{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/kit/dist/index.browser.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/airdrop-internal.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/airdrop.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/compute-limit-internal.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/compute-limit.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/fetch-lookup-tables.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/decompile-transaction-message-fetching-lookup-tables.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/send-transaction-internal.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/send-and-confirm-durable-nonce-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/send-and-confirm-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/voting-web/node_modules/%40solana/kit/src/send-transaction-without-confirming.ts"],"sourcesContent":["import type { Address } from '@solana/addresses';\nimport type { Signature } from '@solana/keys';\nimport type { RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { Commitment, Lamports } from '@solana/rpc-types';\nimport { waitForRecentTransactionConfirmationUntilTimeout } from '@solana/transaction-confirmation';\n\ntype RequestAndConfirmAirdropConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    confirmSignatureOnlyTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) => Promise<void>;\n    lamports: Lamports;\n    recipientAddress: Address;\n    rpc: Rpc<RequestAirdropApi>;\n}>;\n\nexport async function requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmSignatureOnlyTransaction,\n    lamports,\n    recipientAddress,\n    rpc,\n}: RequestAndConfirmAirdropConfig): Promise<Signature> {\n    const airdropTransactionSignature = await rpc\n        .requestAirdrop(recipientAddress, lamports, { commitment })\n        .send({ abortSignal });\n    await confirmSignatureOnlyTransaction({\n        abortSignal,\n        commitment,\n        signature: airdropTransactionSignature,\n    });\n    return airdropTransactionSignature;\n}\n","import type { Signature } from '@solana/keys';\nimport type { GetSignatureStatusesApi, RequestAirdropApi, Rpc } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createRecentSignatureConfirmationPromiseFactory,\n    getTimeoutPromise,\n    waitForRecentTransactionConfirmationUntilTimeout,\n} from '@solana/transaction-confirmation';\n\nimport { requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT } from './airdrop-internal';\n\ntype AirdropFunction = (\n    config: Omit<\n        Parameters<typeof requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmSignatureOnlyTransaction' | 'rpc'\n    >,\n) => Promise<Signature>;\n\ntype AirdropFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link RequestAirdropApi} of the Solana RPC API */\n    rpc: Rpc<GetSignatureStatusesApi & RequestAirdropApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link SignatureNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to airdrop a certain amount of {@link Lamports} to a Solana\n * address.\n *\n * > [!NOTE] This only works on test clusters.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { address, airdropFactory, createSolanaRpc, createSolanaRpcSubscriptions, devnet, lamports } from '@solana/kit';\n *\n * const rpc = createSolanaRpc(devnet('http://127.0.0.1:8899'));\n * const rpcSubscriptions = createSolanaRpcSubscriptions(devnet('ws://127.0.0.1:8900'));\n *\n * const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n *\n * await airdrop({\n *     commitment: 'confirmed',\n *     recipientAddress: address('FnHyam9w4NZoWR6mKN1CuGBritdsEWZQa4Z4oawLZGxa'),\n *     lamports: lamports(10_000_000n),\n * });\n * ```\n */\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'devnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'mainnet'>): AirdropFunction;\nexport function airdropFactory({ rpc, rpcSubscriptions }: AirdropFactoryConfig<'testnet'>): AirdropFunction;\nexport function airdropFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: AirdropFactoryConfig<TCluster>): AirdropFunction {\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmSignatureOnlyTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmationUntilTimeout>[0],\n            'getRecentSignatureConfirmationPromise' | 'getTimeoutPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmationUntilTimeout({\n            ...config,\n            getRecentSignatureConfirmationPromise,\n            getTimeoutPromise,\n        });\n    }\n    return async function airdrop(config) {\n        return await requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmSignatureOnlyTransaction,\n            rpc,\n        });\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { getU32Encoder } from '@solana/codecs';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction, InstructionWithData, isInstructionForProgram, isInstructionWithData } from '@solana/instructions';\nimport { Rpc, SimulateTransactionApi } from '@solana/rpc';\nimport { Blockhash, Commitment, Slot } from '@solana/rpc-types';\nimport {\n    appendTransactionMessageInstruction,\n    CompilableTransactionMessage,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    setTransactionMessageLifetimeUsingBlockhash,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { compileTransaction, getBase64EncodedWireTransaction } from '@solana/transactions';\n\ntype ComputeUnitEstimateForTransactionMessageConfig = Readonly<{\n    abortSignal?: AbortSignal;\n    /**\n     * Compute the estimate as of the highest slot that has reached this level of commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n    rpc: Rpc<SimulateTransactionApi>;\n    transactionMessage: CompilableTransactionMessage | (TransactionMessage & TransactionMessageWithFeePayer);\n}>;\n\nconst COMPUTE_BUDGET_PROGRAM_ADDRESS =\n    'ComputeBudget111111111111111111111111111111' as Address<'ComputeBudget111111111111111111111111111111'>;\n// HACK: Since the `compileTransaction()` method will not compile a transaction with no lifetime we\n// supply a dummy lifetime.\nconst INVALID_BUT_SUFFICIENT_FOR_COMPILATION_BLOCKHASH = {\n    blockhash: '11111111111111111111111111111111' as Blockhash,\n    lastValidBlockHeight: 0n, // This is not included in compiled transactions; it can be anything.\n} as const;\nconst SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX = 0x02;\n\nfunction createComputeUnitLimitInstruction(units: number): Instruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> {\n    const data = new Uint8Array(5);\n    data[0] = SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX;\n    getU32Encoder().write(units, data, 1 /* offset */);\n    return Object.freeze({\n        data,\n        programAddress: COMPUTE_BUDGET_PROGRAM_ADDRESS,\n    });\n}\n\nfunction isSetComputeLimitInstruction(\n    instruction: Instruction,\n): instruction is Instruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & InstructionWithData<Uint8Array> {\n    return (\n        isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n        isInstructionWithData(instruction) &&\n        instruction.data[0] === SET_COMPUTE_UNIT_LIMIT_INSTRUCTION_INDEX\n    );\n}\n\n/**\n * Simulates a transaction message on the network and returns the number of compute units it\n * consumed during simulation.\n *\n * The estimate this function returns can be used to set a compute unit limit on the transaction.\n * Correctly budgeting a compute unit limit for your transaction message can increase the probability\n * that your transaction will be accepted for processing.\n *\n * If you don't declare a compute unit limit on your transaction, validators will assume an upper\n * limit of 200K compute units (CU) per instruction. Since validators have an incentive to pack as\n * many transactions into each block as possible, they may choose to include transactions that they\n * know will fit into the remaining compute budget for the current block over transactions that\n * might not. For this reason, you should set a compute unit limit on each of your transaction\n * messages, whenever possible.\n *\n * ## Example\n *\n * ```ts\n * import { getSetComputeLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage =\n *     getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume.\n * const computeUnitsEstimate =\n *     await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n *\n * > [!WARNING]\n * > The compute unit estimate is just that &ndash; an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n */\nexport async function getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    rpc,\n    transactionMessage,\n    ...simulateConfig\n}: ComputeUnitEstimateForTransactionMessageConfig): Promise<number> {\n    /**\n     * STEP 1: Make sure the transaction message will not fail in simulation for lack of a lifetime\n     *         - either a recent blockhash lifetime or a nonce.\n     */\n    const isDurableNonceTransactionMessage = isTransactionMessageWithDurableNonceLifetime(transactionMessage);\n    let compilableTransactionMessage: CompilableTransactionMessage;\n    if (isDurableNonceTransactionMessage || isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        compilableTransactionMessage = transactionMessage;\n    } else {\n        compilableTransactionMessage = setTransactionMessageLifetimeUsingBlockhash(\n            INVALID_BUT_SUFFICIENT_FOR_COMPILATION_BLOCKHASH,\n            transactionMessage,\n        );\n    }\n    /**\n     * STEP 2: Ensure that the message has a `SetComputeLimit` instruction. The set compute limit\n     *         instruction itself consumes compute units, so it must be included in the simulation.\n     */\n    const existingSetComputeUnitLimitInstructionIndex =\n        transactionMessage.instructions.findIndex(isSetComputeLimitInstruction);\n    const maxComputeUnitLimitInstruction = createComputeUnitLimitInstruction(1_400_000 /* MAX_COMPUTE_UNIT_LIMIT */);\n    if (existingSetComputeUnitLimitInstructionIndex === -1) {\n        compilableTransactionMessage = appendTransactionMessageInstruction(\n            maxComputeUnitLimitInstruction,\n            compilableTransactionMessage,\n        ) as CompilableTransactionMessage;\n    } else {\n        const nextInstructions = [...compilableTransactionMessage.instructions];\n        nextInstructions.splice(existingSetComputeUnitLimitInstructionIndex, 1, maxComputeUnitLimitInstruction);\n        compilableTransactionMessage = Object.freeze({\n            ...compilableTransactionMessage,\n            instructions: nextInstructions,\n        } as typeof compilableTransactionMessage);\n    }\n    /**\n     * STEP 3: Simulate the transaction to measure its compute unit consumption.\n     */\n    const compiledTransaction = compileTransaction(compilableTransactionMessage);\n    const wireTransactionBytes = getBase64EncodedWireTransaction(compiledTransaction);\n    try {\n        const {\n            value: { err: transactionError, unitsConsumed },\n        } = await rpc\n            .simulateTransaction(wireTransactionBytes, {\n                ...simulateConfig,\n                encoding: 'base64',\n                replaceRecentBlockhash: !isDurableNonceTransactionMessage,\n                sigVerify: false,\n            })\n            .send({ abortSignal });\n        if (unitsConsumed == null) {\n            // This should never be hit, because all RPCs should support `unitsConsumed` by now.\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT);\n        }\n        // FIXME(https://github.com/anza-xyz/agave/issues/1295): The simulation response returns\n        // compute units as a u64, but the `SetComputeLimit` instruction only accepts a u32. Until\n        // this changes, downcast it.\n        const downcastUnitsConsumed = unitsConsumed > 4_294_967_295n ? 4_294_967_295 : Number(unitsConsumed);\n        if (transactionError) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT, {\n                cause: transactionError,\n                unitsConsumed: downcastUnitsConsumed,\n            });\n        }\n        return downcastUnitsConsumed;\n    } catch (e) {\n        if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT)) throw e;\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT, {\n            cause: e,\n        });\n    }\n}\n","import { Rpc, SimulateTransactionApi } from '@solana/rpc';\nimport {\n    CompilableTransactionMessage,\n    TransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport { getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT } from './compute-limit-internal';\n\ntype ComputeUnitEstimateForTransactionMessageFactoryConfig = Readonly<{\n    /** An object that supports the {@link SimulateTransactionApi} of the Solana RPC API */\n    rpc: Rpc<SimulateTransactionApi>;\n}>;\ntype ComputeUnitEstimateForTransactionMessageFunction = (\n    transactionMessage: CompilableTransactionMessage | (TransactionMessage & TransactionMessageWithFeePayer),\n    config?: Omit<\n        Parameters<typeof getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'rpc' | 'transactionMessage'\n    >,\n) => Promise<number>;\n\n/**\n * Use this utility to estimate the actual compute unit cost of a given transaction message.\n *\n * Correctly budgeting a compute unit limit for your transaction message can increase the\n * probability that your transaction will be accepted for processing. If you don't declare a compute\n * unit limit on your transaction, validators will assume an upper limit of 200K compute units (CU)\n * per instruction.\n *\n * Since validators have an incentive to pack as many transactions into each block as possible, they\n * may choose to include transactions that they know will fit into the remaining compute budget for\n * the current block over transactions that might not. For this reason, you should set a compute\n * unit limit on each of your transaction messages, whenever possible.\n *\n * > [!WARNING]\n * > The compute unit estimate is just that -- an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n *\n * > [!INFO]\n * > In the event that a transaction message does not already have a `SetComputeUnitLimit`\n * > instruction, this function will add one before simulation. This ensures that the compute unit\n * > consumption of the `SetComputeUnitLimit` instruction itself is included in the estimate.\n *\n * @param config\n *\n * @deprecated Use `estimateComputeUnitLimitFactory` from `@solana-program/compute-budget` instead.\n *\n * @example\n * ```ts\n * import { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage = getComputeUnitEstimateForTransactionMessageFactory({\n *     rpc,\n * });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume. This is done by\n * // simulating the transaction and grabbing the estimated compute units from the result.\n * const computeUnitsEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n */\nexport function getComputeUnitEstimateForTransactionMessageFactory({\n    rpc,\n}: ComputeUnitEstimateForTransactionMessageFactoryConfig): ComputeUnitEstimateForTransactionMessageFunction {\n    return async function getComputeUnitEstimateForTransactionMessage(transactionMessage, config) {\n        return await getComputeUnitEstimateForTransactionMessage_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transactionMessage,\n        });\n    };\n}\n","import {\n    assertAccountsDecoded,\n    assertAccountsExist,\n    type FetchAccountsConfig,\n    fetchJsonParsedAccounts,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport { type AddressesByLookupTableAddress } from '@solana/transaction-messages';\n\ntype FetchedAddressLookup = {\n    addresses: Address[];\n};\n\n/**\n * Given a list of addresses belonging to address lookup tables, returns a map of lookup table\n * addresses to an ordered array of the addresses they contain.\n *\n * @param rpc An object that supports the {@link GetMultipleAccountsApi} of the Solana RPC API\n * @param config\n */\nexport async function fetchAddressesForLookupTables(\n    lookupTableAddresses: Address[],\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: FetchAccountsConfig,\n): Promise<AddressesByLookupTableAddress> {\n    if (lookupTableAddresses.length === 0) {\n        return {};\n    }\n\n    const fetchedLookupTables = await fetchJsonParsedAccounts<FetchedAddressLookup[]>(\n        rpc,\n        lookupTableAddresses,\n        config,\n    );\n\n    assertAccountsDecoded(fetchedLookupTables);\n    assertAccountsExist(fetchedLookupTables);\n\n    return fetchedLookupTables.reduce<AddressesByLookupTableAddress>((acc, lookup) => {\n        return {\n            ...acc,\n            [lookup.address]: lookup.data.addresses,\n        };\n    }, {});\n}\n","import { type FetchAccountsConfig } from '@solana/accounts';\nimport type { GetMultipleAccountsApi, Rpc } from '@solana/rpc';\nimport {\n    CompilableTransactionMessage,\n    CompiledTransactionMessage,\n    decompileTransactionMessage,\n} from '@solana/transaction-messages';\n\nimport { fetchAddressesForLookupTables } from './fetch-lookup-tables';\n\ntype DecompileTransactionMessageFetchingLookupTablesConfig = FetchAccountsConfig & {\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Returns a {@link TransactionMessage} from a {@link CompiledTransactionMessage}. If any of the\n * accounts in the compiled message require an address lookup table to find their address, this\n * function will use the supplied RPC instance to fetch the contents of the address lookup table\n * from the network.\n *\n * @param rpc An object that supports the {@link GetMultipleAccountsApi} of the Solana RPC API\n * @param config\n */\nexport async function decompileTransactionMessageFetchingLookupTables(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    rpc: Rpc<GetMultipleAccountsApi>,\n    config?: DecompileTransactionMessageFetchingLookupTablesConfig,\n): Promise<CompilableTransactionMessage> {\n    const lookupTables =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? compiledTransactionMessage.addressTableLookups\n            : [];\n    const lookupTableAddresses = lookupTables.map(l => l.lookupTableAddress);\n\n    const { lastValidBlockHeight, ...fetchAccountsConfig } = config ?? {};\n    const addressesByLookupTableAddress =\n        lookupTableAddresses.length > 0\n            ? await fetchAddressesForLookupTables(lookupTableAddresses, rpc, fetchAccountsConfig)\n            : {};\n\n    return decompileTransactionMessage(compiledTransactionMessage, {\n        addressesByLookupTableAddress,\n        lastValidBlockHeight,\n    });\n}\n","import type { Signature } from '@solana/keys';\nimport type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { Commitment, commitmentComparator } from '@solana/rpc-types';\nimport {\n    TransactionWithLastValidBlockHeight,\n    waitForDurableNonceTransactionConfirmation,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport {\n    FullySignedTransaction,\n    getBase64EncodedWireTransaction,\n    TransactionWithDurableNonceLifetime,\n} from '@solana/transactions';\n\ninterface SendAndConfirmDurableNonceTransactionConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmDurableNonceTransaction: (\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: FullySignedTransaction & TransactionWithDurableNonceLifetime;\n}\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n    extends SendTransactionBaseConfig,\n        SendTransactionConfigWithoutEncoding {\n    confirmRecentTransaction: (\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) => Promise<void>;\n    transaction: FullySignedTransaction & TransactionWithLastValidBlockHeight;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n    abortSignal?: AbortSignal;\n    commitment: Commitment;\n    rpc: Rpc<SendTransactionApi>;\n    transaction: FullySignedTransaction;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n    NonNullable<Parameters<SendTransactionApi['sendTransaction']>[1]>,\n    'encoding'\n>;\n\nfunction getSendTransactionConfigWithAdjustedPreflightCommitment(\n    commitment: Commitment,\n    config?: SendTransactionConfigWithoutEncoding,\n): SendTransactionConfigWithoutEncoding | void {\n    if (\n        // The developer has supplied no value for `preflightCommitment`.\n        !config?.preflightCommitment &&\n        // The value of `commitment` is lower than the server default of `preflightCommitment`.\n        commitmentComparator(commitment, 'finalized' /* default value of `preflightCommitment` */) < 0\n    ) {\n        return {\n            ...config,\n            // In the common case, it is unlikely that you want to simulate a transaction at\n            // `finalized` commitment when your standard of commitment for confirming the\n            // transaction is lower. Cap the simulation commitment level to the level of the\n            // confirmation commitment.\n            preflightCommitment: commitment,\n        };\n    }\n    // The commitment at which the developer wishes to confirm the transaction is at least as\n    // high as the commitment at which they want to simulate it. Honour the config as-is.\n    return config;\n}\n\nexport async function sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendTransactionBaseConfig): Promise<Signature> {\n    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(transaction);\n    return await rpc\n        .sendTransaction(base64EncodedWireTransaction, {\n            ...getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, sendTransactionConfig),\n            encoding: 'base64',\n        })\n        .send({ abortSignal });\n}\n\nexport async function sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmDurableNonceTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmDurableNonceTransactionConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmDurableNonceTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n\nexport async function sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n    abortSignal,\n    commitment,\n    confirmRecentTransaction,\n    rpc,\n    transaction,\n    ...sendTransactionConfig\n}: SendAndConfirmTransactionWithBlockhashLifetimeConfig): Promise<Signature> {\n    const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n        ...sendTransactionConfig,\n        abortSignal,\n        commitment,\n        rpc,\n        transaction,\n    });\n    await confirmRecentTransaction({\n        abortSignal,\n        commitment,\n        transaction,\n    });\n    return transactionSignature;\n}\n","import type { GetAccountInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { AccountNotificationsApi, RpcSubscriptions, SignatureNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createNonceInvalidationPromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    waitForDurableNonceTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport { FullySignedTransaction, TransactionWithDurableNonceLifetime } from '@solana/transactions';\n\nimport { sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmDurableNonceTransactionFunction = (\n    transaction: FullySignedTransaction & TransactionWithDurableNonceLifetime,\n    config: Omit<\n        Parameters<typeof sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmDurableNonceTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<GetAccountInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link AccountNotificationsApi} and the {@link SignatureNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<AccountNotificationsApi & SignatureNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to send a nonce-based transaction to the network and to wait\n * until it has been confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import {\n *     isSolanaError,\n *     sendAndConfirmDurableNonceTransactionFactory,\n *     SOLANA_ERROR__INVALID_NONCE,\n *     SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n * } from '@solana/kit';\n *\n * const sendAndConfirmNonceTransaction = sendAndConfirmDurableNonceTransactionFactory({ rpc, rpcSubscriptions });\n *\n * try {\n *     await sendAndConfirmNonceTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND)) {\n *         console.error(\n *             'The lifetime specified by this transaction refers to a nonce account ' +\n *                 `\\`${e.context.nonceAccountAddress}\\` that does not exist`,\n *         );\n *     } else if (isSolanaError(e, SOLANA_ERROR__INVALID_NONCE)) {\n *         console.error('This transaction depends on a nonce that is no longer valid');\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'devnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'testnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<'mainnet'>): SendAndConfirmDurableNonceTransactionFunction;\nexport function sendAndConfirmDurableNonceTransactionFactory<\n    TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void,\n>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmDurableNonceTransactionFactoryConfig<TCluster>): SendAndConfirmDurableNonceTransactionFunction {\n    const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({ rpc, rpcSubscriptions } as Parameters<\n        typeof createNonceInvalidationPromiseFactory\n    >[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmDurableNonceTransaction(\n        config: Omit<\n            Parameters<typeof waitForDurableNonceTransactionConfirmation>[0],\n            'getNonceInvalidationPromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForDurableNonceTransactionConfirmation({\n            ...config,\n            getNonceInvalidationPromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmDurableNonceTransaction(transaction, config) {\n        await sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmDurableNonceTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n","import type { GetEpochInfoApi, GetSignatureStatusesApi, Rpc, SendTransactionApi } from '@solana/rpc';\nimport type { RpcSubscriptions, SignatureNotificationsApi, SlotNotificationsApi } from '@solana/rpc-subscriptions';\nimport {\n    createBlockHeightExceedencePromiseFactory,\n    createRecentSignatureConfirmationPromiseFactory,\n    TransactionWithLastValidBlockHeight,\n    waitForRecentTransactionConfirmation,\n} from '@solana/transaction-confirmation';\nimport { FullySignedTransaction } from '@solana/transactions';\n\nimport { sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFunction = (\n    transaction: FullySignedTransaction & TransactionWithLastValidBlockHeight,\n    config: Omit<\n        Parameters<typeof sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT>[0],\n        'confirmRecentTransaction' | 'rpc' | 'transaction'\n    >,\n) => Promise<void>;\n\ntype SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster> = {\n    /** An object that supports the {@link GetSignatureStatusesApi} and the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi> & { '~cluster'?: TCluster };\n    /** An object that supports the {@link SignatureNotificationsApi} and the {@link SlotNotificationsApi} of the Solana RPC Subscriptions API */\n    rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & { '~cluster'?: TCluster };\n};\n\n/**\n * Returns a function that you can call to send a blockhash-based transaction to the network and to\n * wait until it has been confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { isSolanaError, sendAndConfirmTransactionFactory, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED } from '@solana/kit';\n *\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * try {\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n *         console.error('This transaction depends on a blockhash that has expired');\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'devnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'testnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<'mainnet'>): SendAndConfirmTransactionWithBlockhashLifetimeFunction;\nexport function sendAndConfirmTransactionFactory<TCluster extends 'devnet' | 'mainnet' | 'testnet' | void = void>({\n    rpc,\n    rpcSubscriptions,\n}: SendAndConfirmTransactionWithBlockhashLifetimeFactoryConfig<TCluster>): SendAndConfirmTransactionWithBlockhashLifetimeFunction {\n    const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createBlockHeightExceedencePromiseFactory>[0]);\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n        rpc,\n        rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n    async function confirmRecentTransaction(\n        config: Omit<\n            Parameters<typeof waitForRecentTransactionConfirmation>[0],\n            'getBlockHeightExceedencePromise' | 'getRecentSignatureConfirmationPromise'\n        >,\n    ) {\n        await waitForRecentTransactionConfirmation({\n            ...config,\n            getBlockHeightExceedencePromise,\n            getRecentSignatureConfirmationPromise,\n        });\n    }\n    return async function sendAndConfirmTransaction(transaction, config) {\n        await sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            confirmRecentTransaction,\n            rpc,\n            transaction,\n        });\n    };\n}\n","import type { Rpc, SendTransactionApi } from '@solana/rpc';\nimport { FullySignedTransaction } from '@solana/transactions';\n\nimport { sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT } from './send-transaction-internal';\n\ntype SendTransactionWithoutConfirmingFunction = (\n    transaction: FullySignedTransaction,\n    config: Omit<Parameters<typeof sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT>[0], 'rpc' | 'transaction'>,\n) => Promise<void>;\n\ninterface SendTransactionWithoutConfirmingFactoryConfig {\n    /** An object that supports the {@link SendTransactionApi} of the Solana RPC API */\n    rpc: Rpc<SendTransactionApi>;\n}\n\n/**\n * Returns a function that you can call to send a transaction with any kind of lifetime to the\n * network without waiting for it to be confirmed.\n *\n * @param config\n *\n * @example\n * ```ts\n * import {\n *     sendTransactionWithoutConfirmingFactory,\n *     SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n * } from '@solana/kit';\n *\n * const sendTransaction = sendTransactionWithoutConfirmingFactory({ rpc });\n *\n * try {\n *     await sendTransaction(transaction, { commitment: 'confirmed' });\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE)) {\n *         console.error('The transaction failed in simulation', e.cause);\n *     } else {\n *         throw e;\n *     }\n * }\n * ```\n */\nexport function sendTransactionWithoutConfirmingFactory({\n    rpc,\n}: SendTransactionWithoutConfirmingFactoryConfig): SendTransactionWithoutConfirmingFunction {\n    return async function sendTransactionWithoutConfirming(transaction, config) {\n        await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({\n            ...config,\n            rpc,\n            transaction,\n        });\n    };\n}\n"],"names":["getBase64EncodedWireTransaction","createRecentSignatureConfirmationPromiseFactory"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA,eAAsB,oDAAqD,MAOpB,EAAA;UANnD,WAAA,EACA,UAAA,EACA,+BAAA,EACA,QAAA,EACA,gBAAA,EACA,GAAA,KANuE;IAQvE,MAAM,2BAA8B,GAAA,MAAM,GACrC,CAAA,cAAA,CAAe,gBAAkB,EAAA,QAAA,EAAU;QAAE,UAAA;IAAA,CAAY,CAAA,CACzD,IAAK,CAAA;QAAE;IAAA,CAAa,CAAA;IACzB,MAAM,+BAAgC,CAAA;QAClC,WAAA;QACA,UAAA;QACA,SAAW,EAAA;IAAA,CACd,CAAA;IACM,OAAA,2BAAA;AACX;;ACeO,SAAS,cAAgF;UAC5F,GAAA,EACA,gBAAA,EACgD,EAAA,CAH4C;IAI5F,MAAM,wCAAwC,8OAAA,AAAgD,EAAA;QAC1F,GAAA;QACA;IAAA,CACsE,CAAA;IAC1E,eAAe,gCACX,MAIF,EAAA;QACE,kMAAM,mDAAA,AAAiD,EAAA;YACnD,GAAG,MAAA;YACH,qCAAA;uNACA,oBAAA;QAAA,CACH,CAAA;IAAA;IAEE,OAAA,eAAe,QAAQ,MAAQ,EAAA;QAClC,OAAO,MAAM,oDAAqD,CAAA;YAC9D,GAAG,MAAA;YACH,+BAAA;YACA;QAAA,CACH,CAAA;IAAA,CACL;AACJ;ACrCA,IAAM,8BACF,GAAA,6CAAA;AAGJ,IAAM,gDAAmD,GAAA;IACrD,SAAW,EAAA,kCAAA;IACX,oBAAsB,EAAA,EAAA;AAC1B,CAAA;AACA,IAAM,wCAA2C,GAAA,CAAA;AAEjD,SAAS,kCAAkC,KAAmE,EAAA;IACpG,MAAA,IAAA,GAAO,IAAI,UAAA,CAAW,CAAC,CAAA;IAC7B,IAAA,CAAK,CAAC,CAAI,GAAA,wCAAA;2NACV,iBAAA,EAAgB,EAAA,KAAA,CAAM,KAAA,EAAO,IAAA,EAAM;IACnC,OAAO,OAAO,MAAO,CAAA;QACjB,IAAA;QACA,cAAgB,EAAA;IAAA,CACnB,CAAA;AACL;AAEA,SAAS,6BACL,WACmG,EAAA;IAE/F,uNAAA,0BAAA,EAAwB,WAAa,EAAA,8BAA8B,CACnE,oNAAA,wBAAA,EAAsB,WAAW,CACjC,IAAA,WAAA,CAAY,IAAK,CAAA,CAAC,CAAM,KAAA,wCAAA;AAEhC;AA2DA,eAAsB,uEAAwE,MAK1B,EAAA;UAJhE,WAAA,EACA,GAAA,EACA,kBAAA,EACA,GAAG,mBAJuF;IAUpF,MAAA,gCAAA,GAAmC,0QAAA,EAA6C,kBAAkB,CAAA;IACpG,IAAA,4BAAA;IACA,IAAA,gCAAA,8NAAoC,6CAAA,AAA0C,EAAA,kBAAkB,CAAG,EAAA;QACpE,4BAAA,GAAA,kBAAA;IAAA,CAC5B,MAAA;QAC4B,4BAAA,8NAAA,8CAAA,EAC3B,gDAAA,EACA;IACJ;IAMJ,MAAM,2CACF,GAAA,kBAAA,CAAmB,YAAa,CAAA,SAAA,CAAU,4BAA4B,CAAA;IAC1E,MAAM,8BAAiC,GAAA,iCAAA,CAAkC;IACzE,IAAI,gDAAgD,CAAA,CAAI,EAAA;QACrB,4BAAA,8NAAA,sCAAA,EAC3B,8BAAA,EACA;IACJ,CACG,MAAA;QACH,MAAM,gBAAmB,GAAA,CAAC;eAAG,4BAAA,CAA6B,YAAY;SAAA;QACrD,gBAAA,CAAA,MAAA,CAAO,2CAA6C,EAAA,CAAA,EAAG,8BAA8B,CAAA;QACtG,4BAAA,GAA+B,OAAO,MAAO,CAAA;YACzC,GAAG,4BAAA;YACH,YAAc,EAAA;QAAA,CACsB,CAAA;IAAA;IAKtC,MAAA,mBAAA,IAAsB,oOAAA,EAAmB,4BAA4B,CAAA;IACrE,MAAA,oBAAA,mNAAuB,kCAAA,EAAgC,mBAAmB,CAAA;IAC5E,IAAA;QACM,MAAA,EACF,KAAO,EAAA,EAAE,GAAK,EAAA,gBAAA,EAAkB,aAAc,EAAA,EAC9C,GAAA,MAAM,GACL,CAAA,mBAAA,CAAoB,oBAAsB,EAAA;YACvC,GAAG,cAAA;YACH,QAAU,EAAA,QAAA;YACV,wBAAwB,CAAC,gCAAA;YACzB,SAAW,EAAA;QAAA,CACd,CAAA,CACA,IAAK,CAAA;YAAE;QAAA,CAAa,CAAA;QACzB,IAAI,iBAAiB,IAAM,EAAA;YAEjB,MAAA,0MAAI,cAAA,uMAAY,8DAA2D,CAAA;QAAA;QAKrF,MAAM,qBAAwB,GAAA,aAAA,GAAgB,WAAiB,GAAA,UAAA,GAAgB,OAAO,aAAa,CAAA;QACnG,IAAI,gBAAkB,EAAA;YACZ,MAAA,0MAAI,cAAA,uMAAY,8EAA6E,EAAA;gBAC/F,KAAO,EAAA,gBAAA;gBACP,aAAe,EAAA;YAAA,CAClB,CAAA;QAAA;QAEE,OAAA,qBAAA;IAAA,EAAA,OACF,CAAG,EAAA;QACR,QAAI,sNAAA,AAAc,EAAA,CAAA,wMAAG,8EAA2E,CAAA,EAAS,MAAA,CAAA;QACnG,MAAA,0MAAI,cAAA,uMAAY,8DAA6D,EAAA;YAC/E,KAAO,EAAA;QAAA,CACV,CAAA;IAAA;AAET;;ACzHO,SAAS,kDAAmD,CAAA;UAC/D,GAAA,EACwG,EAAA;IACjG,OAAA,eAAe,2CAA4C,CAAA,kBAAA,EAAoB,MAAQ,EAAA;QAC1F,OAAO,MAAM,uEAAwE,CAAA;YACjF,GAAG,MAAA;YACH,GAAA;YACA;QAAA,CACH,CAAA;IAAA,CACL;AACJ;AC1EA,eAAsB,6BAAA,CAClB,oBACA,EAAA,GAAA,EACA,MACsC,EAAA;IAClC,IAAA,oBAAA,CAAqB,MAAA,KAAW,CAAG,EAAA;QACnC,OAAO,CAAA,CAAC;IAAA;IAGZ,MAAM,sBAAsB,+KAAM,0BAAA,EAC9B,GAAA,EACA,oBAAA,EACA;IAGJ,iMAAA,EAAsB,mBAAmB,CAAA;6KACzC,sBAAA,EAAoB,mBAAmB,CAAA;IAEvC,OAAO,mBAAoB,CAAA,MAAA,CAAsC,CAAC,GAAA,EAAK,MAAW,KAAA;QACvE,OAAA;YACH,GAAG,GAAA;YACH,CAAC,MAAA,CAAO,OAAO,CAAA,EAAG,OAAO,IAAK,CAAA,SAAA;QAAA,CAClC;IAAA,CACJ,EAAG,CAAA,CAAE,CAAA;AACT;;ACtBA,eAAsB,+CAAA,CAClB,0BACA,EAAA,GAAA,EACA,MACqC,EAAA;IACrC,MAAM,YACF,GAAA,qBAAA,IAAyB,0BACzB,IAAA,0BAAA,CAA2B,mBAAwB,KAAA,KAAA,CAAA,IACnD,0BAA2B,CAAA,mBAAA,CAAoB,MAAS,GAAA,CAAA,GAClD,0BAA2B,CAAA,mBAAA,GAC3B,EAAC;IACX,MAAM,oBAAuB,GAAA,YAAA,CAAa,GAAI,CAAA,CAAA,CAAA,GAAK,EAAE,kBAAkB,CAAA;IAEvE,MAAM,EAAE,oBAAsB,EAAA,GAAG,mBAAoB,EAAA,0CAAI,SAAU,CAAA,CAAC;IAC9D,MAAA,6BAAA,GACF,oBAAqB,CAAA,MAAA,GAAS,CACxB,GAAA,MAAM,8BAA8B,oBAAsB,EAAA,GAAA,EAAK,mBAAmB,CAAA,GAClF,CAAA,CAAC;IAEX,kOAAO,8BAAA,EAA4B,0BAA4B,EAAA;QAC3D,6BAAA;QACA;IAAA,CACH,CAAA;AACL;ACIA,SAAS,uDAAA,CACL,UAAA,EACA,MAC2C,EAAA;IAC3C,IAAA,iEAAA;IAEI,kDAAC,MAAQ,CAAA,mBAAA,KAAA,uFAAA;oNAET,uBAAA,EAAqB,UAAA,EAAY,eAA4D,GAC/F;QACS,OAAA;YACH,GAAG,MAAA;YAAA,gFAAA;YAAA,6EAAA;YAAA,gFAAA;YAAA,2BAAA;YAKH,mBAAqB,EAAA;QAAA,CACzB;IAAA;IAIG,OAAA,MAAA;AACX;AAEA,eAAsB,2CAA4C,CAAA,KAMhB,EAAA;UAL9C,WAAA,EACA,UAAA,EACA,GAAA,EACA,WAAA,EACA,GAAG;IAEG,MAAA,4BAAA,GAA+BA,kPAAAA,EAAgC,WAAW,CAAA;IACzE,OAAA,MAAM,GACR,CAAA,eAAA,CAAgB,4BAA8B,EAAA;QAC3C,GAAG,uDAAwD,CAAA,UAAA,EAAY,qBAAqB,CAAA;QAC5F,QAAU,EAAA;IAAA,CACb,CAAA,CACA,IAAK,CAAA;QAAE;IAAA,CAAa,CAAA;AAC7B;AAEA,eAAsB,iEAAkE;UACpF,WAAA,EACA,UAAA,EACA,8BAAA,EACA,GAAA,EACA,WAAA,EACA,GAAG,uBAC6D,EAAA,CAPoB;IAQ9E,MAAA,oBAAA,GAAuB,MAAM,2CAA4C,CAAA;QAC3E,GAAG,qBAAA;QACH,WAAA;QACA,UAAA;QACA,GAAA;QACA;IAAA,CACH,CAAA;IACD,MAAM,8BAA+B,CAAA;QACjC,WAAA;QACA,UAAA;QACA;IAAA,CACH,CAAA;IACM,OAAA,oBAAA;AACX;AAEA,eAAsB,0EAA2E,MAOpB,EAAA;UANzE,WAAA,EACA,UAAA,EACA,wBAAA,EACA,GAAA,EACA,WAAA,EACA,GAAG,0BAN0F;IAQvF,MAAA,oBAAA,GAAuB,MAAM,2CAA4C,CAAA;QAC3E,GAAG,qBAAA;QACH,WAAA;QACA,UAAA;QACA,GAAA;QACA;IAAA,CACH,CAAA;IACD,MAAM,wBAAyB,CAAA;QAC3B,WAAA;QACA,UAAA;QACA;IAAA,CACH,CAAA;IACM,OAAA,oBAAA;AACX;;AC/DO,SAAS,4CAEd;UACE,GAAA,EACA,gBAAA,EAC4G,EAAA,CAH9G;IAIE,MAAM,2BAA8B,+LAAA,wCAAA,EAAsC;QAAE,GAAA;QAAK;IAAA,CAE7E,CAAA;IACJ,MAAM,oOAAwCC,kDAAAA,AAAgD,EAAA;QAC1F,GAAA;QACA;IAAA,CACsE,CAAA;IAC1E,eAAe,+BACX,MAIF,EAAA;QACE,kMAAM,6CAAA,AAA2C,EAAA;YAC7C,GAAG,MAAA;YACH,2BAAA;YACA;QAAA,CACH,CAAA;IAAA;IAEE,OAAA,eAAe,qCAAsC,CAAA,WAAA,EAAa,MAAQ,EAAA;QAC7E,MAAM,iEAAkE,CAAA;YACpE,GAAG,MAAA;YACH,8BAAA;YACA,GAAA;YACA;QAAA,CACH,CAAA;IAAA,CACL;AACJ;AC1CO,SAAS,gCAAkG;UAC9G,GAAA,EACA,gBAAA,EAC8H,EAAA,CAHhB;IAI9G,MAAM,8NAAkC,4CAAA,AAA0C,EAAA;QAC9E,GAAA;QACA;IAAA,CACgE,CAAA;IACpE,MAAM,oOAAwCA,kDAAAA,AAAgD,EAAA;QAC1F,GAAA;QACA;IAAA,CACsE,CAAA;IAC1E,eAAe,yBACX,MAIF,EAAA;QACE,OAAM,kOAAA,AAAqC,EAAA;YACvC,GAAG,MAAA;YACH,+BAAA;YACA;QAAA,CACH,CAAA;IAAA;IAEE,OAAA,eAAe,yBAA0B,CAAA,WAAA,EAAa,MAAQ,EAAA;QACjE,MAAM,0EAA2E,CAAA;YAC7E,GAAG,MAAA;YACH,wBAAA;YACA,GAAA;YACA;QAAA,CACH,CAAA;IAAA,CACL;AACJ;;ACrDO,SAAS,uCAAwC;UACpD,GAAA,EACwF,EAAA,CAFpC;IAG7C,OAAA,eAAe,gCAAiC,CAAA,WAAA,EAAa,MAAQ,EAAA;QACxE,MAAM,2CAA4C,CAAA;YAC9C,GAAG,MAAA;YACH,GAAA;YACA;QAAA,CACH,CAAA;IAAA,CACL;AACJ","debugId":null}}]
}