{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/gill/dist/index.browser.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/debug.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/const.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/utils.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/rpc.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/explorer.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/create-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/send-and-confirm-transaction-with-signers.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/compute-budget/utils.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/base64-to-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/prepare-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/simulate-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/create-solana-client.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/keypairs-extractable.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/keypairs-base58.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/base64-from-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/get-oldest-signature.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/insert-reference-key.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/create-codama-config.ts"],"sourcesContent":["/**\n *\n */\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nconst GILL_LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\ndeclare global {\n  /**\n   * Whether or not to enable debug mode. When enabled, default log level of `info`\n   */\n  var __GILL_DEBUG__: boolean | undefined;\n  /**\n   * Set the a desired level of logs to be output in the application\n   *\n   * - Default: `info`\n   * - Options: `debug` | `info` | `warn` | `error`\n   */\n  var __GILL_DEBUG_LEVEL__: LogLevel | undefined;\n}\n\nconst getMinLogLevel = (): LogLevel =>\n  (process.env.GILL_DEBUG_LEVEL as LogLevel) ||\n  global.__GILL_DEBUG_LEVEL__ ||\n  (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG_LEVEL__) ||\n  \"info\";\n\n/**\n * Check if the `gill` debug logger is enabled or not\n */\nexport const isDebugEnabled = (): boolean =>\n  Boolean(\n    process.env.GILL_DEBUG_LEVEL ||\n      global.__GILL_DEBUG_LEVEL__ ||\n      process.env.GILL_DEBUG === \"true\" ||\n      process.env.GILL_DEBUG === \"1\" ||\n      global.__GILL_DEBUG__ === true ||\n      (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG__ === true),\n  );\n\n/**\n * Log debug messages based on the desired application's logging level.\n *\n * @param message - the message contents to be logged\n * @param level - default: `info` (see: {@link GILL_LOG_LEVELS})\n * @param prefix - default: `[GILL]`\n *\n * To enable gill's debug logger, set any of the following to `true`:\n * - `process.env.GILL_DEBUG`\n * - `global.__GILL_DEBUG__`\n * - `window.__GILL_DEBUG__`\n *\n * To set a desired level of logs to be output in the application, set the value of one of the following:\n * - `process.env.GILL_DEBUG_LEVEL`\n * - `global.__GILL_DEBUG_LEVEL__`\n * - `window.__GILL_DEBUG_LEVEL__`\n */\nexport function debug(message: unknown, level: LogLevel = \"info\", prefix: string = \"[GILL]\") {\n  if (!isDebugEnabled()) return;\n\n  if (GILL_LOG_LEVELS[level] < GILL_LOG_LEVELS[getMinLogLevel()]) return;\n\n  const formattedMessage = typeof message === \"string\" ? message : JSON.stringify(message, null, 2);\n\n  switch (level) {\n    case \"debug\":\n      console.log(prefix, formattedMessage);\n      break;\n    case \"info\":\n      console.info(prefix, formattedMessage);\n      break;\n    case \"warn\":\n      console.warn(prefix, formattedMessage);\n      break;\n    case \"error\":\n      console.error(prefix, formattedMessage);\n      break;\n  }\n}\n","/** 1 billion lamports per SOL */\nexport const LAMPORTS_PER_SOL = 1_000_000_000;\n\n/**\n * Genesis hash for Solana network clusters\n */\nexport const GENESIS_HASH = {\n  mainnet: \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\",\n  devnet: \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\",\n  testnet: \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\",\n};\n","import {\n  assertIsTransactionSigner,\n  createNoopSigner,\n  isTransactionSigner,\n  type Address,\n  type TransactionSigner,\n} from \"@solana/kit\";\nimport type { SolanaClusterMoniker } from \"../types\";\nimport { GENESIS_HASH } from \"./const\";\n\n/**\n * Determine the Solana moniker from its genesis hash\n *\n * If the hash is NOT known, returns `unknown`\n */\nexport function getMonikerFromGenesisHash(hash: string): SolanaClusterMoniker | \"unknown\" {\n  switch (hash) {\n    case GENESIS_HASH.mainnet:\n      return \"mainnet\";\n    case GENESIS_HASH.devnet:\n      return \"devnet\";\n    case GENESIS_HASH.testnet:\n      return \"testnet\";\n    default:\n      return \"unknown\";\n  }\n}\n\nexport function checkedAddress<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): Address<TAddress> {\n  return typeof input == \"string\" ? input : input.address;\n}\n\nexport function checkedTransactionSigner<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): TransactionSigner<TAddress> {\n  if (typeof input === \"string\" || \"address\" in input == false) input = createNoopSigner(input);\n  if (!isTransactionSigner(input)) throw new Error(\"A signer or address is required\");\n  assertIsTransactionSigner(input);\n  return input;\n}\n\n/**\n * Convert a lamport number to the human readable string of a SOL value\n */\nexport function lamportsToSol(lamports: bigint | number): string {\n  // @ts-expect-error This format is valid\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits: 9 }).format(`${lamports}E-9`);\n}\n","import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport type { LocalnetUrl, ModifiedClusterUrl, SolanaClusterMoniker } from \"../types/rpc\";\n\nexport function localnet(putativeString: string): LocalnetUrl {\n  return putativeString as LocalnetUrl;\n}\n\n/**\n * Get a public Solana RPC endpoint for a cluster based on its moniker\n *\n * Note: These RPC URLs are rate limited and not suitable for production applications.\n */\nexport function getPublicSolanaRpcUrl(\n  cluster: SolanaClusterMoniker | \"mainnet-beta\" | \"localhost\",\n): ModifiedClusterUrl {\n  switch (cluster) {\n    case \"devnet\":\n      return \"https://api.devnet.solana.com\" as DevnetUrl;\n    case \"testnet\":\n      return \"https://api.testnet.solana.com\" as TestnetUrl;\n    case \"mainnet-beta\":\n    case \"mainnet\":\n      return \"https://api.mainnet-beta.solana.com\" as MainnetUrl;\n    case \"localnet\":\n    case \"localhost\":\n      return \"http://127.0.0.1:8899\" as LocalnetUrl;\n    default:\n      throw new Error(\"Invalid cluster moniker\");\n  }\n}\n","import type { GetExplorerLinkArgs } from \"../types\";\n\n/**\n * Craft a Solana Explorer link on any cluster\n */\nexport function getExplorerLink(props: GetExplorerLinkArgs = {}): string {\n  let url = new URL(\"https://explorer.solana.com\");\n\n  // default to mainnet / mainnet-beta\n  if (!props.cluster || props.cluster == \"mainnet\") props.cluster = \"mainnet-beta\";\n\n  if (\"address\" in props) {\n    url.pathname = `/address/${props.address}`;\n  } else if (\"transaction\" in props) {\n    url.pathname = `/tx/${props.transaction}`;\n  } else if (\"block\" in props) {\n    url.pathname = `/block/${props.block}`;\n  }\n\n  if (props.cluster !== \"mainnet-beta\") {\n    if (props.cluster === \"localnet\" || props.cluster === \"localhost\") {\n      // localnet technically isn't a cluster, so requires special handling\n      url.searchParams.set(\"cluster\", \"custom\");\n      url.searchParams.set(\"customUrl\", \"http://localhost:8899\");\n    } else {\n      url.searchParams.set(\"cluster\", props.cluster);\n    }\n  }\n\n  return url.toString();\n}\n","import type { Simplify } from \"../types\";\n\nimport { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  ITransactionMessageWithFeePayerSigner,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  isTransactionSigner,\n  pipe,\n  setTransactionMessageFeePayer,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\n\nimport type { CreateTransactionInput, FullTransaction } from \"../types/transactions\";\n\n/**\n * Simple interface for creating a Solana transaction\n */\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends TransactionSigner>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, ITransactionMessageWithFeePayerSigner>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, ITransactionMessageWithFeePayer>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayerSigner, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address | TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address | TransactionSigner>({\n  version,\n  feePayer,\n  instructions,\n  latestBlockhash,\n  computeUnitLimit,\n  computeUnitPrice,\n}: CreateTransactionInput<TVersion, TFeePayer>): FullTransaction<\n  TVersion,\n  ITransactionMessageWithFeePayer | ITransactionMessageWithFeePayerSigner\n> {\n  return pipe(\n    createTransactionMessage({ version }),\n    (tx) => {\n      if (latestBlockhash) {\n        tx = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx);\n      }\n      if (typeof feePayer !== \"string\" && \"address\" in feePayer && isTransactionSigner(feePayer)) {\n        return setTransactionMessageFeePayerSigner(feePayer, tx);\n      } else return setTransactionMessageFeePayer(feePayer, tx);\n    },\n    (tx) => {\n      if (typeof computeUnitLimit !== \"undefined\") {\n        tx = appendTransactionMessageInstruction(\n          getSetComputeUnitLimitInstruction({ units: Number(computeUnitLimit) }),\n          tx,\n        );\n      }\n\n      if (typeof computeUnitPrice !== \"undefined\") {\n        tx = appendTransactionMessageInstruction(\n          getSetComputeUnitPriceInstruction({ microLamports: Number(computeUnitPrice) }),\n          tx,\n        );\n      }\n\n      return appendTransactionMessageInstructions(instructions, tx);\n    },\n  );\n}\n","import type {\n  CompilableTransactionMessage,\n  FullySignedTransaction,\n  GetEpochInfoApi,\n  GetSignatureStatusesApi,\n  Rpc,\n  RpcSubscriptions,\n  SendTransactionApi,\n  Signature,\n  SignatureNotificationsApi,\n  SlotNotificationsApi,\n  TransactionWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  Commitment,\n  getBase64EncodedWireTransaction,\n  getSignatureFromTransaction,\n  sendAndConfirmTransactionFactory,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { type waitForRecentTransactionConfirmation } from \"@solana/transaction-confirmation\";\nimport { debug } from \"./debug\";\nimport { getExplorerLink } from \"./explorer\";\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n  extends SendTransactionBaseConfig,\n    SendTransactionConfigWithoutEncoding {\n  confirmRecentTransaction: (\n    config: Omit<\n      Parameters<typeof waitForRecentTransactionConfirmation>[0],\n      \"getBlockHeightExceedencePromise\" | \"getRecentSignatureConfirmationPromise\"\n    >,\n  ) => Promise<void>;\n  transaction: FullySignedTransaction & TransactionWithBlockhashLifetime;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n  abortSignal?: AbortSignal;\n  commitment: Commitment;\n  rpc: Rpc<SendTransactionApi>;\n  transaction: FullySignedTransaction;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n  NonNullable<Parameters<SendTransactionApi[\"sendTransaction\"]>[1]>,\n  \"encoding\"\n>;\n\nexport type SendAndConfirmTransactionWithSignersFunction = (\n  transaction: (FullySignedTransaction & TransactionWithBlockhashLifetime) | CompilableTransactionMessage,\n  config?: Omit<\n    SendAndConfirmTransactionWithBlockhashLifetimeConfig,\n    \"confirmRecentTransaction\" | \"rpc\" | \"transaction\"\n  >,\n) => Promise<Signature>;\n\ntype SendAndConfirmTransactionWithSignersFactoryConfig<TCluster> = {\n  rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n  rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"devnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"testnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"mainnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"localnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | undefined = undefined,\n>({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<TCluster>): SendAndConfirmTransactionWithSignersFunction {\n  // @ts-ignore - TODO(FIXME)\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n  return async function sendAndConfirmTransactionWithSigners(transaction, config = { commitment: \"confirmed\" }) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = (await signTransactionMessageWithSigners(transaction)) as Readonly<\n        FullySignedTransaction & TransactionWithBlockhashLifetime\n      >;\n    }\n    debug(`Sending transaction: ${getExplorerLink({ transaction: getSignatureFromTransaction(transaction) })}`);\n    debug(`Transaction as base64: ${getBase64EncodedWireTransaction(transaction)}`, \"debug\");\n    await sendAndConfirmTransaction(transaction, config);\n    return getSignatureFromTransaction(transaction);\n  };\n}\n","import { COMPUTE_BUDGET_PROGRAM_ADDRESS, ComputeBudgetInstruction } from \"@solana-program/compute-budget\";\nimport type { IInstruction, IInstructionWithData, TransactionMessage } from \"@solana/kit\";\nimport { isInstructionForProgram, isInstructionWithData } from \"@solana/kit\";\n\n/**\n * Check if a given instruction is a `SetComputeUnitLimit` instruction\n */\nexport function isSetComputeLimitInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitLimit` instruction\n */\nexport function hasSetComputeLimitInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeLimitInstruction).length == 1;\n}\n\n/**\n * Check if a given instruction is a `SetComputeUnitPrice` instruction\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitPrice` instruction\n */\nexport function hasSetComputeUnitPriceInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeUnitPriceInstruction).length == 1;\n}\n","import type { Base64EncodedWireTransaction, CompilableTransactionMessage, Transaction } from \"@solana/kit\";\nimport {\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  partiallySignTransactionMessageWithSigners,\n  pipe,\n} from \"@solana/kit\";\n\n/**\n * Compile a transaction to a base64 string\n *\n * Note: This will NOT attempt to sign the transaction,\n * so it will be missing `signatures` from any of the attached Signers\n *\n * Use {@link transactionToBase64WithSignatures} sign and base64 encode\n */\nexport function transactionToBase64(tx: CompilableTransactionMessage | Transaction): Base64EncodedWireTransaction {\n  if (\"messageBytes\" in tx) return pipe(tx, getBase64EncodedWireTransaction);\n  else return pipe(tx, compileTransaction, getBase64EncodedWireTransaction);\n}\n\n/**\n * Compile a transaction to a base64 string and sign it with all attached Signers\n *\n * See also {@link partiallySignTransactionMessageWithSigners}\n */\nexport async function transactionToBase64WithSigners(\n  tx: CompilableTransactionMessage | Transaction,\n): Promise<Base64EncodedWireTransaction> {\n  if (\"messageBytes\" in tx) return transactionToBase64(tx);\n  else return transactionToBase64(await partiallySignTransactionMessageWithSigners(tx));\n}\n","import { COMPUTE_BUDGET_PROGRAM_ADDRESS, getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  CompilableTransactionMessage,\n  GetLatestBlockhashApi,\n  ITransactionMessageWithFeePayer,\n  Rpc,\n  SimulateTransactionApi,\n  TransactionMessage,\n  TransactionMessageWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  assertIsTransactionMessageWithBlockhashLifetime,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nimport { isSetComputeLimitInstruction } from \"../programs/compute-budget\";\nimport { transactionToBase64WithSigners } from \"./base64-to-transaction\";\nimport { debug, isDebugEnabled } from \"./debug\";\n\ntype PrepareCompilableTransactionMessage =\n  | CompilableTransactionMessage\n  | (ITransactionMessageWithFeePayer & TransactionMessage);\n\nexport type PrepareTransactionConfig<TMessage extends PrepareCompilableTransactionMessage> = {\n  /**\n   * Transaction to prepare for sending to the blockchain\n   */\n  transaction: TMessage;\n  /**\n   * RPC client capable of simulating transactions and getting the latest blockhash\n   **/\n  rpc: Rpc<SimulateTransactionApi & GetLatestBlockhashApi>;\n  /**\n   * Multiplier applied to the simulated compute unit value obtained from simulation\n   *\n   * Default: `1.1`\n   **/\n  computeUnitLimitMultiplier?: number;\n  /**\n   * Whether or not you wish to force reset the compute unit limit value (if one is already set)\n   * using the simulation response and `computeUnitLimitMultiplier`\n   **/\n  computeUnitLimitReset?: boolean;\n  /**\n   * Whether or not you wish to force reset the latest blockhash (if one is already set)\n   *\n   * Default: `true`\n   **/\n  blockhashReset?: boolean;\n};\n\n/**\n * Prepare a Transaction to be signed and sent to the network. Including:\n * - setting a compute unit limit (if not already set)\n * - fetching the latest blockhash (if not already set)\n * - (optional) simulating and resetting the compute unit limit\n * - (optional) resetting latest blockhash to the most recent\n */\nexport async function prepareTransaction<TMessage extends PrepareCompilableTransactionMessage>(\n  config: PrepareTransactionConfig<TMessage>,\n) {\n  // set the config defaults\n  if (!config.computeUnitLimitMultiplier) config.computeUnitLimitMultiplier = 1.1;\n  if (config.blockhashReset !== false) config.blockhashReset = true;\n\n  const computeBudgetIndex = {\n    limit: -1,\n    price: -1,\n  };\n\n  config.transaction.instructions.map((ix, index) => {\n    if (ix.programAddress != COMPUTE_BUDGET_PROGRAM_ADDRESS) return;\n\n    if (isSetComputeLimitInstruction(ix)) {\n      computeBudgetIndex.limit = index;\n    }\n    // else if (isSetComputeUnitPriceInstruction(ix)) {\n    //   computeBudgetIndex.price = index;\n    // }\n  });\n\n  // set a compute unit limit instruction\n  if (computeBudgetIndex.limit < 0 || config.computeUnitLimitReset) {\n    const units = await getComputeUnitEstimateForTransactionMessageFactory({ rpc: config.rpc })(config.transaction);\n    debug(`Obtained compute units from simulation: ${units}`, \"debug\");\n    const ix = getSetComputeUnitLimitInstruction({\n      units: units * config.computeUnitLimitMultiplier,\n    });\n\n    if (computeBudgetIndex.limit < 0) {\n      config.transaction = appendTransactionMessageInstruction(ix, config.transaction);\n    } else if (config.computeUnitLimitReset) {\n      const nextInstructions = [...config.transaction.instructions];\n      nextInstructions.splice(computeBudgetIndex.limit, 1, ix);\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        instructions: nextInstructions,\n      } as typeof config.transaction);\n    }\n  }\n\n  // update the latest blockhash\n  if (config.blockhashReset || \"lifetimeConstraint\" in config.transaction == false) {\n    const { value: latestBlockhash } = await config.rpc.getLatestBlockhash().send();\n    if (\"lifetimeConstraint\" in config.transaction == false) {\n      debug(\"Transaction missing latest blockhash, fetching one.\", \"debug\");\n      config.transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, config.transaction);\n    } else if (config.blockhashReset) {\n      debug(\"Auto resetting the latest blockhash.\", \"debug\");\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        lifetimeConstraint: latestBlockhash,\n      } as typeof config.transaction & TransactionMessageWithBlockhashLifetime);\n    }\n  }\n\n  assertIsTransactionMessageWithBlockhashLifetime(config.transaction);\n\n  // skip the async call if debugging is off\n  if (isDebugEnabled()) {\n    debug(`Transaction as base64: ${await transactionToBase64WithSigners(config.transaction)}`, \"debug\");\n  }\n\n  return config.transaction;\n}\n","import type { CompilableTransactionMessage, Rpc, SimulateTransactionApi, Transaction } from \"@solana/kit\";\nimport { getBase64EncodedWireTransaction, partiallySignTransactionMessageWithSigners } from \"@solana/kit\";\nimport type { Simplify } from \"./../types/index\";\n\nexport type SimulateTransactionFunction = (\n  transaction: Transaction | CompilableTransactionMessage,\n  config?: Simplify<Omit<Parameters<SimulateTransactionApi[\"simulateTransaction\"]>[1], \"encoding\" | \"sigVerify\">>,\n) => Promise<ReturnType<SimulateTransactionApi[\"simulateTransaction\"]>>;\n\ntype SimulateTransactionFactoryConfig<TCluster> = {\n  rpc: Rpc<SimulateTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"devnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"testnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"mainnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"localnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | void = void,\n>({ rpc }: SimulateTransactionFactoryConfig<TCluster>): SimulateTransactionFunction {\n  return async function simulateTransaction(transaction, config) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = await partiallySignTransactionMessageWithSigners(transaction);\n    }\n\n    return rpc\n      .simulateTransaction(getBase64EncodedWireTransaction(transaction), {\n        replaceRecentBlockhash: true,\n        // innerInstructions: true,\n        ...config,\n        sigVerify: false,\n        encoding: \"base64\",\n      })\n      .send();\n  };\n}\n","import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport { createSolanaRpc, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\nimport type { CreateSolanaClientArgs, LocalnetUrl, ModifiedClusterUrl, SolanaClient } from \"../types/rpc\";\nimport { getPublicSolanaRpcUrl } from \"./rpc\";\nimport { sendAndConfirmTransactionWithSignersFactory } from \"./send-and-confirm-transaction-with-signers\";\nimport { simulateTransactionFactory } from \"./simulate-transaction\";\n\n/**\n * Create a Solana `rpc` and `rpcSubscriptions` client\n */\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<MainnetUrl | \"mainnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"mainnet\";\n  },\n): SolanaClient<MainnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<DevnetUrl | \"devnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"devnet\";\n  },\n): SolanaClient<DevnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<TestnetUrl | \"testnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"testnet\";\n  },\n): SolanaClient<TestnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<LocalnetUrl | \"localnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"localnet\";\n  },\n): SolanaClient<LocalnetUrl>;\nexport function createSolanaClient<TClusterUrl extends ModifiedClusterUrl>(\n  props: CreateSolanaClientArgs<TClusterUrl>,\n): SolanaClient<TClusterUrl>;\nexport function createSolanaClient<TCluster extends ModifiedClusterUrl>({\n  urlOrMoniker,\n  rpcConfig,\n  rpcSubscriptionsConfig,\n}: CreateSolanaClientArgs<TCluster>) {\n  if (!urlOrMoniker) throw new Error(\"Cluster url or moniker is required\");\n  if (urlOrMoniker instanceof URL == false) {\n    try {\n      urlOrMoniker = new URL(urlOrMoniker.toString());\n    } catch (err) {\n      try {\n        urlOrMoniker = new URL(getPublicSolanaRpcUrl(urlOrMoniker.toString() as any));\n      } catch (err) {\n        throw new Error(\"Invalid URL or cluster moniker\");\n      }\n    }\n  }\n\n  if (!urlOrMoniker.protocol.match(/^https?/i)) {\n    throw new Error(\"Unsupported protocol. Only HTTP and HTTPS are supported\");\n  }\n\n  if (rpcConfig?.port) {\n    urlOrMoniker.port = rpcConfig.port.toString();\n  }\n\n  const rpc = createSolanaRpc<TCluster>(urlOrMoniker.toString() as TCluster, rpcConfig);\n\n  urlOrMoniker.protocol = urlOrMoniker.protocol.replace('http', 'ws');\n\n  if (rpcSubscriptionsConfig?.port) {\n    urlOrMoniker.port = rpcSubscriptionsConfig.port.toString();\n  } else if (urlOrMoniker.hostname == \"localhost\" || urlOrMoniker.hostname.startsWith(\"127\")) {\n    urlOrMoniker.port = \"8900\";\n  }\n\n  const rpcSubscriptions = createSolanaRpcSubscriptions<TCluster>(\n    urlOrMoniker.toString() as TCluster,\n    rpcSubscriptionsConfig,\n  );\n\n  return {\n    rpc,\n    rpcSubscriptions,\n    sendAndConfirmTransaction: sendAndConfirmTransactionWithSignersFactory({\n      // @ts-ignore - TODO(FIXME:nick)\n      rpc,\n      // @ts-ignore - TODO(FIXME:nick)\n      rpcSubscriptions,\n    }),\n    // @ts-ignore\n    simulateTransaction: simulateTransactionFactory({ rpc }),\n  };\n}\n","/**\n * Calculate the total rent needed for to create an account, with or without extra data stored in it\n */\nexport function getMinimumBalanceForRentExemption(space: bigint | number = 0) {\n  /**\n   * Default values for Rent calculations\n   *\n   * Values taken from: https://github.com/anza-xyz/solana-sdk/blob/c07f692e41d757057c8700211a9300cdcd6d33b1/rent/src/lib.rs#L93-L97\n   * \n   */\n  const RENT = {\n    /**\n     * Account storage overhead for calculation of base rent. (aka the number of bytes required to store an account with no data.\n     */\n    ACCOUNT_STORAGE_OVERHEAD: 128n,\n    /**\n     * Amount of time (in years) a balance must include rent for the account to\n     * be rent exempt.\n     */\n    DEFAULT_EXEMPTION_THRESHOLD: BigInt(Math.floor(2.0 * 1000)) / 1000n,\n    /**\n     * Default rental rate in lamports/byte-year. This calculation is based on:\n     * - 10^9 lamports per SOL\n     * - $1 per SOL\n     * - $0.01 per megabyte day\n     * - $3.65 per megabyte year\n     */\n    DEFAULT_LAMPORTS_PER_BYTE_YEAR: BigInt(\n      Math.floor(((1_000_000_000 / 100) * 365) / (1024 * 1024)),\n    ),\n  };\n\n  return (\n    ((RENT.ACCOUNT_STORAGE_OVERHEAD + BigInt(space)) *\n      RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR *\n      RENT.DEFAULT_EXEMPTION_THRESHOLD) /\n    1n\n  );\n}\n","import { assertKeyExporterIsAvailable, assertKeyGenerationIsAvailable } from \"@solana/assertions\";\nimport type { KeyPairSigner, createKeyPairFromBytes, createKeyPairSignerFromBytes } from \"@solana/kit\";\nimport { createSignerFromKeyPair } from \"@solana/kit\";\n\nexport function assertKeyPairIsExtractable(keyPair: CryptoKeyPair): asserts keyPair is ExtractableCryptoKeyPair {\n  assertKeyExporterIsAvailable();\n\n  if (!keyPair.privateKey) {\n    throw new Error(\"Keypair is missing private key\");\n  }\n\n  if (!keyPair.publicKey) {\n    throw new Error(\"Keypair is missing public key\");\n  }\n\n  if (!keyPair.privateKey.extractable) {\n    throw new Error(\"Private key is not extractable\");\n  }\n}\n\ntype Extractable = { \"~extractable\": true };\n\ntype ExtractableCryptoKeyPair = CryptoKeyPair & Extractable;\ntype ExtractableKeyPairSigner = KeyPairSigner & Extractable;\n\n/**\n * Generates an extractable Ed25519 `CryptoKeyPair` capable of signing messages and transactions\n * */\nexport async function generateExtractableKeyPair(): Promise<ExtractableCryptoKeyPair> {\n  await assertKeyGenerationIsAvailable();\n  return crypto.subtle.generateKey(\n    /* algorithm */ \"Ed25519\", // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */ true,\n    /* allowed uses */ [\"sign\", \"verify\"],\n  ) as Promise<ExtractableCryptoKeyPair>;\n}\n\n/**\n * Generates an extractable signer capable of signing messages and transactions using a Crypto KeyPair.\n * */\nexport async function generateExtractableKeyPairSigner(): Promise<ExtractableKeyPairSigner> {\n  return createSignerFromKeyPair(await generateExtractableKeyPair()) as Promise<ExtractableKeyPairSigner>;\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 CryptoKeyPair.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPair}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairFromBytes}.\n *\n * @param keypair An extractable Ed25519 `CryptoKeyPair`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPair(keypair: ExtractableCryptoKeyPair | CryptoKeyPair): Promise<Uint8Array> {\n  assertKeyPairIsExtractable(keypair);\n\n  const [publicKeyBytes, privateKeyJwk] = await Promise.all([\n    crypto.subtle.exportKey(\"raw\", keypair.publicKey),\n    crypto.subtle.exportKey(\"jwk\", keypair.privateKey),\n  ]);\n\n  if (!privateKeyJwk.d) throw new Error(\"Failed to get private key bytes\");\n\n  return new Uint8Array([...Buffer.from(privateKeyJwk.d, \"base64\"), ...new Uint8Array(publicKeyBytes)]);\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 KeyPairSigner.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPairSigner}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairSignerFromBytes}.\n *\n * @param keypairSigner An extractable Ed25519 `KeyPairSigner`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPairSigner(\n  keypairSigner: ExtractableKeyPairSigner | KeyPairSigner,\n): Promise<Uint8Array> {\n  return extractBytesFromKeyPair(keypairSigner.keyPair);\n}\n","import { createKeyPairFromBytes, createSignerFromKeyPair, getBase58Encoder, type KeyPairSigner } from \"@solana/kit\";\n\n/**\n * Create a `CryptoKeyPair` from as base58 encoded secret key\n */\nexport async function createKeypairFromBase58(punitiveSecretKey: string): Promise<CryptoKeyPair> {\n  return createKeyPairFromBytes(getBase58Encoder().encode(punitiveSecretKey));\n}\n\n/**\n * Create a `KeyPairSigner` from as base58 encoded secret key\n */\nexport async function createKeypairSignerFromBase58(punitiveSecretKey: string): Promise<KeyPairSigner> {\n  return createSignerFromKeyPair(await createKeypairFromBase58(punitiveSecretKey));\n}\n","import { getBase64Encoder, getTransactionDecoder, type Transaction } from \"@solana/kit\";\nimport type { transactionToBase64, transactionToBase64WithSigners } from \"./base64-to-transaction\";\n\n/**\n * Convert a base64 encoded transaction string into compiled transaction\n *\n * Use {@link transactionToBase64} or {@link transactionToBase64WithSigners} to create the base64 encoded transaction string\n */\nexport function transactionFromBase64(base64EncodedTransaction: string): Transaction {\n  return getTransactionDecoder().decode(getBase64Encoder().encode(base64EncodedTransaction));\n}\n","import type { Simplify } from \"../types/index\";\n\nimport type { Address, GetSignaturesForAddressApi, Rpc } from \"@solana/kit\";\nimport { isSolanaError, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SolanaError } from \"@solana/kit\";\n\ntype GetOldestSignatureForAddressRpc<TCluster> = Rpc<GetSignaturesForAddressApi> & {\n  \"~cluster\"?: TCluster;\n};\n\ntype GetOldestSignatureForAddressConfig = Simplify<\n  Parameters<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[1]\n> & { abortSignal?: AbortSignal };\n\n/**\n * Get the oldest signature for the provided `address`\n */\nexport async function getOldestSignatureForAddress<TCluster>(\n  rpc: GetOldestSignatureForAddressRpc<TCluster>,\n  address: Address,\n  config?: GetOldestSignatureForAddressConfig,\n): Promise<ReturnType<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[0]> {\n  const signatures = await rpc.getSignaturesForAddress(address, config).send({ abortSignal: config?.abortSignal });\n\n  if (!signatures.length) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, {\n      errorName: \"OldestSignatureNotFound\",\n    });\n  }\n\n  const oldest = signatures[signatures.length - 1];\n  if (signatures.length < (config?.limit || 1000)) return oldest;\n\n  try {\n    // if signatures are found to the limit, recurse for find the oldest\n    return await getOldestSignatureForAddress(rpc, address, { ...config, before: oldest.signature });\n  } catch (err) {\n    // if signatures found were exactly at the limit, there will be no more to find, so we return the oldest\n    if (isSolanaError(err, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN)) return oldest;\n    throw err;\n  }\n}\n","import type { Address, BaseTransactionMessage } from \"@solana/kit\";\nimport { AccountRole, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SolanaError } from \"@solana/kit\";\nimport type { getOldestSignatureForAddress } from \"./get-oldest-signature\";\n\n/**\n * Insert a single of reference key {@link Address} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeyToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  reference: Address,\n  transaction: TTransaction,\n): TTransaction {\n  return insertReferenceKeysToTransactionMessage([reference], transaction);\n}\n\n/**\n * Insert multiple reference key {@link Address | Addresses} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeysToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  references: Address[],\n  transaction: TTransaction,\n): TTransaction {\n  const nonMemoIndex = transaction.instructions.findIndex(\n    (ix) => ix.programAddress !== \"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\",\n  );\n\n  if (transaction.instructions.length == 0 || nonMemoIndex == -1) {\n    throw new SolanaError(SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, {\n      index: transaction.instructions.length || nonMemoIndex,\n      cause: \"At least one non-memo instruction is required\",\n    });\n  }\n\n  const modifiedIx = {\n    ...transaction.instructions[nonMemoIndex],\n    accounts: [\n      ...(transaction.instructions[nonMemoIndex].accounts || []),\n      // actually insert the reference keys\n      ...references.map((ref) => ({\n        address: ref,\n        role: AccountRole.READONLY,\n      })),\n    ],\n  };\n\n  const instructions = [...transaction.instructions];\n  instructions.splice(nonMemoIndex, 1, modifiedIx);\n\n  return Object.freeze({\n    ...transaction,\n    instructions: Object.freeze(instructions),\n  });\n}\n","export const GILL_EXTERNAL_MODULE_MAP: Record<string, string> = {\n  solanaAccounts: \"gill\",\n  solanaAddresses: \"gill\",\n  solanaCodecsCore: \"gill\",\n  solanaCodecsDataStructures: \"gill\",\n  solanaCodecsNumbers: \"gill\",\n  solanaCodecsStrings: \"gill\",\n  solanaErrors: \"gill\",\n  solanaInstructions: \"gill\",\n  solanaOptions: \"gill\",\n  solanaPrograms: \"gill\",\n  solanaRpcTypes: \"gill\",\n  solanaSigners: \"gill\",\n};\n\nexport function createCodamaConfig({\n  clientJs,\n  dependencyMap = GILL_EXTERNAL_MODULE_MAP,\n  idl,\n}: {\n  clientJs: string;\n  dependencyMap?: Record<string, string>;\n  idl: string;\n}) {\n  return {\n    idl,\n    scripts: {\n      js: {\n        args: [clientJs, { dependencyMap }],\n        from: \"@codama/renderers-js\",\n      },\n    },\n  };\n}\n"],"names":["isTransactionSigner","pipe","getBase64EncodedWireTransaction","COMPUTE_BUDGET_PROGRAM_ADDRESS","getSetComputeUnitLimitInstruction","appendTransactionMessageInstruction","setTransactionMessageLifetimeUsingBlockhash","partiallySignTransactionMessageWithSigners","err","createSignerFromKeyPair","SolanaError"],"mappings":"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","debugId":null}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/gill/dist/chunk-XJTBIVSK.node.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/debug.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/const.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/utils.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/rpc.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/explorer.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/create-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/send-and-confirm-transaction-with-signers.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/compute-budget/utils.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/base64-to-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/prepare-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/simulate-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/create-solana-client.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/keypairs-extractable.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/keypairs-base58.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/base64-from-transaction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/get-oldest-signature.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/insert-reference-key.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/core/create-codama-config.ts"],"sourcesContent":["/**\n *\n */\n\ntype LogLevel = \"debug\" | \"info\" | \"warn\" | \"error\";\n\nconst GILL_LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n};\n\ndeclare global {\n  /**\n   * Whether or not to enable debug mode. When enabled, default log level of `info`\n   */\n  var __GILL_DEBUG__: boolean | undefined;\n  /**\n   * Set the a desired level of logs to be output in the application\n   *\n   * - Default: `info`\n   * - Options: `debug` | `info` | `warn` | `error`\n   */\n  var __GILL_DEBUG_LEVEL__: LogLevel | undefined;\n}\n\nconst getMinLogLevel = (): LogLevel =>\n  (process.env.GILL_DEBUG_LEVEL as LogLevel) ||\n  global.__GILL_DEBUG_LEVEL__ ||\n  (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG_LEVEL__) ||\n  \"info\";\n\n/**\n * Check if the `gill` debug logger is enabled or not\n */\nexport const isDebugEnabled = (): boolean =>\n  Boolean(\n    process.env.GILL_DEBUG_LEVEL ||\n      global.__GILL_DEBUG_LEVEL__ ||\n      process.env.GILL_DEBUG === \"true\" ||\n      process.env.GILL_DEBUG === \"1\" ||\n      global.__GILL_DEBUG__ === true ||\n      (typeof window !== \"undefined\" && (window as any).__GILL_DEBUG__ === true),\n  );\n\n/**\n * Log debug messages based on the desired application's logging level.\n *\n * @param message - the message contents to be logged\n * @param level - default: `info` (see: {@link GILL_LOG_LEVELS})\n * @param prefix - default: `[GILL]`\n *\n * To enable gill's debug logger, set any of the following to `true`:\n * - `process.env.GILL_DEBUG`\n * - `global.__GILL_DEBUG__`\n * - `window.__GILL_DEBUG__`\n *\n * To set a desired level of logs to be output in the application, set the value of one of the following:\n * - `process.env.GILL_DEBUG_LEVEL`\n * - `global.__GILL_DEBUG_LEVEL__`\n * - `window.__GILL_DEBUG_LEVEL__`\n */\nexport function debug(message: unknown, level: LogLevel = \"info\", prefix: string = \"[GILL]\") {\n  if (!isDebugEnabled()) return;\n\n  if (GILL_LOG_LEVELS[level] < GILL_LOG_LEVELS[getMinLogLevel()]) return;\n\n  const formattedMessage = typeof message === \"string\" ? message : JSON.stringify(message, null, 2);\n\n  switch (level) {\n    case \"debug\":\n      console.log(prefix, formattedMessage);\n      break;\n    case \"info\":\n      console.info(prefix, formattedMessage);\n      break;\n    case \"warn\":\n      console.warn(prefix, formattedMessage);\n      break;\n    case \"error\":\n      console.error(prefix, formattedMessage);\n      break;\n  }\n}\n","/** 1 billion lamports per SOL */\nexport const LAMPORTS_PER_SOL = 1_000_000_000;\n\n/**\n * Genesis hash for Solana network clusters\n */\nexport const GENESIS_HASH = {\n  mainnet: \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\",\n  devnet: \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\",\n  testnet: \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\",\n};\n","import {\n  assertIsTransactionSigner,\n  createNoopSigner,\n  isTransactionSigner,\n  type Address,\n  type TransactionSigner,\n} from \"@solana/kit\";\nimport type { SolanaClusterMoniker } from \"../types\";\nimport { GENESIS_HASH } from \"./const\";\n\n/**\n * Determine the Solana moniker from its genesis hash\n *\n * If the hash is NOT known, returns `unknown`\n */\nexport function getMonikerFromGenesisHash(hash: string): SolanaClusterMoniker | \"unknown\" {\n  switch (hash) {\n    case GENESIS_HASH.mainnet:\n      return \"mainnet\";\n    case GENESIS_HASH.devnet:\n      return \"devnet\";\n    case GENESIS_HASH.testnet:\n      return \"testnet\";\n    default:\n      return \"unknown\";\n  }\n}\n\nexport function checkedAddress<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): Address<TAddress> {\n  return typeof input == \"string\" ? input : input.address;\n}\n\nexport function checkedTransactionSigner<TAddress extends string = string>(\n  input: Address<TAddress> | TransactionSigner<TAddress>,\n): TransactionSigner<TAddress> {\n  if (typeof input === \"string\" || \"address\" in input == false) input = createNoopSigner(input);\n  if (!isTransactionSigner(input)) throw new Error(\"A signer or address is required\");\n  assertIsTransactionSigner(input);\n  return input;\n}\n\n/**\n * Convert a lamport number to the human readable string of a SOL value\n */\nexport function lamportsToSol(lamports: bigint | number): string {\n  // @ts-expect-error This format is valid\n  return new Intl.NumberFormat(\"en-US\", { maximumFractionDigits: 9 }).format(`${lamports}E-9`);\n}\n","import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport type { LocalnetUrl, ModifiedClusterUrl, SolanaClusterMoniker } from \"../types/rpc\";\n\nexport function localnet(putativeString: string): LocalnetUrl {\n  return putativeString as LocalnetUrl;\n}\n\n/**\n * Get a public Solana RPC endpoint for a cluster based on its moniker\n *\n * Note: These RPC URLs are rate limited and not suitable for production applications.\n */\nexport function getPublicSolanaRpcUrl(\n  cluster: SolanaClusterMoniker | \"mainnet-beta\" | \"localhost\",\n): ModifiedClusterUrl {\n  switch (cluster) {\n    case \"devnet\":\n      return \"https://api.devnet.solana.com\" as DevnetUrl;\n    case \"testnet\":\n      return \"https://api.testnet.solana.com\" as TestnetUrl;\n    case \"mainnet-beta\":\n    case \"mainnet\":\n      return \"https://api.mainnet-beta.solana.com\" as MainnetUrl;\n    case \"localnet\":\n    case \"localhost\":\n      return \"http://127.0.0.1:8899\" as LocalnetUrl;\n    default:\n      throw new Error(\"Invalid cluster moniker\");\n  }\n}\n","import type { GetExplorerLinkArgs } from \"../types\";\n\n/**\n * Craft a Solana Explorer link on any cluster\n */\nexport function getExplorerLink(props: GetExplorerLinkArgs = {}): string {\n  let url = new URL(\"https://explorer.solana.com\");\n\n  // default to mainnet / mainnet-beta\n  if (!props.cluster || props.cluster == \"mainnet\") props.cluster = \"mainnet-beta\";\n\n  if (\"address\" in props) {\n    url.pathname = `/address/${props.address}`;\n  } else if (\"transaction\" in props) {\n    url.pathname = `/tx/${props.transaction}`;\n  } else if (\"block\" in props) {\n    url.pathname = `/block/${props.block}`;\n  }\n\n  if (props.cluster !== \"mainnet-beta\") {\n    if (props.cluster === \"localnet\" || props.cluster === \"localhost\") {\n      // localnet technically isn't a cluster, so requires special handling\n      url.searchParams.set(\"cluster\", \"custom\");\n      url.searchParams.set(\"customUrl\", \"http://localhost:8899\");\n    } else {\n      url.searchParams.set(\"cluster\", props.cluster);\n    }\n  }\n\n  return url.toString();\n}\n","import type { Simplify } from \"../types\";\n\nimport { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  ITransactionMessageWithFeePayerSigner,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  isTransactionSigner,\n  pipe,\n  setTransactionMessageFeePayer,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\n\nimport type { CreateTransactionInput, FullTransaction } from \"../types/transactions\";\n\n/**\n * Simple interface for creating a Solana transaction\n */\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends TransactionSigner>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, ITransactionMessageWithFeePayerSigner>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address>(\n  props: CreateTransactionInput<TVersion, TFeePayer>,\n): FullTransaction<TVersion, ITransactionMessageWithFeePayer>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayerSigner, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address | TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  props: CreateTransactionInput<TVersion, TFeePayer, TLifetimeConstraint>,\n): Simplify<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport function createTransaction<TVersion extends TransactionVersion, TFeePayer extends Address | TransactionSigner>({\n  version,\n  feePayer,\n  instructions,\n  latestBlockhash,\n  computeUnitLimit,\n  computeUnitPrice,\n}: CreateTransactionInput<TVersion, TFeePayer>): FullTransaction<\n  TVersion,\n  ITransactionMessageWithFeePayer | ITransactionMessageWithFeePayerSigner\n> {\n  return pipe(\n    createTransactionMessage({ version }),\n    (tx) => {\n      if (latestBlockhash) {\n        tx = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx);\n      }\n      if (typeof feePayer !== \"string\" && \"address\" in feePayer && isTransactionSigner(feePayer)) {\n        return setTransactionMessageFeePayerSigner(feePayer, tx);\n      } else return setTransactionMessageFeePayer(feePayer, tx);\n    },\n    (tx) => {\n      if (typeof computeUnitLimit !== \"undefined\") {\n        tx = appendTransactionMessageInstruction(\n          getSetComputeUnitLimitInstruction({ units: Number(computeUnitLimit) }),\n          tx,\n        );\n      }\n\n      if (typeof computeUnitPrice !== \"undefined\") {\n        tx = appendTransactionMessageInstruction(\n          getSetComputeUnitPriceInstruction({ microLamports: Number(computeUnitPrice) }),\n          tx,\n        );\n      }\n\n      return appendTransactionMessageInstructions(instructions, tx);\n    },\n  );\n}\n","import type {\n  CompilableTransactionMessage,\n  FullySignedTransaction,\n  GetEpochInfoApi,\n  GetSignatureStatusesApi,\n  Rpc,\n  RpcSubscriptions,\n  SendTransactionApi,\n  Signature,\n  SignatureNotificationsApi,\n  SlotNotificationsApi,\n  TransactionWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  Commitment,\n  getBase64EncodedWireTransaction,\n  getSignatureFromTransaction,\n  sendAndConfirmTransactionFactory,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { type waitForRecentTransactionConfirmation } from \"@solana/transaction-confirmation\";\nimport { debug } from \"./debug\";\nimport { getExplorerLink } from \"./explorer\";\n\ninterface SendAndConfirmTransactionWithBlockhashLifetimeConfig\n  extends SendTransactionBaseConfig,\n    SendTransactionConfigWithoutEncoding {\n  confirmRecentTransaction: (\n    config: Omit<\n      Parameters<typeof waitForRecentTransactionConfirmation>[0],\n      \"getBlockHeightExceedencePromise\" | \"getRecentSignatureConfirmationPromise\"\n    >,\n  ) => Promise<void>;\n  transaction: FullySignedTransaction & TransactionWithBlockhashLifetime;\n}\n\ninterface SendTransactionBaseConfig extends SendTransactionConfigWithoutEncoding {\n  abortSignal?: AbortSignal;\n  commitment: Commitment;\n  rpc: Rpc<SendTransactionApi>;\n  transaction: FullySignedTransaction;\n}\n\ntype SendTransactionConfigWithoutEncoding = Omit<\n  NonNullable<Parameters<SendTransactionApi[\"sendTransaction\"]>[1]>,\n  \"encoding\"\n>;\n\nexport type SendAndConfirmTransactionWithSignersFunction = (\n  transaction: (FullySignedTransaction & TransactionWithBlockhashLifetime) | CompilableTransactionMessage,\n  config?: Omit<\n    SendAndConfirmTransactionWithBlockhashLifetimeConfig,\n    \"confirmRecentTransaction\" | \"rpc\" | \"transaction\"\n  >,\n) => Promise<Signature>;\n\ntype SendAndConfirmTransactionWithSignersFactoryConfig<TCluster> = {\n  rpc: Rpc<GetEpochInfoApi & GetSignatureStatusesApi & SendTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n  rpcSubscriptions: RpcSubscriptions<SignatureNotificationsApi & SlotNotificationsApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"devnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"testnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"mainnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<\"localnet\">): SendAndConfirmTransactionWithSignersFunction;\nexport function sendAndConfirmTransactionWithSignersFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | undefined = undefined,\n>({\n  rpc,\n  rpcSubscriptions,\n}: SendAndConfirmTransactionWithSignersFactoryConfig<TCluster>): SendAndConfirmTransactionWithSignersFunction {\n  // @ts-ignore - TODO(FIXME)\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n  return async function sendAndConfirmTransactionWithSigners(transaction, config = { commitment: \"confirmed\" }) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = (await signTransactionMessageWithSigners(transaction)) as Readonly<\n        FullySignedTransaction & TransactionWithBlockhashLifetime\n      >;\n    }\n    debug(`Sending transaction: ${getExplorerLink({ transaction: getSignatureFromTransaction(transaction) })}`);\n    debug(`Transaction as base64: ${getBase64EncodedWireTransaction(transaction)}`, \"debug\");\n    await sendAndConfirmTransaction(transaction, config);\n    return getSignatureFromTransaction(transaction);\n  };\n}\n","import { COMPUTE_BUDGET_PROGRAM_ADDRESS, ComputeBudgetInstruction } from \"@solana-program/compute-budget\";\nimport type { IInstruction, IInstructionWithData, TransactionMessage } from \"@solana/kit\";\nimport { isInstructionForProgram, isInstructionWithData } from \"@solana/kit\";\n\n/**\n * Check if a given instruction is a `SetComputeUnitLimit` instruction\n */\nexport function isSetComputeLimitInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitLimit` instruction\n */\nexport function hasSetComputeLimitInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeLimitInstruction).length == 1;\n}\n\n/**\n * Check if a given instruction is a `SetComputeUnitPrice` instruction\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction,\n): instruction is IInstruction<typeof COMPUTE_BUDGET_PROGRAM_ADDRESS> & IInstructionWithData<Uint8Array> {\n  return (\n    isInstructionForProgram(instruction, COMPUTE_BUDGET_PROGRAM_ADDRESS) &&\n    isInstructionWithData(instruction) &&\n    instruction.data[0] === ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n\n/**\n * Check if a given transaction contains a `SetComputeUnitPrice` instruction\n */\nexport function hasSetComputeUnitPriceInstruction(tx: TransactionMessage): boolean {\n  return tx.instructions.filter(isSetComputeUnitPriceInstruction).length == 1;\n}\n","import type { Base64EncodedWireTransaction, CompilableTransactionMessage, Transaction } from \"@solana/kit\";\nimport {\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  partiallySignTransactionMessageWithSigners,\n  pipe,\n} from \"@solana/kit\";\n\n/**\n * Compile a transaction to a base64 string\n *\n * Note: This will NOT attempt to sign the transaction,\n * so it will be missing `signatures` from any of the attached Signers\n *\n * Use {@link transactionToBase64WithSignatures} sign and base64 encode\n */\nexport function transactionToBase64(tx: CompilableTransactionMessage | Transaction): Base64EncodedWireTransaction {\n  if (\"messageBytes\" in tx) return pipe(tx, getBase64EncodedWireTransaction);\n  else return pipe(tx, compileTransaction, getBase64EncodedWireTransaction);\n}\n\n/**\n * Compile a transaction to a base64 string and sign it with all attached Signers\n *\n * See also {@link partiallySignTransactionMessageWithSigners}\n */\nexport async function transactionToBase64WithSigners(\n  tx: CompilableTransactionMessage | Transaction,\n): Promise<Base64EncodedWireTransaction> {\n  if (\"messageBytes\" in tx) return transactionToBase64(tx);\n  else return transactionToBase64(await partiallySignTransactionMessageWithSigners(tx));\n}\n","import { COMPUTE_BUDGET_PROGRAM_ADDRESS, getSetComputeUnitLimitInstruction } from \"@solana-program/compute-budget\";\nimport type {\n  CompilableTransactionMessage,\n  GetLatestBlockhashApi,\n  ITransactionMessageWithFeePayer,\n  Rpc,\n  SimulateTransactionApi,\n  TransactionMessage,\n  TransactionMessageWithBlockhashLifetime,\n} from \"@solana/kit\";\nimport {\n  appendTransactionMessageInstruction,\n  assertIsTransactionMessageWithBlockhashLifetime,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  setTransactionMessageLifetimeUsingBlockhash,\n} from \"@solana/kit\";\nimport { isSetComputeLimitInstruction } from \"../programs/compute-budget\";\nimport { transactionToBase64WithSigners } from \"./base64-to-transaction\";\nimport { debug, isDebugEnabled } from \"./debug\";\n\ntype PrepareCompilableTransactionMessage =\n  | CompilableTransactionMessage\n  | (ITransactionMessageWithFeePayer & TransactionMessage);\n\nexport type PrepareTransactionConfig<TMessage extends PrepareCompilableTransactionMessage> = {\n  /**\n   * Transaction to prepare for sending to the blockchain\n   */\n  transaction: TMessage;\n  /**\n   * RPC client capable of simulating transactions and getting the latest blockhash\n   **/\n  rpc: Rpc<SimulateTransactionApi & GetLatestBlockhashApi>;\n  /**\n   * Multiplier applied to the simulated compute unit value obtained from simulation\n   *\n   * Default: `1.1`\n   **/\n  computeUnitLimitMultiplier?: number;\n  /**\n   * Whether or not you wish to force reset the compute unit limit value (if one is already set)\n   * using the simulation response and `computeUnitLimitMultiplier`\n   **/\n  computeUnitLimitReset?: boolean;\n  /**\n   * Whether or not you wish to force reset the latest blockhash (if one is already set)\n   *\n   * Default: `true`\n   **/\n  blockhashReset?: boolean;\n};\n\n/**\n * Prepare a Transaction to be signed and sent to the network. Including:\n * - setting a compute unit limit (if not already set)\n * - fetching the latest blockhash (if not already set)\n * - (optional) simulating and resetting the compute unit limit\n * - (optional) resetting latest blockhash to the most recent\n */\nexport async function prepareTransaction<TMessage extends PrepareCompilableTransactionMessage>(\n  config: PrepareTransactionConfig<TMessage>,\n) {\n  // set the config defaults\n  if (!config.computeUnitLimitMultiplier) config.computeUnitLimitMultiplier = 1.1;\n  if (config.blockhashReset !== false) config.blockhashReset = true;\n\n  const computeBudgetIndex = {\n    limit: -1,\n    price: -1,\n  };\n\n  config.transaction.instructions.map((ix, index) => {\n    if (ix.programAddress != COMPUTE_BUDGET_PROGRAM_ADDRESS) return;\n\n    if (isSetComputeLimitInstruction(ix)) {\n      computeBudgetIndex.limit = index;\n    }\n    // else if (isSetComputeUnitPriceInstruction(ix)) {\n    //   computeBudgetIndex.price = index;\n    // }\n  });\n\n  // set a compute unit limit instruction\n  if (computeBudgetIndex.limit < 0 || config.computeUnitLimitReset) {\n    const units = await getComputeUnitEstimateForTransactionMessageFactory({ rpc: config.rpc })(config.transaction);\n    debug(`Obtained compute units from simulation: ${units}`, \"debug\");\n    const ix = getSetComputeUnitLimitInstruction({\n      units: units * config.computeUnitLimitMultiplier,\n    });\n\n    if (computeBudgetIndex.limit < 0) {\n      config.transaction = appendTransactionMessageInstruction(ix, config.transaction);\n    } else if (config.computeUnitLimitReset) {\n      const nextInstructions = [...config.transaction.instructions];\n      nextInstructions.splice(computeBudgetIndex.limit, 1, ix);\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        instructions: nextInstructions,\n      } as typeof config.transaction);\n    }\n  }\n\n  // update the latest blockhash\n  if (config.blockhashReset || \"lifetimeConstraint\" in config.transaction == false) {\n    const { value: latestBlockhash } = await config.rpc.getLatestBlockhash().send();\n    if (\"lifetimeConstraint\" in config.transaction == false) {\n      debug(\"Transaction missing latest blockhash, fetching one.\", \"debug\");\n      config.transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, config.transaction);\n    } else if (config.blockhashReset) {\n      debug(\"Auto resetting the latest blockhash.\", \"debug\");\n      config.transaction = Object.freeze({\n        ...config.transaction,\n        lifetimeConstraint: latestBlockhash,\n      } as typeof config.transaction & TransactionMessageWithBlockhashLifetime);\n    }\n  }\n\n  assertIsTransactionMessageWithBlockhashLifetime(config.transaction);\n\n  // skip the async call if debugging is off\n  if (isDebugEnabled()) {\n    debug(`Transaction as base64: ${await transactionToBase64WithSigners(config.transaction)}`, \"debug\");\n  }\n\n  return config.transaction;\n}\n","import type { CompilableTransactionMessage, Rpc, SimulateTransactionApi, Transaction } from \"@solana/kit\";\nimport { getBase64EncodedWireTransaction, partiallySignTransactionMessageWithSigners } from \"@solana/kit\";\nimport type { Simplify } from \"./../types/index\";\n\nexport type SimulateTransactionFunction = (\n  transaction: Transaction | CompilableTransactionMessage,\n  config?: Simplify<Omit<Parameters<SimulateTransactionApi[\"simulateTransaction\"]>[1], \"encoding\" | \"sigVerify\">>,\n) => Promise<ReturnType<SimulateTransactionApi[\"simulateTransaction\"]>>;\n\ntype SimulateTransactionFactoryConfig<TCluster> = {\n  rpc: Rpc<SimulateTransactionApi> & {\n    \"~cluster\"?: TCluster;\n  };\n};\n\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"devnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"testnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"mainnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory({\n  rpc,\n}: SimulateTransactionFactoryConfig<\"localnet\">): SimulateTransactionFunction;\nexport function simulateTransactionFactory<\n  TCluster extends \"devnet\" | \"mainnet\" | \"testnet\" | \"localnet\" | void = void,\n>({ rpc }: SimulateTransactionFactoryConfig<TCluster>): SimulateTransactionFunction {\n  return async function simulateTransaction(transaction, config) {\n    if (\"messageBytes\" in transaction == false) {\n      transaction = await partiallySignTransactionMessageWithSigners(transaction);\n    }\n\n    return rpc\n      .simulateTransaction(getBase64EncodedWireTransaction(transaction), {\n        replaceRecentBlockhash: true,\n        // innerInstructions: true,\n        ...config,\n        sigVerify: false,\n        encoding: \"base64\",\n      })\n      .send();\n  };\n}\n","import type { DevnetUrl, MainnetUrl, TestnetUrl } from \"@solana/kit\";\nimport { createSolanaRpc, createSolanaRpcSubscriptions } from \"@solana/kit\";\n\nimport type { CreateSolanaClientArgs, LocalnetUrl, ModifiedClusterUrl, SolanaClient } from \"../types/rpc\";\nimport { getPublicSolanaRpcUrl } from \"./rpc\";\nimport { sendAndConfirmTransactionWithSignersFactory } from \"./send-and-confirm-transaction-with-signers\";\nimport { simulateTransactionFactory } from \"./simulate-transaction\";\n\n/**\n * Create a Solana `rpc` and `rpcSubscriptions` client\n */\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<MainnetUrl | \"mainnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"mainnet\";\n  },\n): SolanaClient<MainnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<DevnetUrl | \"devnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"devnet\";\n  },\n): SolanaClient<DevnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<TestnetUrl | \"testnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"testnet\";\n  },\n): SolanaClient<TestnetUrl>;\nexport function createSolanaClient(\n  props: Omit<CreateSolanaClientArgs<LocalnetUrl | \"localnet\">, \"urlOrMoniker\"> & {\n    urlOrMoniker: \"localnet\";\n  },\n): SolanaClient<LocalnetUrl>;\nexport function createSolanaClient<TClusterUrl extends ModifiedClusterUrl>(\n  props: CreateSolanaClientArgs<TClusterUrl>,\n): SolanaClient<TClusterUrl>;\nexport function createSolanaClient<TCluster extends ModifiedClusterUrl>({\n  urlOrMoniker,\n  rpcConfig,\n  rpcSubscriptionsConfig,\n}: CreateSolanaClientArgs<TCluster>) {\n  if (!urlOrMoniker) throw new Error(\"Cluster url or moniker is required\");\n  if (urlOrMoniker instanceof URL == false) {\n    try {\n      urlOrMoniker = new URL(urlOrMoniker.toString());\n    } catch (err) {\n      try {\n        urlOrMoniker = new URL(getPublicSolanaRpcUrl(urlOrMoniker.toString() as any));\n      } catch (err) {\n        throw new Error(\"Invalid URL or cluster moniker\");\n      }\n    }\n  }\n\n  if (!urlOrMoniker.protocol.match(/^https?/i)) {\n    throw new Error(\"Unsupported protocol. Only HTTP and HTTPS are supported\");\n  }\n\n  if (rpcConfig?.port) {\n    urlOrMoniker.port = rpcConfig.port.toString();\n  }\n\n  const rpc = createSolanaRpc<TCluster>(urlOrMoniker.toString() as TCluster, rpcConfig);\n\n  urlOrMoniker.protocol = urlOrMoniker.protocol.replace('http', 'ws');\n\n  if (rpcSubscriptionsConfig?.port) {\n    urlOrMoniker.port = rpcSubscriptionsConfig.port.toString();\n  } else if (urlOrMoniker.hostname == \"localhost\" || urlOrMoniker.hostname.startsWith(\"127\")) {\n    urlOrMoniker.port = \"8900\";\n  }\n\n  const rpcSubscriptions = createSolanaRpcSubscriptions<TCluster>(\n    urlOrMoniker.toString() as TCluster,\n    rpcSubscriptionsConfig,\n  );\n\n  return {\n    rpc,\n    rpcSubscriptions,\n    sendAndConfirmTransaction: sendAndConfirmTransactionWithSignersFactory({\n      // @ts-ignore - TODO(FIXME:nick)\n      rpc,\n      // @ts-ignore - TODO(FIXME:nick)\n      rpcSubscriptions,\n    }),\n    // @ts-ignore\n    simulateTransaction: simulateTransactionFactory({ rpc }),\n  };\n}\n","/**\n * Calculate the total rent needed for to create an account, with or without extra data stored in it\n */\nexport function getMinimumBalanceForRentExemption(space: bigint | number = 0) {\n  /**\n   * Default values for Rent calculations\n   *\n   * Values taken from: https://github.com/anza-xyz/solana-sdk/blob/c07f692e41d757057c8700211a9300cdcd6d33b1/rent/src/lib.rs#L93-L97\n   * \n   */\n  const RENT = {\n    /**\n     * Account storage overhead for calculation of base rent. (aka the number of bytes required to store an account with no data.\n     */\n    ACCOUNT_STORAGE_OVERHEAD: 128n,\n    /**\n     * Amount of time (in years) a balance must include rent for the account to\n     * be rent exempt.\n     */\n    DEFAULT_EXEMPTION_THRESHOLD: BigInt(Math.floor(2.0 * 1000)) / 1000n,\n    /**\n     * Default rental rate in lamports/byte-year. This calculation is based on:\n     * - 10^9 lamports per SOL\n     * - $1 per SOL\n     * - $0.01 per megabyte day\n     * - $3.65 per megabyte year\n     */\n    DEFAULT_LAMPORTS_PER_BYTE_YEAR: BigInt(\n      Math.floor(((1_000_000_000 / 100) * 365) / (1024 * 1024)),\n    ),\n  };\n\n  return (\n    ((RENT.ACCOUNT_STORAGE_OVERHEAD + BigInt(space)) *\n      RENT.DEFAULT_LAMPORTS_PER_BYTE_YEAR *\n      RENT.DEFAULT_EXEMPTION_THRESHOLD) /\n    1n\n  );\n}\n","import { assertKeyExporterIsAvailable, assertKeyGenerationIsAvailable } from \"@solana/assertions\";\nimport type { KeyPairSigner, createKeyPairFromBytes, createKeyPairSignerFromBytes } from \"@solana/kit\";\nimport { createSignerFromKeyPair } from \"@solana/kit\";\n\nexport function assertKeyPairIsExtractable(keyPair: CryptoKeyPair): asserts keyPair is ExtractableCryptoKeyPair {\n  assertKeyExporterIsAvailable();\n\n  if (!keyPair.privateKey) {\n    throw new Error(\"Keypair is missing private key\");\n  }\n\n  if (!keyPair.publicKey) {\n    throw new Error(\"Keypair is missing public key\");\n  }\n\n  if (!keyPair.privateKey.extractable) {\n    throw new Error(\"Private key is not extractable\");\n  }\n}\n\ntype Extractable = { \"~extractable\": true };\n\ntype ExtractableCryptoKeyPair = CryptoKeyPair & Extractable;\ntype ExtractableKeyPairSigner = KeyPairSigner & Extractable;\n\n/**\n * Generates an extractable Ed25519 `CryptoKeyPair` capable of signing messages and transactions\n * */\nexport async function generateExtractableKeyPair(): Promise<ExtractableCryptoKeyPair> {\n  await assertKeyGenerationIsAvailable();\n  return crypto.subtle.generateKey(\n    /* algorithm */ \"Ed25519\", // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */ true,\n    /* allowed uses */ [\"sign\", \"verify\"],\n  ) as Promise<ExtractableCryptoKeyPair>;\n}\n\n/**\n * Generates an extractable signer capable of signing messages and transactions using a Crypto KeyPair.\n * */\nexport async function generateExtractableKeyPairSigner(): Promise<ExtractableKeyPairSigner> {\n  return createSignerFromKeyPair(await generateExtractableKeyPair()) as Promise<ExtractableKeyPairSigner>;\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 CryptoKeyPair.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPair}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairFromBytes}.\n *\n * @param keypair An extractable Ed25519 `CryptoKeyPair`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPair(keypair: ExtractableCryptoKeyPair | CryptoKeyPair): Promise<Uint8Array> {\n  assertKeyPairIsExtractable(keypair);\n\n  const [publicKeyBytes, privateKeyJwk] = await Promise.all([\n    crypto.subtle.exportKey(\"raw\", keypair.publicKey),\n    crypto.subtle.exportKey(\"jwk\", keypair.privateKey),\n  ]);\n\n  if (!privateKeyJwk.d) throw new Error(\"Failed to get private key bytes\");\n\n  return new Uint8Array([...Buffer.from(privateKeyJwk.d, \"base64\"), ...new Uint8Array(publicKeyBytes)]);\n}\n\n/**\n * Extracts the raw key material from an extractable Ed25519 KeyPairSigner.\n *\n * @remarks\n * - Requires a keypair generated with extractable=true. See {@link generateExtractableKeyPairSigner}.\n * - The extracted bytes can be used to reconstruct the `CryptoKeyPair` with {@link createKeyPairSignerFromBytes}.\n *\n * @param keypairSigner An extractable Ed25519 `KeyPairSigner`\n * @returns Raw key bytes as `Uint8Array`\n */\nexport async function extractBytesFromKeyPairSigner(\n  keypairSigner: ExtractableKeyPairSigner | KeyPairSigner,\n): Promise<Uint8Array> {\n  return extractBytesFromKeyPair(keypairSigner.keyPair);\n}\n","import { createKeyPairFromBytes, createSignerFromKeyPair, getBase58Encoder, type KeyPairSigner } from \"@solana/kit\";\n\n/**\n * Create a `CryptoKeyPair` from as base58 encoded secret key\n */\nexport async function createKeypairFromBase58(punitiveSecretKey: string): Promise<CryptoKeyPair> {\n  return createKeyPairFromBytes(getBase58Encoder().encode(punitiveSecretKey));\n}\n\n/**\n * Create a `KeyPairSigner` from as base58 encoded secret key\n */\nexport async function createKeypairSignerFromBase58(punitiveSecretKey: string): Promise<KeyPairSigner> {\n  return createSignerFromKeyPair(await createKeypairFromBase58(punitiveSecretKey));\n}\n","import { getBase64Encoder, getTransactionDecoder, type Transaction } from \"@solana/kit\";\nimport type { transactionToBase64, transactionToBase64WithSigners } from \"./base64-to-transaction\";\n\n/**\n * Convert a base64 encoded transaction string into compiled transaction\n *\n * Use {@link transactionToBase64} or {@link transactionToBase64WithSigners} to create the base64 encoded transaction string\n */\nexport function transactionFromBase64(base64EncodedTransaction: string): Transaction {\n  return getTransactionDecoder().decode(getBase64Encoder().encode(base64EncodedTransaction));\n}\n","import type { Simplify } from \"../types/index\";\n\nimport type { Address, GetSignaturesForAddressApi, Rpc } from \"@solana/kit\";\nimport { isSolanaError, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SolanaError } from \"@solana/kit\";\n\ntype GetOldestSignatureForAddressRpc<TCluster> = Rpc<GetSignaturesForAddressApi> & {\n  \"~cluster\"?: TCluster;\n};\n\ntype GetOldestSignatureForAddressConfig = Simplify<\n  Parameters<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[1]\n> & { abortSignal?: AbortSignal };\n\n/**\n * Get the oldest signature for the provided `address`\n */\nexport async function getOldestSignatureForAddress<TCluster>(\n  rpc: GetOldestSignatureForAddressRpc<TCluster>,\n  address: Address,\n  config?: GetOldestSignatureForAddressConfig,\n): Promise<ReturnType<GetSignaturesForAddressApi[\"getSignaturesForAddress\"]>[0]> {\n  const signatures = await rpc.getSignaturesForAddress(address, config).send({ abortSignal: config?.abortSignal });\n\n  if (!signatures.length) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, {\n      errorName: \"OldestSignatureNotFound\",\n    });\n  }\n\n  const oldest = signatures[signatures.length - 1];\n  if (signatures.length < (config?.limit || 1000)) return oldest;\n\n  try {\n    // if signatures are found to the limit, recurse for find the oldest\n    return await getOldestSignatureForAddress(rpc, address, { ...config, before: oldest.signature });\n  } catch (err) {\n    // if signatures found were exactly at the limit, there will be no more to find, so we return the oldest\n    if (isSolanaError(err, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN)) return oldest;\n    throw err;\n  }\n}\n","import type { Address, BaseTransactionMessage } from \"@solana/kit\";\nimport { AccountRole, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SolanaError } from \"@solana/kit\";\nimport type { getOldestSignatureForAddress } from \"./get-oldest-signature\";\n\n/**\n * Insert a single of reference key {@link Address} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeyToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  reference: Address,\n  transaction: TTransaction,\n): TTransaction {\n  return insertReferenceKeysToTransactionMessage([reference], transaction);\n}\n\n/**\n * Insert multiple reference key {@link Address | Addresses} into a transaction message\n *\n * Use {@link getOldestSignatureForAddress} to locate the oldest signature for a reference key's address\n *\n * Note: The `transaction` must have at least one non-memo instruction.\n */\nexport function insertReferenceKeysToTransactionMessage<TTransaction extends BaseTransactionMessage>(\n  references: Address[],\n  transaction: TTransaction,\n): TTransaction {\n  const nonMemoIndex = transaction.instructions.findIndex(\n    (ix) => ix.programAddress !== \"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\",\n  );\n\n  if (transaction.instructions.length == 0 || nonMemoIndex == -1) {\n    throw new SolanaError(SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, {\n      index: transaction.instructions.length || nonMemoIndex,\n      cause: \"At least one non-memo instruction is required\",\n    });\n  }\n\n  const modifiedIx = {\n    ...transaction.instructions[nonMemoIndex],\n    accounts: [\n      ...(transaction.instructions[nonMemoIndex].accounts || []),\n      // actually insert the reference keys\n      ...references.map((ref) => ({\n        address: ref,\n        role: AccountRole.READONLY,\n      })),\n    ],\n  };\n\n  const instructions = [...transaction.instructions];\n  instructions.splice(nonMemoIndex, 1, modifiedIx);\n\n  return Object.freeze({\n    ...transaction,\n    instructions: Object.freeze(instructions),\n  });\n}\n","export const GILL_EXTERNAL_MODULE_MAP: Record<string, string> = {\n  solanaAccounts: \"gill\",\n  solanaAddresses: \"gill\",\n  solanaCodecsCore: \"gill\",\n  solanaCodecsDataStructures: \"gill\",\n  solanaCodecsNumbers: \"gill\",\n  solanaCodecsStrings: \"gill\",\n  solanaErrors: \"gill\",\n  solanaInstructions: \"gill\",\n  solanaOptions: \"gill\",\n  solanaPrograms: \"gill\",\n  solanaRpcTypes: \"gill\",\n  solanaSigners: \"gill\",\n};\n\nexport function createCodamaConfig({\n  clientJs,\n  dependencyMap = GILL_EXTERNAL_MODULE_MAP,\n  idl,\n}: {\n  clientJs: string;\n  dependencyMap?: Record<string, string>;\n  idl: string;\n}) {\n  return {\n    idl,\n    scripts: {\n      js: {\n        args: [clientJs, { dependencyMap }],\n        from: \"@codama/renderers-js\",\n      },\n    },\n  };\n}\n"],"names":["isTransactionSigner","pipe","getBase64EncodedWireTransaction","COMPUTE_BUDGET_PROGRAM_ADDRESS","getSetComputeUnitLimitInstruction","appendTransactionMessageInstruction","setTransactionMessageLifetimeUsingBlockhash","partiallySignTransactionMessageWithSigners","err","createSignerFromKeyPair","SolanaError"],"mappings":"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","debugId":null}},
    {"offset": {"line": 992, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/gill/dist/chunk-IPZIBVL2.node.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/addresses.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/types/collection.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/types/collectionDetails.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/types/creator.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/types/dataV2.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/types/uses.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/types/useMethod.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/programs/tokenMetadata.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/shared/index.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/generated/instructions/createMetadataAccountV3.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token-metadata/addresses.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/instructions/create-token.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/instructions/mint-tokens.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/instructions/transfer-tokens.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/transactions/create-token.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/transactions/mint-tokens.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/transactions/transfer-tokens.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/voting-dapp/app/node_modules/gill/src/programs/token/ui-amount.ts"],"sourcesContent":["import { findAssociatedTokenPda, TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport { isAddress, type Address, type TransactionSigner } from \"@solana/kit\";\nimport { checkedAddress } from \"../../core/utils\";\n\nexport type LegacyTokenProgramMonikers = \"legacy\" | \"token\";\n\nexport type TokenExtensionProgramMonikers = \"token22\" | \"tokenExtension\" | \"tokenExtensions\" | \"token2022\";\n\nexport type TokenProgramMonikers = LegacyTokenProgramMonikers | TokenExtensionProgramMonikers;\n\nexport const TOKEN_PROGRAM_ADDRESS =\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\" as Address<\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\">;\n\n/**\n * Derive the associated token account (ata) address for an owner and mint/tokenProgram\n *\n * @argument `mint` - the token mint itself\n * @argument `owner` - destination wallet address to own tokens from `mint`\n * @argument `tokenProgram` - token program that the token `mint` was created with\n *\n * - (default) {@link TOKEN_PROGRAM_ADDRESS} - the original SPL Token Program\n * - {@link TOKEN_2022_PROGRAM_ADDRESS} - the SPL Token Extensions Program (aka Token22)\n */\nexport async function getAssociatedTokenAccountAddress(\n  mint: Address | TransactionSigner,\n  owner: Address | TransactionSigner,\n  tokenProgram?: Address,\n): Promise<Address> {\n  return (\n    await findAssociatedTokenPda({\n      mint: checkedAddress(mint),\n      owner: checkedAddress(owner),\n      tokenProgram: checkedTokenProgramAddress(tokenProgram),\n    })\n  )[0];\n}\n\nexport function parseTokenProgramAddressOrMoniker(tokenProgram: Address | TokenProgramMonikers): Address {\n  if (!isAddress(tokenProgram)) {\n    tokenProgram = tokenProgram.toLowerCase() as TokenProgramMonikers;\n  }\n  switch (tokenProgram) {\n    case \"legacy\":\n    case \"token\":\n    case TOKEN_PROGRAM_ADDRESS: {\n      return TOKEN_PROGRAM_ADDRESS;\n    }\n    case \"token22\":\n    case \"token2022\":\n    case \"tokenextension\":\n    case \"tokenextensions\":\n    case TOKEN_2022_PROGRAM_ADDRESS: {\n      return TOKEN_2022_PROGRAM_ADDRESS;\n    }\n    default:\n      throw Error(\"Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'\");\n  }\n}\n\nexport function assertIsSupportedTokenProgram(\n  tokenProgram: Address,\n): asserts tokenProgram is Address<typeof tokenProgram> {\n  if (tokenProgram !== TOKEN_PROGRAM_ADDRESS && tokenProgram !== TOKEN_2022_PROGRAM_ADDRESS) {\n    throw Error(\"Unsupported token program. Try 'TOKEN_PROGRAM_ADDRESS' or 'TOKEN_2022_PROGRAM_ADDRESS'\");\n  }\n}\n\n/**\n * Check the provided program is one of the supported token programs.\n * Including setting the default to {@link TOKEN_PROGRAM_ADDRESS} (the original SPL token program)\n *\n * @example\n * ```\n * args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n * ```\n */\nexport function checkedTokenProgramAddress(tokenProgram?: Address | TokenProgramMonikers): Address {\n  if (!tokenProgram) return TOKEN_PROGRAM_ADDRESS;\n  tokenProgram = parseTokenProgramAddressOrMoniker(tokenProgram);\n  assertIsSupportedTokenProgram(tokenProgram);\n  return tokenProgram;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from \"@solana/kit\";\n\nexport type Collection = { verified: boolean; key: Address };\n\nexport type CollectionArgs = Collection;\n\nexport function getCollectionEncoder(): Encoder<CollectionArgs> {\n  return getStructEncoder([\n    [\"verified\", getBooleanEncoder()],\n    [\"key\", getAddressEncoder()],\n  ]);\n}\n\nexport function getCollectionDecoder(): Decoder<Collection> {\n  return getStructDecoder([\n    [\"verified\", getBooleanDecoder()],\n    [\"key\", getAddressDecoder()],\n  ]);\n}\n\nexport function getCollectionCodec(): Codec<CollectionArgs, Collection> {\n  return combineCodec(getCollectionEncoder(), getCollectionDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport type CollectionDetails =\n  | { __kind: 'V1'; size: bigint }\n  | { __kind: 'V2'; padding: ReadonlyUint8Array };\n\nexport type CollectionDetailsArgs =\n  | { __kind: 'V1'; size: number | bigint }\n  | { __kind: 'V2'; padding: ReadonlyUint8Array };\n\nexport function getCollectionDetailsEncoder(): Encoder<CollectionDetailsArgs> {\n  return getDiscriminatedUnionEncoder([\n    ['V1', getStructEncoder([['size', getU64Encoder()]])],\n    [\n      'V2',\n      getStructEncoder([['padding', fixEncoderSize(getBytesEncoder(), 8)]]),\n    ],\n  ]);\n}\n\nexport function getCollectionDetailsDecoder(): Decoder<CollectionDetails> {\n  return getDiscriminatedUnionDecoder([\n    ['V1', getStructDecoder([['size', getU64Decoder()]])],\n    [\n      'V2',\n      getStructDecoder([['padding', fixDecoderSize(getBytesDecoder(), 8)]]),\n    ],\n  ]);\n}\n\nexport function getCollectionDetailsCodec(): Codec<\n  CollectionDetailsArgs,\n  CollectionDetails\n> {\n  return combineCodec(\n    getCollectionDetailsEncoder(),\n    getCollectionDetailsDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function collectionDetails(\n  kind: 'V1',\n  data: GetDiscriminatedUnionVariantContent<\n    CollectionDetailsArgs,\n    '__kind',\n    'V1'\n  >\n): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V1'>;\nexport function collectionDetails(\n  kind: 'V2',\n  data: GetDiscriminatedUnionVariantContent<\n    CollectionDetailsArgs,\n    '__kind',\n    'V2'\n  >\n): GetDiscriminatedUnionVariant<CollectionDetailsArgs, '__kind', 'V2'>;\nexport function collectionDetails<\n  K extends CollectionDetailsArgs['__kind'],\n  Data,\n>(kind: K, data?: Data) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isCollectionDetails<K extends CollectionDetails['__kind']>(\n  kind: K,\n  value: CollectionDetails\n): value is CollectionDetails & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport type Creator = { address: Address; verified: boolean; share: number };\n\nexport type CreatorArgs = Creator;\n\nexport function getCreatorEncoder(): Encoder<CreatorArgs> {\n  return getStructEncoder([\n    ['address', getAddressEncoder()],\n    ['verified', getBooleanEncoder()],\n    ['share', getU8Encoder()],\n  ]);\n}\n\nexport function getCreatorDecoder(): Decoder<Creator> {\n  return getStructDecoder([\n    ['address', getAddressDecoder()],\n    ['verified', getBooleanDecoder()],\n    ['share', getU8Decoder()],\n  ]);\n}\n\nexport function getCreatorCodec(): Codec<CreatorArgs, Creator> {\n  return combineCodec(getCreatorEncoder(), getCreatorDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getCollectionDecoder,\n  getCollectionEncoder,\n  getCreatorDecoder,\n  getCreatorEncoder,\n  getUsesDecoder,\n  getUsesEncoder,\n  type Collection,\n  type CollectionArgs,\n  type Creator,\n  type CreatorArgs,\n  type Uses,\n  type UsesArgs,\n} from '.';\n\nexport type DataV2 = {\n  name: string;\n  symbol: string;\n  uri: string;\n  sellerFeeBasisPoints: number;\n  creators: Option<Array<Creator>>;\n  collection: Option<Collection>;\n  uses: Option<Uses>;\n};\n\nexport type DataV2Args = {\n  name: string;\n  symbol: string;\n  uri: string;\n  sellerFeeBasisPoints: number;\n  creators: OptionOrNullable<Array<CreatorArgs>>;\n  collection: OptionOrNullable<CollectionArgs>;\n  uses: OptionOrNullable<UsesArgs>;\n};\n\nexport function getDataV2Encoder(): Encoder<DataV2Args> {\n  return getStructEncoder([\n    ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ['sellerFeeBasisPoints', getU16Encoder()],\n    ['creators', getOptionEncoder(getArrayEncoder(getCreatorEncoder()))],\n    ['collection', getOptionEncoder(getCollectionEncoder())],\n    ['uses', getOptionEncoder(getUsesEncoder())],\n  ]);\n}\n\nexport function getDataV2Decoder(): Decoder<DataV2> {\n  return getStructDecoder([\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['sellerFeeBasisPoints', getU16Decoder()],\n    ['creators', getOptionDecoder(getArrayDecoder(getCreatorDecoder()))],\n    ['collection', getOptionDecoder(getCollectionDecoder())],\n    ['uses', getOptionDecoder(getUsesDecoder())],\n  ]);\n}\n\nexport function getDataV2Codec(): Codec<DataV2Args, DataV2> {\n  return combineCodec(getDataV2Encoder(), getDataV2Decoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\nimport {\n  getUseMethodDecoder,\n  getUseMethodEncoder,\n  type UseMethod,\n  type UseMethodArgs,\n} from '.';\n\nexport type Uses = { useMethod: UseMethod; remaining: bigint; total: bigint };\n\nexport type UsesArgs = {\n  useMethod: UseMethodArgs;\n  remaining: number | bigint;\n  total: number | bigint;\n};\n\nexport function getUsesEncoder(): Encoder<UsesArgs> {\n  return getStructEncoder([\n    ['useMethod', getUseMethodEncoder()],\n    ['remaining', getU64Encoder()],\n    ['total', getU64Encoder()],\n  ]);\n}\n\nexport function getUsesDecoder(): Decoder<Uses> {\n  return getStructDecoder([\n    ['useMethod', getUseMethodDecoder()],\n    ['remaining', getU64Decoder()],\n    ['total', getU64Decoder()],\n  ]);\n}\n\nexport function getUsesCodec(): Codec<UsesArgs, Uses> {\n  return combineCodec(getUsesEncoder(), getUsesDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum UseMethod {\n  Burn,\n  Multiple,\n  Single,\n}\n\nexport type UseMethodArgs = UseMethod;\n\nexport function getUseMethodEncoder(): Encoder<UseMethodArgs> {\n  return getEnumEncoder(UseMethod);\n}\n\nexport function getUseMethodDecoder(): Decoder<UseMethod> {\n  return getEnumDecoder(UseMethod);\n}\n\nexport function getUseMethodCodec(): Codec<UseMethodArgs, UseMethod> {\n  return combineCodec(getUseMethodEncoder(), getUseMethodDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport { type Address } from \"@solana/kit\";\n\nexport const TOKEN_METADATA_PROGRAM_ADDRESS =\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\" as Address<\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\">;\n\nexport enum TokenMetadataAccount {\n  CollectionAuthorityRecord,\n  MetadataDelegateRecord,\n  HolderDelegateRecord,\n  Edition,\n  EditionMarker,\n  EditionMarkerV2,\n  TokenOwnedEscrow,\n  MasterEditionV2,\n  MasterEditionV1,\n  Metadata,\n  TokenRecord,\n  ReservationListV2,\n  ReservationListV1,\n  UseAuthorityRecord,\n}\n\nexport enum TokenMetadataInstruction {\n  CreateMetadataAccount,\n  UpdateMetadataAccount,\n  DeprecatedCreateMasterEdition,\n  DeprecatedMintNewEditionFromMasterEditionViaPrintingToken,\n  UpdatePrimarySaleHappenedViaToken,\n  DeprecatedSetReservationList,\n  DeprecatedCreateReservationList,\n  SignMetadata,\n  DeprecatedMintPrintingTokensViaToken,\n  DeprecatedMintPrintingTokens,\n  CreateMasterEdition,\n  MintNewEditionFromMasterEditionViaToken,\n  ConvertMasterEditionV1ToV2,\n  MintNewEditionFromMasterEditionViaVaultProxy,\n  PuffMetadata,\n  UpdateMetadataAccountV2,\n  CreateMetadataAccountV2,\n  CreateMasterEditionV3,\n  VerifyCollection,\n  Utilize,\n  ApproveUseAuthority,\n  RevokeUseAuthority,\n  UnverifyCollection,\n  ApproveCollectionAuthority,\n  RevokeCollectionAuthority,\n  SetAndVerifyCollection,\n  FreezeDelegatedAccount,\n  ThawDelegatedAccount,\n  RemoveCreatorVerification,\n  BurnNft,\n  VerifySizedCollectionItem,\n  UnverifySizedCollectionItem,\n  SetAndVerifySizedCollectionItem,\n  CreateMetadataAccountV3,\n  SetCollectionSize,\n  SetTokenStandard,\n  BubblegumSetCollectionSize,\n  BurnEditionNft,\n  CreateEscrowAccount,\n  CloseEscrowAccount,\n  TransferOutOfEscrow,\n  Burn,\n  Create,\n  Mint,\n  Delegate,\n  Revoke,\n  Lock,\n  Unlock,\n  Migrate,\n  Transfer,\n  Update,\n  Use,\n  Verify,\n  Unverify,\n  Collect,\n  Print,\n  Resize,\n  CloseAccounts,\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * And vendored in from various codama generated client to help\n * minimize redundancy and bundle sizes\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport { isProgramDerivedAddress, type Address, type ProgramDerivedAddress } from \"@solana/kit\";\nimport { AccountRole, type IAccountMeta, upgradeRoleToSigner } from \"@solana/kit\";\nimport {\n  isTransactionSigner as web3JsIsTransactionSigner,\n  type IAccountSignerMeta,\n  type TransactionSigner,\n} from \"@solana/kit\";\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error(\"Expected a value but received null or undefined.\");\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): Address<T> {\n  if (!value) {\n    throw new Error(\"Expected a Address.\");\n  }\n  if (typeof value === \"object\" && \"address\" in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error(\"Expected a ProgramDerivedAddress.\");\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value: Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null | undefined,\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error(\"Expected a TransactionSigner.\");\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends Address<T> | ProgramDerivedAddress<T> | TransactionSigner<T> | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(programAddress: Address, optionalAccountStrategy: \"omitted\" | \"programId\") {\n  return (account: ResolvedAccount): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === \"omitted\") return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value: Address<TAddress> | ProgramDerivedAddress<TAddress> | TransactionSigner<TAddress>,\n): value is TransactionSigner<TAddress> {\n  return !!value && typeof value === \"object\" && \"address\" in value && web3JsIsTransactionSigner(value);\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n} from \"@solana/codecs\";\nimport type {\n  Address,\n  IAccountMeta,\n  IAccountSignerMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  ReadonlySignerAccount,\n  TransactionSigner,\n  WritableAccount,\n  WritableSignerAccount,\n} from \"@solana/kit\";\n\nimport { getAccountMetaFactory, type ResolvedAccount } from \"../../../shared\";\nimport { TOKEN_METADATA_PROGRAM_ADDRESS } from \"../programs\";\nimport {\n  getCollectionDetailsDecoder,\n  getCollectionDetailsEncoder,\n  getDataV2Decoder,\n  getDataV2Encoder,\n  type CollectionDetails,\n  type CollectionDetailsArgs,\n  type DataV2,\n  type DataV2Args,\n} from \"../types\";\n\nexport const CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR = 33;\n\nexport function getCreateMetadataAccountV3DiscriminatorBytes(): ReadonlyUint8Array {\n  return getU8Encoder().encode(CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR);\n}\n\nexport type CreateMetadataAccountV3Instruction<\n  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | IAccountMeta<string> = string,\n  TAccountMint extends string | IAccountMeta<string> = string,\n  TAccountMintAuthority extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends string | IAccountMeta<string> = \"11111111111111111111111111111111\",\n  TAccountRent extends string | IAccountMeta<string> | undefined = undefined,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountMetadata extends string ? WritableAccount<TAccountMetadata> : TAccountMetadata,\n      TAccountMint extends string ? ReadonlyAccount<TAccountMint> : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> & IAccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> & IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountUpdateAuthority extends string ? ReadonlyAccount<TAccountUpdateAuthority> : TAccountUpdateAuthority,\n      TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram,\n      ...(TAccountRent extends undefined\n        ? []\n        : [TAccountRent extends string ? ReadonlyAccount<TAccountRent> : TAccountRent]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateMetadataAccountV3InstructionData = {\n  discriminator: number;\n  data: DataV2;\n  isMutable: boolean;\n  collectionDetails: Option<CollectionDetails>;\n};\n\nexport type CreateMetadataAccountV3InstructionDataArgs = {\n  data: DataV2Args;\n  isMutable: boolean;\n  collectionDetails: OptionOrNullable<CollectionDetailsArgs>;\n};\n\nexport function getCreateMetadataAccountV3InstructionDataEncoder(): Encoder<CreateMetadataAccountV3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"data\", getDataV2Encoder()],\n      [\"isMutable\", getBooleanEncoder()],\n      [\"collectionDetails\", getOptionEncoder(getCollectionDetailsEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_METADATA_ACCOUNT_V3_DISCRIMINATOR,\n    }),\n  );\n}\n\nexport function getCreateMetadataAccountV3InstructionDataDecoder(): Decoder<CreateMetadataAccountV3InstructionData> {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"data\", getDataV2Decoder()],\n    [\"isMutable\", getBooleanDecoder()],\n    [\"collectionDetails\", getOptionDecoder(getCollectionDetailsDecoder())],\n  ]);\n}\n\nexport function getCreateMetadataAccountV3InstructionDataCodec(): Codec<\n  CreateMetadataAccountV3InstructionDataArgs,\n  CreateMetadataAccountV3InstructionData\n> {\n  return combineCodec(\n    getCreateMetadataAccountV3InstructionDataEncoder(),\n    getCreateMetadataAccountV3InstructionDataDecoder(),\n  );\n}\n\nexport type CreateMetadataAccountV3Input<\n  TAccountMetadata extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n  TAccountPayer extends string = string,\n  TAccountUpdateAuthority extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Metadata key (pda of ['metadata', program id, mint id]) */\n  metadata: Address<TAccountMetadata>;\n  /** Mint of token asset */\n  mint: Address<TAccountMint>;\n  /** Mint authority */\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  /** payer */\n  payer: TransactionSigner<TAccountPayer>;\n  /** update authority info */\n  updateAuthority: Address<TAccountUpdateAuthority> | TransactionSigner<TAccountUpdateAuthority>;\n  /** System program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** Rent info */\n  rent?: Address<TAccountRent>;\n  data: CreateMetadataAccountV3InstructionDataArgs[\"data\"];\n  isMutable: CreateMetadataAccountV3InstructionDataArgs[\"isMutable\"];\n  collectionDetails: CreateMetadataAccountV3InstructionDataArgs[\"collectionDetails\"];\n};\n\nexport function getCreateMetadataAccountV3Instruction<\n  TAccountMetadata extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TAccountPayer extends string,\n  TAccountUpdateAuthority extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n>(\n  input: CreateMetadataAccountV3Input<\n    TAccountMetadata,\n    TAccountMint,\n    TAccountMintAuthority,\n    TAccountPayer,\n    TAccountUpdateAuthority,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress },\n): CreateMetadataAccountV3Instruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountMint,\n  TAccountMintAuthority,\n  TAccountPayer,\n  (typeof input)[\"updateAuthority\"] extends TransactionSigner<TAccountUpdateAuthority>\n    ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority>\n    : TAccountUpdateAuthority,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_METADATA_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\" as Address<\"11111111111111111111111111111111\">;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, \"omitted\");\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    programAddress,\n    data: getCreateMetadataAccountV3InstructionDataEncoder().encode(args as CreateMetadataAccountV3InstructionDataArgs),\n  } as CreateMetadataAccountV3Instruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountMint,\n    TAccountMintAuthority,\n    TAccountPayer,\n    (typeof input)[\"updateAuthority\"] extends TransactionSigner<TAccountUpdateAuthority>\n      ? ReadonlySignerAccount<TAccountUpdateAuthority> & IAccountSignerMeta<TAccountUpdateAuthority>\n      : TAccountUpdateAuthority,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateMetadataAccountV3Instruction<\n  TProgram extends string = typeof TOKEN_METADATA_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Metadata key (pda of ['metadata', program id, mint id]) */\n    metadata: TAccountMetas[0];\n    /** Mint of token asset */\n    mint: TAccountMetas[1];\n    /** Mint authority */\n    mintAuthority: TAccountMetas[2];\n    /** payer */\n    payer: TAccountMetas[3];\n    /** update authority info */\n    updateAuthority: TAccountMetas[4];\n    /** System program */\n    systemProgram: TAccountMetas[5];\n    /** Rent info */\n    rent?: TAccountMetas[6] | undefined;\n  };\n  data: CreateMetadataAccountV3InstructionData;\n};\n\nexport function parseCreateMetadataAccountV3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> & IInstructionWithAccounts<TAccountMetas> & IInstructionWithData<Uint8Array>,\n): ParsedCreateMetadataAccountV3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 6;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n      payer: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextOptionalAccount(),\n    },\n    data: getCreateMetadataAccountV3InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { type Address, type KeyPairSigner, getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { checkedAddress } from \"../../core/utils\";\nimport { TOKEN_METADATA_PROGRAM_ADDRESS } from \"./generated\";\n\n/**\n * Derive the Token Metadata address from a token's mint address\n *\n * @param `mint` - `Address` or `KeyPairSigner` of the token mint\n */\nexport async function getTokenMetadataAddress(mint: Address | KeyPairSigner): Promise<Address> {\n  return (\n    await getProgramDerivedAddress({\n      programAddress: TOKEN_METADATA_PROGRAM_ADDRESS,\n      seeds: [\n        Buffer.from(\"metadata\"),\n        getAddressEncoder().encode(TOKEN_METADATA_PROGRAM_ADDRESS),\n        getAddressEncoder().encode(checkedAddress(mint)),\n      ],\n    })\n  )[0];\n}\n","import { getCreateAccountInstruction } from \"@solana-program/system\";\nimport type { Address, IInstruction, KeyPairSigner, TransactionSigner } from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, getMinimumBalanceForRentExemption } from \"../../../core\";\nimport { getCreateMetadataAccountV3Instruction, getTokenMetadataAddress } from \"../../token-metadata\";\n\nimport {\n  extension,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintInstruction,\n  getInitializeTokenMetadataInstruction,\n  getMintSize,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetCreateTokenInstructionsArgs = TokenInstructionBase<KeyPairSigner> & {\n  /**\n   * The number of decimal places this token should have\n   *\n   * @default `9` - the most commonly used decimals value\n   **/\n  decimals?: bigint | number;\n  /**\n   * Authority address that is allowed to mint new tokens\n   *\n   * When not provided, defaults to: `feePayer`\n   **/\n  mintAuthority?: TransactionSigner;\n  /**\n   * Authority address that is able to freeze (and thaw) user owned token accounts.\n   * When a user's token account is frozen, they will not be able to transfer their tokens.\n   *\n   * When not provided, defaults to: `null`\n   **/\n  freezeAuthority?: Address | TransactionSigner;\n  /**\n   * Authority address that is allowed to update the metadata\n   *\n   * When not provided, defaults to: `feePayer`\n   **/\n  updateAuthority?: TransactionSigner;\n  /**\n   * Optional (but highly recommended) metadata to attach to this token\n   */\n  metadata: {\n    /** Name of this token */\n    name: string;\n    /** Symbol for this token */\n    symbol: string;\n    /** URI pointing to additional metadata for this token. Typically an offchain json file. */\n    uri: string;\n    /** Whether or not the onchain metadata will be editable after minting */\n    isMutable: boolean;\n  };\n  /**\n   * Metadata address for this token\n   *\n   * @example\n   * For `TOKEN_PROGRAM_ADDRESS` use the {@link getTokenMetadataAddress} function:\n   * ```\n   * metadataAddress: await getTokenMetadataAddress(mint.address);\n   * ```\n   *\n   * @example\n   * For `TOKEN_2022_PROGRAM_ADDRESS` use the mint's address:\n   * ```\n   * metadataAddress: mint.address;\n   * ```\n   * */\n  metadataAddress: Address;\n  // extensions // todo\n};\n\n/**\n * Create the instructions required to initialize a new token's mint\n */\nexport function getCreateTokenInstructions(args: GetCreateTokenInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n\n  if (args.decimals == null) args.decimals = 9;\n  if (!args.mintAuthority) args.mintAuthority = args.feePayer;\n  if (!args.updateAuthority) args.updateAuthority = args.feePayer;\n  if (args.freezeAuthority) args.freezeAuthority = checkedAddress(args.freezeAuthority);\n\n  if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {\n    const metadataPointer = extension(\"MetadataPointer\", {\n      metadataAddress: args.mint.address,\n      authority: args.updateAuthority.address,\n    });\n\n    const metadataExtensionData = extension(\"TokenMetadata\", {\n      updateAuthority: args.updateAuthority.address,\n      mint: args.mint.address,\n      name: args.metadata.name,\n      symbol: args.metadata.symbol,\n      uri: args.metadata.uri,\n      // todo: support token22 additional metadata\n      additionalMetadata: new Map(),\n    });\n\n    return [\n      getCreateAccountInstruction({\n        payer: args.feePayer,\n        newAccount: args.mint,\n        /**\n         * token22 requires only the pre-mint-initialization extensions (like metadata pointer)\n         * to be the `space`. then it will extend the account's space for each applicable extension\n         * */\n        space: BigInt(getMintSize([metadataPointer])),\n        /**\n         * token22 requires the total lamport balance for all extensions,\n         * including pre-initialization and post-initialization\n         */\n        lamports: getMinimumBalanceForRentExemption(BigInt(getMintSize([metadataPointer, metadataExtensionData]))),\n        programAddress: args.tokenProgram,\n      }),\n      getInitializeMetadataPointerInstruction({\n        authority: args.mintAuthority.address,\n        metadataAddress: args.metadataAddress,\n        mint: args.mint.address,\n      }),\n      getInitializeMintInstruction(\n        {\n          mint: args.mint.address,\n          decimals: Number(args.decimals),\n          mintAuthority: args.mintAuthority.address,\n          freezeAuthority: args.freezeAuthority || null,\n        },\n        {\n          programAddress: args.tokenProgram,\n        },\n      ),\n      getInitializeTokenMetadataInstruction({\n        metadata: args.mint.address,\n        mint: args.mint.address,\n        mintAuthority: args.mintAuthority,\n        name: args.metadata.name,\n        symbol: args.metadata.symbol,\n        uri: args.metadata.uri,\n        updateAuthority: args.updateAuthority.address,\n      }),\n      // todo: support token22 additional metadata by adding that instruction(s) here\n    ];\n  } else {\n    // the token22 `getMintSize` is fully compatible with the original token program\n    const space: bigint = BigInt(getMintSize());\n\n    return [\n      getCreateAccountInstruction({\n        payer: args.feePayer,\n        newAccount: args.mint,\n        lamports: getMinimumBalanceForRentExemption(space),\n        space,\n        programAddress: args.tokenProgram,\n      }),\n      getInitializeMintInstruction(\n        {\n          mint: args.mint.address,\n          decimals: Number(args.decimals),\n          mintAuthority: args.mintAuthority.address,\n          freezeAuthority: args.freezeAuthority || null,\n        },\n        {\n          programAddress: args.tokenProgram,\n        },\n      ),\n      getCreateMetadataAccountV3Instruction({\n        metadata: args.metadataAddress,\n        mint: args.mint.address,\n        mintAuthority: args.mintAuthority,\n        payer: args.feePayer,\n        updateAuthority: args.updateAuthority,\n        data: {\n          name: args.metadata.name,\n          symbol: args.metadata.symbol,\n          uri: args.metadata.uri,\n          sellerFeeBasisPoints: 0,\n          creators: null,\n          collection: null,\n          uses: null,\n        },\n        isMutable: args.metadata.isMutable,\n        collectionDetails: null,\n      }),\n    ];\n  }\n}\n","import type { Address, IInstruction, TransactionSigner } from \"@solana/kit\";\n\nimport { getCreateAssociatedTokenIdempotentInstruction, getMintToInstruction } from \"@solana-program/token-2022\";\nimport { checkedAddress, checkedTransactionSigner } from \"../../../core\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetMintTokensInstructionsArgs = TokenInstructionBase & {\n  /**\n   * The authority address capable of authorizing minting of new tokens.\n   *\n   * - this should normally by a `TransactionSigner`\n   * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`\n   * */\n  mintAuthority: TransactionSigner | Address;\n  /** Wallet address to receive the tokens being minted, via their associated token account (ata) */\n  destination: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `destination` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n   * ```\n   * */\n  ata: Address;\n  /** Amount of tokens to mint to the `owner` via their `ata` */\n  amount: bigint | number;\n};\n\n/**\n * Create the instructions required to mint tokens to any wallet/owner,\n * including creating their ATA if it does not exist\n *\n * @example\n *\n * ```\n * const mint = await generateKeyPairSigner();\n * const destination = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\n *\n * const instructions = getMintTokensInstructions({\n *   mint,\n *   feePayer: signer,\n *   mintAuthority: signer,\n *   amount: 1000, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will mint 10.00 tokens\n *   // if decimals=4 => this will mint 0.100 tokens\n *   destination,\n *   // be sure to set the correct token program when getting the `ata`\n *   ata: await getAssociatedTokenAccountAddress(mint, destination, tokenProgram),\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport function getMintTokensInstructions(args: GetMintTokensInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  return [\n    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!\n    getCreateAssociatedTokenIdempotentInstruction({\n      owner: checkedAddress(args.destination),\n      mint: args.mint,\n      ata: args.ata,\n      payer: args.feePayer,\n      tokenProgram: args.tokenProgram,\n    }),\n    getMintToInstruction(\n      {\n        mint: args.mint,\n        mintAuthority: args.mintAuthority,\n        token: args.ata,\n        amount: args.amount,\n      },\n      {\n        programAddress: args.tokenProgram,\n      },\n    ),\n  ];\n}\n","import type { Address, IInstruction, TransactionSigner } from \"@solana/kit\";\n\nimport { getCreateAssociatedTokenIdempotentInstruction, getTransferInstruction } from \"@solana-program/token-2022\";\nimport { checkedAddress, checkedTransactionSigner } from \"../../../core\";\nimport { checkedTokenProgramAddress } from \"../addresses\";\nimport type { TokenInstructionBase } from \"./types\";\n\nexport type GetTransferTokensInstructionsArgs = TokenInstructionBase & {\n  /**\n   * The source account's owner/delegate or its multi-signature account:\n   * - this should normally by a `TransactionSigner`\n   * - only for multi-sig authorities (like Squads Protocol), should you supply an `Address`\n   * */\n  authority: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `authority` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, authority, tokenProgram);\n   * ```\n   * */\n  sourceAta: Address;\n  /** Wallet address to receive the tokens, via their associated token account: `destinationAta` */\n  destination: TransactionSigner | Address;\n  /**\n   * Associated token account (ata) address for `destination` and this `mint`\n   *\n   * See {@link getAssociatedTokenAccountAddress}\n   *\n   * @example\n   * ```\n   * getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n   * ```\n   * */\n  destinationAta: Address;\n  /** Amount of tokens to be transferred to the `destination` via their `destinationAta` */\n  amount: bigint | number;\n};\n\n/**\n * Create the instructions required to transfer tokens from one wallet to another,\n * including creating the destination ATA if it does not exist\n *\n * @example\n *\n * ```\n * const sourceAta = await getAssociatedTokenAccountAddress(mint, authority, tokenProgram);\n *\n * const destination = address(...);\n * const destinationAta = await getAssociatedTokenAccountAddress(mint, destination, tokenProgram);\n *\n * const instructions = getTransferTokensInstructions({\n *    feePayer: signer,\n *    mint,\n *    amount: 10,\n *    authority: signer, // the source wallet for the tokens to be transferred\n *    sourceAta, // normally derived from the `authority`\n *    destination,\n *    destinationAta, // derived from the `destination`\n *    tokenProgram,\n * });\n * ```\n */\nexport function getTransferTokensInstructions(args: GetTransferTokensInstructionsArgs): IInstruction[] {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  return [\n    // create idempotent will gracefully fail if the ata already exists. this is the gold standard!\n    getCreateAssociatedTokenIdempotentInstruction({\n      owner: checkedAddress(args.destination),\n      mint: args.mint,\n      ata: args.destinationAta,\n      payer: args.feePayer,\n      tokenProgram: args.tokenProgram,\n    }),\n    getTransferInstruction(\n      {\n        authority: args.authority,\n        source: args.sourceAta,\n        destination: args.destinationAta,\n        amount: args.amount,\n      },\n      {\n        programAddress: args.tokenProgram,\n      },\n    ),\n  ];\n}\n","import { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type {\n  ITransactionMessageWithFeePayer,\n  KeyPairSigner,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { getTokenMetadataAddress } from \"../../token-metadata\";\nimport { checkedTokenProgramAddress, TOKEN_PROGRAM_ADDRESS } from \"../addresses\";\nimport { getCreateTokenInstructions, type GetCreateTokenInstructionsArgs } from \"../instructions/create-token\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetCreateTokenTransactionInput = Simplify<\n  Omit<GetCreateTokenInstructionsArgs, \"metadataAddress\"> &\n    Partial<Pick<GetCreateTokenInstructionsArgs, \"metadataAddress\">>\n>;\n\n/**\n * Create a transaction that can create a token with metadata\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit`:\n *    - for TOKEN_PROGRAM_ADDRESS => `60_000`\n *    - for TOKEN_2022_PROGRAM_ADDRESS => `10_000`\n *\n * @example\n *\n * ```\n * const mint = await generateKeyPairSigner();\n *\n * const transaction = await buildCreateTokenTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   metadata: {\n *     name: \"Test Token\",\n *     symbol: \"TEST\",\n *     uri: \"https://example.com/metadata.json\",\n *     isMutable: true,\n *   },\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildCreateTokenTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n\n  let metadataAddress = args.mint.address;\n\n  if (args.tokenProgram === TOKEN_PROGRAM_ADDRESS) {\n    metadataAddress = await getTokenMetadataAddress(args.mint);\n\n    // default a reasonably low computeUnitLimit based on simulation data\n    if (!args.computeUnitLimit) {\n      // creating the token's mint is around 3219cu (and stable?)\n      // token metadata is the rest... and fluctuates a lot based on the pda and amount of metadata\n      args.computeUnitLimit = 60_000;\n    }\n  } else if (args.tokenProgram === TOKEN_2022_PROGRAM_ADDRESS) {\n    if (!args.computeUnitLimit) {\n      // token22 token creation, with metadata is (seemingly stable) around 7647cu,\n      // but consume more with more metadata provided\n      args.computeUnitLimit = 10_000;\n    }\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getCreateTokenInstructions(\n        (({\n          decimals,\n          mintAuthority,\n          freezeAuthority,\n          updateAuthority,\n          metadata,\n          feePayer,\n          tokenProgram,\n          mint,\n        }: typeof args) => ({\n          mint: mint as KeyPairSigner,\n          feePayer,\n          metadataAddress,\n          metadata,\n          decimals,\n          mintAuthority,\n          freezeAuthority,\n          updateAuthority,\n          tokenProgram,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n","import type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { checkedTokenProgramAddress, getAssociatedTokenAccountAddress } from \"../addresses\";\nimport { getMintTokensInstructions, type GetMintTokensInstructionsArgs } from \"../instructions/mint-tokens\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetCreateTokenTransactionInput = Simplify<\n  Omit<GetMintTokensInstructionsArgs, \"ata\"> & Partial<Pick<GetMintTokensInstructionsArgs, \"ata\">>\n>;\n\n/**\n * Create a transaction that can mint tokens to the desired wallet/owner,\n * including creating their ATA if it does not exist\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit` = `31_000`\n *\n * @remarks\n *\n * - minting without creating the ata is generally < 10_000cu\n * - validating the ata onchain during creation results in a ~5000cu fluctuation\n *\n * @example\n * ```\n * const destination = address(\"nicktrLHhYzLmoVbuZQzHUTicd2sfP571orwo9jfc8c\");\n *\n * const mint = address(...);\n * // or mint can be a keypair from a freshly created token\n *\n * const transaction = await buildMintTokensTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   mintAuthority: signer,\n *   amount: 1000, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will mint 10.00 tokens\n *   // if decimals=4 => this will mint 0.100 tokens\n *   destination,\n *   // tokenProgram: TOKEN_PROGRAM_ADDRESS, // default\n *   // tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n * });\n * ```\n */\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildMintTokensTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetCreateTokenTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  if (!args.ata) {\n    args.ata = await getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram);\n  }\n\n  // default a reasonably low computeUnitLimit based on simulation data\n  if (!args.computeUnitLimit) {\n    /**\n     * for TOKEN_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 9156cu\n     * - when creating the ata: 26535cu\n     *\n     * for TOKEN_2022_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 8978cu\n     * - when creating the ata: 22567cu\n     */\n    args.computeUnitLimit = 31_000;\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getMintTokensInstructions(\n        (({ tokenProgram, feePayer, mint, ata, mintAuthority, amount, destination }: typeof args) => ({\n          tokenProgram,\n          feePayer,\n          mint,\n          mintAuthority,\n          ata: ata as Address,\n          amount,\n          destination,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n","import type {\n  Address,\n  ITransactionMessageWithFeePayer,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionSigner,\n  TransactionVersion,\n} from \"@solana/kit\";\nimport { checkedAddress, checkedTransactionSigner, createTransaction } from \"../../../core\";\nimport type { FullTransaction, Simplify } from \"../../../types\";\nimport { checkedTokenProgramAddress, getAssociatedTokenAccountAddress } from \"../addresses\";\nimport { getTransferTokensInstructions, type GetTransferTokensInstructionsArgs } from \"../instructions\";\nimport type { TransactionBuilderInput } from \"./types\";\n\ntype GetTransferTokensTransactionInput = Simplify<\n  Omit<GetTransferTokensInstructionsArgs, \"sourceAta\" | \"destinationAta\"> &\n    Partial<Pick<GetTransferTokensInstructionsArgs, \"sourceAta\" | \"destinationAta\">>\n>;\n\n/**\n * Create a transaction that can transfer tokens to the desired wallet/owner,\n * including creating their ATA if it does not exist\n *\n * The transaction has the following defaults:\n * - Default `version` = `legacy`\n * - Default `computeUnitLimit` = `31_000`\n *\n * @remarks\n *\n * - transferring without creating the ata is generally < 10_000cu\n * - validating the ata onchain during creation results in a ~15000cu fluctuation\n *\n * @example\n * ```\n * const destination = address(...);\n *\n * const transferTokensTx = await buildTransferTokensTransaction({\n *   feePayer: signer,\n *   latestBlockhash,\n *   mint,\n *   authority: signer,\n *   amount: 900, // note: be sure to consider the mint's `decimals` value\n *   // if decimals=2 => this will transfer 9.00 tokens\n *   // if decimals=4 => this will transfer 0.090 tokens\n *   destination,\n *   // use the correct token program for the `mint`\n *   tokenProgram, // default=TOKEN_PROGRAM_ADDRESS\n *   // default cu limit set to be optimized, but can be overridden here\n *   // computeUnitLimit?: number,\n *   // obtain from your favorite priority fee api\n *   // computeUnitPrice?: number, // no default set\n * });\n * ```\n */\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer> & GetTransferTokensTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer>>;\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion = \"legacy\",\n  TFeePayer extends TransactionSigner = TransactionSigner,\n  TLifetimeConstraint extends\n    TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"] = TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(\n  args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetTransferTokensTransactionInput,\n): Promise<FullTransaction<TVersion, ITransactionMessageWithFeePayer, TransactionMessageWithBlockhashLifetime>>;\nexport async function buildTransferTokensTransaction<\n  TVersion extends TransactionVersion,\n  TFeePayer extends Address | TransactionSigner,\n  TLifetimeConstraint extends TransactionMessageWithBlockhashLifetime[\"lifetimeConstraint\"],\n>(args: TransactionBuilderInput<TVersion, TFeePayer, TLifetimeConstraint> & GetTransferTokensTransactionInput) {\n  args.tokenProgram = checkedTokenProgramAddress(args.tokenProgram);\n  args.feePayer = checkedTransactionSigner(args.feePayer);\n  args.mint = checkedAddress(args.mint);\n\n  [args.destinationAta, args.sourceAta] = await Promise.all([\n    !args.destinationAta\n      ? getAssociatedTokenAccountAddress(args.mint, args.destination, args.tokenProgram)\n      : args.destinationAta,\n    !args.sourceAta ? getAssociatedTokenAccountAddress(args.mint, args.authority, args.tokenProgram) : args.sourceAta,\n  ]);\n\n  // default a reasonably low computeUnitLimit based on simulation data\n  if (!args.computeUnitLimit) {\n    /**\n     * for TOKEN_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 6336cu - 12336cu\n     * - when creating the ata: 19428cu - 25034cu\n     *\n     * for TOKEN_2022_PROGRAM_ADDRESS and multiple simulation attempts,\n     * minting tokens costs the following:\n     * - when not creating the ata: 6157cu - 15157cu\n     * - when creating the ata: 18722cu - 27722cu\n     */\n    args.computeUnitLimit = 31_000;\n  }\n\n  return createTransaction(\n    (({ feePayer, version, computeUnitLimit, computeUnitPrice, latestBlockhash }: typeof args) => ({\n      feePayer,\n      version: version || \"legacy\",\n      computeUnitLimit,\n      computeUnitPrice,\n      latestBlockhash,\n      instructions: getTransferTokensInstructions(\n        (({\n          tokenProgram,\n          feePayer,\n          mint,\n          amount,\n          destination,\n          authority,\n          destinationAta,\n          sourceAta,\n        }: typeof args) => ({\n          tokenProgram,\n          feePayer,\n          mint,\n          amount,\n          authority,\n          destination,\n          sourceAta: sourceAta as Address,\n          destinationAta: destinationAta as Address,\n        }))(args),\n      ),\n    }))(args),\n  );\n}\n","/**\n * Converts a UI amount (human-readable) to raw amount (BigInt)\n * @param uiAmount The human-readable token amount (e.g., 1.5)\n * @param decimals The number of decimals for the token\n * @returns BigInt representation of the amount\n */\nexport function tokenUiAmountToAmount(uiAmount: number, decimals: number): bigint {\n  // Handle potential scientific notation by using the built-in toFixed\n  // This ensures we get a decimal string representation without scientific notation\n  const uiAmountStr = uiAmount.toFixed(decimals);\n\n  // Find decimal point position\n  const decimalPointIndex = uiAmountStr.indexOf(\".\");\n\n  let wholeNumber: string;\n  let fractionalPart: string;\n\n  if (decimalPointIndex === -1) {\n    // No decimal point\n    wholeNumber = uiAmountStr;\n    fractionalPart = \"\";\n  } else {\n    wholeNumber = uiAmountStr.substring(0, decimalPointIndex);\n    fractionalPart = uiAmountStr.substring(decimalPointIndex + 1);\n  }\n\n  // Pad or truncate fractional part based on decimals\n  if (fractionalPart.length > decimals) {\n    fractionalPart = fractionalPart.substring(0, decimals);\n  } else {\n    fractionalPart = fractionalPart.padEnd(decimals, \"0\");\n  }\n\n  // Combine and convert to BigInt, stripping any potential leading zeros\n  const rawAmountStr = wholeNumber + fractionalPart;\n  if (rawAmountStr.replace(/0/g, \"\") === \"\") {\n    return BigInt(0);\n  }\n  return BigInt(rawAmountStr);\n}\n\n/**\n * Converts a raw amount (BigInt) to UI amount (human-readable)\n * @param amount The raw token amount as BigInt\n * @param decimals The number of decimals for the token\n * @returns UI representation of the amount as a number\n */\nexport function tokenAmountToUiAmount(amount: bigint, decimals: number): number {\n  // Convert to string for easier manipulation\n  let amountStr = amount.toString();\n\n  // Pad with leading zeros if necessary\n  if (amountStr.length <= decimals) {\n    amountStr = amountStr.padStart(decimals + 1, \"0\");\n  }\n\n  // Split into whole and fractional parts\n  const wholePartLength = amountStr.length - decimals;\n  const wholePart = amountStr.substring(0, wholePartLength);\n  const fractionalPart = amountStr.substring(wholePartLength);\n\n  // Combine with decimal point\n  const uiAmountStr = `${wholePart || \"0\"}.${fractionalPart}`;\n\n  // Convert back to number\n  return parseFloat(uiAmountStr);\n}\n"],"names":["getStructEncoder","getStructDecoder","combineCodec","getAddressEncoder","getBooleanEncoder","getAddressDecoder","getBooleanDecoder","getU64Encoder","getU64Decoder","UseMethod","TokenMetadataAccount","TokenMetadataInstruction","web3JsIsTransactionSigner","getU8Encoder","getOptionEncoder","getU8Decoder","getOptionDecoder","TOKEN_2022_PROGRAM_ADDRESS","getCreateAssociatedTokenIdempotentInstruction","feePayer"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AUcQ;;;;;;;;;;;;;;;;;;AVJD,IAAM,qBACX,GAAA;AAYF,eAAsB,gCAAA,CACpB,IACA,EAAA,KAAA,EACA,YACkB,EAAA;IAClB,OAAA,CACE,2LAAM,yBAAA,AAAuB,EAAA;QAC3B,IAAA,oKAAM,iBAAA,EAAe,IAAI,CAAA;QACzB,KAAA,oKAAO,iBAAA,EAAe,KAAK,CAAA;QAC3B,YAAA,EAAc,2BAA2B,YAAY;IAAA,CACtD,CAAA,CAAA,CACD,CAAC,CAAA;AACL;AAEO,SAAS,kCAAkC,YAAuD,EAAA;IACnG,IAAA,8MAAC,YAAA,AAAU,EAAA,YAAY,CAAG,EAAA;QAC5B,YAAA,GAAe,aAAa,WAAY,EAAA;IAAA;IAE1C,OAAQ,YAAc;QACpB,KAAK,QAAA;QACL,KAAK,OAAA;QACL,KAAK,qBAAuB;YAAA;gBACnB,OAAA,qBAAA;YAAA;QAET,KAAK,SAAA;QACL,KAAK,WAAA;QACL,KAAK,gBAAA;QACL,KAAK,iBAAA;QACL,sLAAK,6BAA4B;YAAA;gBACxB,wLAAA,6BAAA;YAAA;QAET;YACE,MAAM,MAAM,wFAAwF,CAAA;IAAA;AAE1G;AAEO,SAAS,8BACd,YACsD,EAAA;IAClD,IAAA,YAAA,KAAiB,qBAAyB,IAAA,YAAA,sLAAiB,6BAA4B,EAAA;QACzF,MAAM,MAAM,wFAAwF,CAAA;IAAA;AAExG;AAWO,SAAS,2BAA2B,YAAwD,EAAA;IAC7F,IAAA,CAAC,cAAqB,OAAA,qBAAA;IAC1B,YAAA,GAAe,kCAAkC,YAAY,CAAA;IAC7D,6BAAA,CAA8B,YAAY,CAAA;IACnC,OAAA,YAAA;AACT;ACvDO,SAAS,oBAAgD,GAAA;IAC9D,0OAAO,mBAAA,AAAiB,EAAA;QACtB;YAAC,UAAY;+OAAA,oBAAA,EAAmB;SAAA;QAChC;YAAC,KAAO;yNAAA,oBAAA,EAAmB;SAAA;KAC5B,CAAA;AACH;AAEO,SAAS,oBAA4C,GAAA;IAC1D,0OAAO,mBAAA,AAAiB,EAAA;QACtB;YAAC,UAAY;+OAAA,oBAAA,EAAmB;SAAA;QAChC;YAAC,KAAO;aAAA,gOAAA,EAAmB;SAAA;KAC5B,CAAA;AACH;AAEO,SAAS,kBAAwD,GAAA;IACtE,4NAAO,eAAA,AAAa,EAAA,oBAAA,EAAwB,EAAA,oBAAA,EAAsB,CAAA;AACpE;ACNO,SAAS,2BAA8D,GAAA;IAC5E,0OAAO,+BAAA,AAA6B,EAAA;QAClC;YAAC,IAAMA;+OAAAA,mBAAAA,EAAiB;gBAAC;oBAAC;4OAAQ,gBAAA,AAAc,EAAC;iBAAC;aAAC,CAAC;SAAA;QACpD;YACE,IAAA;+OACAA,mBAAAA,EAAiB;gBAAC;oBAAC,SAAW;yOAAA,iBAAA,oOAAe,mBAAA,EAAmB,GAAA,CAAC,CAAC;iBAAC;aAAC;SAAA;KAEvE,CAAA;AACH;AAEO,SAAS,2BAA0D,GAAA;IACxE,WAAO,8PAAA,AAA6B,EAAA;QAClC;YAAC,IAAMC;+OAAAA,mBAAAA,EAAiB;gBAAC;oBAAC;oBAAQ,wOAAA,AAAc,EAAC;iBAAC;aAAC,CAAC;SAAA;QACpD;YACE,IAAA;+OACAA,mBAAAA,EAAiB;gBAAC;oBAAC,SAAW;wOAAA,kBAAA,qOAAe,kBAAA,EAAmB,GAAA,CAAC,CAAC;iBAAC;aAAC;SAAA;KAEvE,CAAA;AACH;AAEO,SAAS,yBAGd,GAAA;IACOC,4NAAAA,eAAAA,EACL,2BAA4B,EAAA,EAC5B,2BAA4B;AAEhC;AAmBO,SAAS,iBAAA,CAGd,IAAA,EAAS,IAAa,EAAA;IACtB,OAAO,MAAM,OAAQ,CAAA,IAAI,CACrB,GAAA;QAAE,QAAQ,IAAM;QAAA,MAAA,EAAQ,IAAK;IAAA,CAAA,GAC7B;QAAE,MAAQ,EAAA,IAAA;QAAM,sCAAI,IAAA,GAAQ,CAAA,CAAI;IAAA,CAAA;AACtC;AAEO,SAAS,mBAAA,CACd,IAAA,EACA,KAC4C,EAAA;IAC5C,OAAO,MAAM,MAAW,KAAA,IAAA;AAC1B;ACrEO,SAAS,iBAA0C,GAAA;IACxD,0OAAOF,mBAAAA,AAAiB,EAAA;QACtB;YAAC,SAAWG;yNAAAA,oBAAAA,EAAmB;SAAA;QAC/B;YAAC,UAAYC;+OAAAA,oBAAAA,EAAmB;SAAA;QAChC;YAAC,OAAS;YAAA,uOAAA,EAAc;SAAA;KACzB,CAAA;AACH;AAEO,SAAS,iBAAsC,GAAA;IACpD,yOAAOH,oBAAAA,AAAiB,EAAA;QACtB;YAAC,SAAWI;yNAAAA,oBAAAA,EAAmB;SAAA;QAC/B;YAAC,UAAYC;+OAAAA,oBAAAA,EAAmB;SAAA;QAChC;YAAC,OAAS;YAAA,uOAAA,EAAc;SAAA;KACzB,CAAA;AACH;AAEO,SAAS,eAA+C,GAAA;IAC7D,2NAAOJ,gBAAAA,AAAa,EAAA,iBAAA,EAAqB,EAAA,iBAAA,EAAmB,CAAA;AAC9D;ACmBO,SAAS,gBAAwC,GAAA;IACtD,0OAAOF,mBAAAA,AAAiB,EAAA;QACtB;YAAC,MAAQ;iOAAA,uBAAA,EAAqB,yOAAA,EAAkB,2NAAA,gBAAA,EAAe,CAAC;SAAA;QAChE;YAAC,QAAU;YAAA,4OAAA,0NAAqB,iBAAA,EAAkB,2NAAA,gBAAA,EAAe,CAAC;SAAA;QAClE;YAAC,KAAO;gBAAA,wOAAA,0NAAqB,iBAAA,EAAkB,2NAAA,gBAAA,EAAe,CAAC;SAAA;QAC/D;YAAC,sBAAwB;YAAA,wOAAA,EAAe;SAAA;QACxC;YAAC,UAAY;oLAAA,mBAAA,qOAAiB,kBAAA,EAAgB,iBAAkB,EAAC,CAAC,CAAC;SAAA;QACnE;YAAC,YAAA;gBAAc,uLAAA,AAAiB,EAAA,oBAAA,EAAsB,CAAC;SAAA;QACvD;YAAC,MAAA;oLAAQ,mBAAA,AAAiB,EAAA,cAAA,EAAgB,CAAC;SAAA;KAC5C,CAAA;AACH;AAEO,SAAS,gBAAoC,GAAA;IAClD,0OAAOC,mBAAAA,AAAiB,EAAA;QACtB;YAAC,MAAQ;aAAA,2OAAA,0NAAqB,iBAAA,EAAkB,2NAAA,gBAAA,EAAe,CAAC;SAAA;QAChE;YAAC,QAAU;iOAAA,uBAAA,0NAAqB,iBAAA,EAAkB,2NAAA,gBAAA,EAAe,CAAC;SAAA;QAClE;YAAC,KAAO;YAAA,4OAAA,0NAAqB,iBAAA,EAAkB,2NAAA,gBAAA,EAAe,CAAC;SAAA;QAC/D;YAAC,sBAAwB;aAAA,uOAAA,EAAe;SAAA;QACxC;YAAC,UAAY;mLAAA,oBAAA,qOAAiB,kBAAA,EAAgB,iBAAkB,EAAC,CAAC,CAAC;SAAA;QACnE;YAAC,YAAA;oLAAc,mBAAA,AAAiB,EAAA,oBAAA,EAAsB,CAAC;SAAA;QACvD;YAAC,MAAA;oLAAQ,mBAAA,AAAiB,EAAA,cAAA,EAAgB,CAAC;SAAA;KAC5C,CAAA;AACH;AAEO,SAAS,cAA4C,GAAA;IAC1D,OAAOC,oOAAAA,AAAa,EAAA,gBAAA,EAAoB,EAAA,gBAAA,EAAkB,CAAA;AAC5D;AC1DO,SAAS,cAAoC,GAAA;IAClD,0OAAOF,mBAAAA,AAAiB,EAAA;QACtB;YAAC,WAAa;YAAA,mBAAA,EAAqB;SAAA;QACnC;YAAC,WAAaO;gBAAAA,oOAAAA,EAAe;SAAA;QAC7B;YAAC,OAASA;oOAAAA,gBAAAA,EAAe;SAAA;KAC1B,CAAA;AACH;AAEO,SAAS,cAAgC,GAAA;IAC9C,WAAON,kPAAAA,AAAiB,EAAA;QACtB;YAAC,WAAa;YAAA,mBAAA,EAAqB;SAAA;QACnC;YAAC,WAAaO;YAAAA,wOAAAA,EAAe;SAAA;QAC7B;YAAC,OAASA;oOAAAA,gBAAAA,EAAe;SAAA;KAC1B,CAAA;AACH;AAEO,SAAS,YAAsC,GAAA;IACpD,4NAAON,eAAAA,AAAa,EAAA,cAAA,EAAkB,EAAA,cAAA,EAAgB,CAAA;AACxD;AClCY,IAAA,SAAA,GAAA,aAAA,GAAA,CAAA,CAAAO,UAAL,KAAA;IACLA,UAAA,CAAA,UAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;IACAA,UAAA,CAAA,UAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;IACAA,UAAA,CAAA,UAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;IAHUA,OAAAA,UAAAA;AAAA,CAAA,EAAA,SAAA,IAAA,CAAA,CAAA;AAQL,SAAS,mBAA8C,GAAA;IAC5D,0OAAO,iBAAA,EAAe,SAAS,CAAA;AACjC;AAEO,SAAS,mBAA0C,GAAA;IACxD,QAAO,mPAAA,EAAe,SAAS,CAAA;AACjC;AAEO,SAAS,iBAAqD,GAAA;IACnE,4NAAOP,eAAAA,AAAa,EAAA,mBAAA,EAAuB,EAAA,mBAAA,EAAqB,CAAA;AAClE;;ACzBO,IAAM,8BACX,GAAA;AAEU,IAAA,oBAAA,GAAA,aAAA,GAAA,CAAA,CAAAQ,qBAAL,KAAA;IACLA,qBAAA,CAAA,qBAAA,CAAA,2BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,2BAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,wBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,wBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,sBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,sBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,eAAA,CAAA,GAAA,CAAA,CAAA,GAAA,eAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,iBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,iBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,iBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,iBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,iBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,iBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,aAAA,CAAA,GAAA,EAAA,CAAA,GAAA,aAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,mBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,mBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,mBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,mBAAA;IACAA,qBAAA,CAAA,qBAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA;IAdUA,OAAAA,qBAAAA;AAAA,CAAA,EAAA,oBAAA,IAAA,CAAA,CAAA;AAiBA,IAAA,wBAAA,GAAA,aAAA,GAAA,CAAA,CAAAC,yBAAL,KAAA;IACLA,yBAAA,CAAA,yBAAA,CAAA,uBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,uBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,uBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,uBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,+BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,+BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,2DAAA,CAAA,GAAA,CAAA,CAAA,GAAA,2DAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,mCAAA,CAAA,GAAA,CAAA,CAAA,GAAA,mCAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,8BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,8BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,iCAAA,CAAA,GAAA,CAAA,CAAA,GAAA,iCAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,sCAAA,CAAA,GAAA,CAAA,CAAA,GAAA,sCAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,8BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,8BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,qBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,qBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,yCAAA,CAAA,GAAA,EAAA,CAAA,GAAA,yCAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,4BAAA,CAAA,GAAA,EAAA,CAAA,GAAA,4BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,8CAAA,CAAA,GAAA,EAAA,CAAA,GAAA,8CAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,cAAA,CAAA,GAAA,EAAA,CAAA,GAAA,cAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,yBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,yBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,yBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,yBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,uBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,uBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,kBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,kBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,SAAA,CAAA,GAAA,EAAA,CAAA,GAAA,SAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,qBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,qBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,4BAAA,CAAA,GAAA,EAAA,CAAA,GAAA,4BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,2BAAA,CAAA,GAAA,EAAA,CAAA,GAAA,2BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,wBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,wBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,wBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,wBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,sBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,sBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,2BAAA,CAAA,GAAA,EAAA,CAAA,GAAA,2BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,SAAA,CAAA,GAAA,EAAA,CAAA,GAAA,SAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,2BAAA,CAAA,GAAA,EAAA,CAAA,GAAA,2BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,6BAAA,CAAA,GAAA,EAAA,CAAA,GAAA,6BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,iCAAA,CAAA,GAAA,EAAA,CAAA,GAAA,iCAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,yBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,yBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,mBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,mBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,kBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,kBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,4BAAA,CAAA,GAAA,EAAA,CAAA,GAAA,4BAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,gBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,gBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,qBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,qBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,oBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,oBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,qBAAA,CAAA,GAAA,EAAA,CAAA,GAAA,qBAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,UAAA,CAAA,GAAA,EAAA,CAAA,GAAA,UAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,MAAA,CAAA,GAAA,EAAA,CAAA,GAAA,MAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,SAAA,CAAA,GAAA,EAAA,CAAA,GAAA,SAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,UAAA,CAAA,GAAA,EAAA,CAAA,GAAA,UAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,KAAA,CAAA,GAAA,EAAA,CAAA,GAAA,KAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,UAAA,CAAA,GAAA,EAAA,CAAA,GAAA,UAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,SAAA,CAAA,GAAA,EAAA,CAAA,GAAA,SAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,OAAA,CAAA,GAAA,EAAA,CAAA,GAAA,OAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,QAAA;IACAA,yBAAA,CAAA,yBAAA,CAAA,eAAA,CAAA,GAAA,EAAA,CAAA,GAAA,eAAA;IA1DUA,OAAAA,yBAAAA;AAAA,CAAA,EAAA,wBAAA,IAAA,CAAA,CAAA;ACCL,SAAS,cACd,KACY,EAAA;IACZ,IAAI,CAAC,KAAO,EAAA;QACJ,MAAA,IAAI,MAAM,qBAAqB,CAAA;IAAA;IAEvC,IAAI,OAAO,KAAA,KAAU,QAAY,IAAA,SAAA,IAAa,KAAO,EAAA;QACnD,OAAO,KAAM,CAAA,OAAA;IAAA;IAEX,IAAA,KAAA,CAAM,OAAQ,CAAA,KAAK,CAAG,EAAA;QACxB,OAAO,KAAA,CAAM,CAAC,CAAA;IAAA;IAET,OAAA,KAAA;AACT;AAwDO,SAAS,qBAAA,CAAsB,cAAA,EAAyB,uBAAkD,EAAA;IAC/G,OAAO,CAAC,OAA4E,KAAA;QAC9E,IAAA,CAAC,QAAQ,KAAO,EAAA;YAClB,IAAI,4BAA4B,SAAW,EAAA;YAC3C,OAAO,OAAO,MAAO,CAAA;gBACnB,OAAS,EAAA,cAAA;gBACT,kNAAM,cAAY,CAAA,QAAA;YAAA,CACnB,CAAA;QAAA;QAGH,MAAM,YAAe,GAAA,OAAA,CAAQ,UAAa,+MAAA,cAAA,CAAY,QAAA,GAAW,0NAAY,CAAA,QAAA;QAC7E,OAAO,OAAO,MAAO,CAAA;YACnB,OAAA,EAAS,aAAc,CAAA,OAAA,CAAQ,KAAK,CAAA;YACpC,MAAM,mBAAoB,CAAA,OAAA,CAAQ,KAAK,CAAI,mNAAA,sBAAA,EAAoB,YAAY,CAAI,GAAA,YAAA;YAC/E,GAAI,mBAAoB,CAAA,OAAA,CAAQ,KAAK,CAAA,GAAI;gBAAE,MAAQ,EAAA,OAAA,CAAQ,KAAM;YAAA,CAAA,GAAI,CAAA,CAAA;QAAC,CACvE,CAAA;IAAA,CACH;AACF;AAEO,SAAS,oBACd,KACsC,EAAA;IAC/B,OAAA,CAAC,CAAC,KAAS,IAAA,OAAO,UAAU,QAAY,IAAA,SAAA,IAAa,KAAS,IAAAC,iOAAAA,AAAA,EAA0B,KAAK,CAAA;AACtG;;ACtEO,IAAM,wCAA2C,GAAA;AAEjD,SAAS,4CAAmE,GAAA;IAC1EC,+NAAAA,eAAAA,EAAe,EAAA,MAAA,CAAO,wCAAwC,CAAA;AACvE;AA8CO,SAAS,gDAAwG,GAAA;IAC/G,4NAAA,mBAAA,qOACLb,mBAAAA,AAAiB,EAAA;QACf;YAAC,eAAiBa;YAAAA,uOAAAA,EAAc;SAAA;QAChC;YAAC,MAAQ;YAAA,gBAAA,EAAkB;SAAA;QAC3B;YAAC,WAAaT;+OAAAA,oBAAAA,EAAmB;SAAA;QACjC;YAAC,mBAAA;oLAAqBU,mBAAAA,AAAiB,EAAA,2BAAA,EAA6B,CAAC;SAAA;KACtE,CAAA,EACD,CAAC,KAAW,GAAA,CAAA;YACV,GAAG,KAAA;YACH,aAAe,EAAA;QAAA,CACjB;AAEJ;AAEO,SAAS,gDAAoG,GAAA;IAClH,0OAAOb,mBAAAA,AAAiB,EAAA;QACtB;YAAC,eAAiBc;oOAAAA,eAAAA,EAAc;SAAA;QAChC;YAAC,MAAQ;YAAA,gBAAA,EAAkB;SAAA;QAC3B;YAAC,WAAaT;+OAAAA,oBAAAA,EAAmB;SAAA;QACjC;YAAC,mBAAA;oLAAqBU,mBAAAA,AAAiB,EAAA,2BAAA,EAA6B,CAAC;SAAA;KACtE,CAAA;AACH;AAEO,SAAS,8CAGd,GAAA;IACOd,4NAAAA,eAAAA,EACL,gDAAiD,EAAA,EACjD,gDAAiD;AAErD;AA8BO,SAAS,qCAAA,CAUd,KAAA,EASA,MAYA,EAAA;QAEuB;IAAjB,MAAA,cAAA,oFAAyB,cAAkB,2EAAA,8BAAA;yBAKhC,+FAQA;IAVjB,MAAM,gBAAmB,GAAA;QACvB,UAAU;YAAE,KAAA,2BAAa,QAAY,2CAAlB,kBAAkB,IAAA;YAAM,YAAY,IAAK;QAAA,CAAA;QAC5D,MAAM;YAAE,KAAA,uBAAa,IAAQ,qDAAA,IAAA;YAAM,YAAY,KAAM;QAAA,CAAA;QACrD,eAAe;YAAE,KAAA,EAAO,8BAAM,aAAiB,uEAAA,IAAA;YAAM,YAAY,KAAM;QAAA,CAAA;QACvE,OAAO;YAAE,KAAA,wBAAa,KAAS,wCAAf,eAAe,IAAA;YAAM,YAAY,IAAK;QAAA,CAAA;QACtD,eAAiB,EAAA;YACf,KAAA,kCAAa,eAAmB,kDAAzB,yBAAyB,IAAA;YAChC,UAAY,EAAA;QAAA,CACd;QACA,eAAe;YAAE,KAAA,gCAAa,aAAiB,gDAAvB,uBAAuB,IAAA;YAAM,YAAY,KAAM;QAAA,CAAA;QACvE,MAAM;YAAE,KAAA,uBAAa,IAAQ,qDAAA,IAAA;YAAM,YAAY,KAAM;QAAA;IAAA,CACvD;IACA,MAAM,QAAW,GAAA,gBAAA;IAGX,MAAA,IAAA,GAAO;QAAE,GAAG,KAAM;IAAA,CAAA;IAGpB,IAAA,CAAC,QAAS,CAAA,aAAA,CAAc,KAAO,EAAA;QACjC,QAAA,CAAS,aAAA,CAAc,KAAQ,GAAA,kCAAA;IAAA;IAG3B,MAAA,cAAA,GAAiB,qBAAsB,CAAA,cAAA,EAAgB,SAAS,CAAA;IACtE,MAAM,WAAc,GAAA;QAClB,QAAU,EAAA;YACR,cAAA,CAAe,SAAS,QAAQ,CAAA;YAChC,cAAA,CAAe,SAAS,IAAI,CAAA;YAC5B,cAAA,CAAe,SAAS,aAAa,CAAA;YACrC,cAAA,CAAe,SAAS,KAAK,CAAA;YAC7B,cAAA,CAAe,SAAS,eAAe,CAAA;YACvC,cAAA,CAAe,SAAS,aAAa,CAAA;YACrC,cAAA,CAAe,SAAS,IAAI;SAC5B,CAAA,MAAA,CAAO,CAAI,CAAA,GAA6B,MAAM,KAAS,CAAA,CAAA;QACzD,cAAA;QACA,IAAM,EAAA,gDAAA,EAAmD,CAAA,MAAA,CAAO,IAAkD;IAAA,CACpH;IAaO,OAAA,WAAA;AACT;AA0BO,SAAS,wCAId,WACmE,EAAA;IAC/D,IAAA,WAAA,CAAY,QAAS,CAAA,MAAA,GAAS,CAAG,EAAA;QAE7B,MAAA,IAAI,MAAM,qBAAqB,CAAA;IAAA;IAEvC,IAAI,YAAe,GAAA,CAAA;IACnB,MAAM,iBAAiB,MAAM;QACrB,MAAA,WAAA,GAAc,WAAY,CAAA,QAAA,CAAU,YAAY,CAAA;QACtC,YAAA,IAAA,CAAA;QACT,OAAA,WAAA;IAAA,CACT;IACI,IAAA,yBAAA,GAA4B,WAAY,CAAA,QAAA,CAAS,MAAS,GAAA,CAAA;IAC9D,MAAM,yBAAyB,MAAM;QAC/B,IAAA,yBAAA,KAA8B,GAAU,OAAA,KAAA,CAAA;QACf,yBAAA,IAAA,CAAA;QAC7B,OAAO,cAAe,EAAA;IAAA,CACxB;IACO,OAAA;QACL,gBAAgB,WAAY,CAAA,cAAA;QAC5B,QAAU,EAAA;YACR,UAAU,cAAe,EAAA;YACzB,MAAM,cAAe,EAAA;YACrB,eAAe,cAAe,EAAA;YAC9B,OAAO,cAAe,EAAA;YACtB,iBAAiB,cAAe,EAAA;YAChC,eAAe,cAAe,EAAA;YAC9B,MAAM,sBAAuB;QAAA,CAC/B;QACA,IAAM,EAAA,gDAAA,EAAmD,CAAA,MAAA,CAAO,YAAY,IAAI;IAAA,CAClF;AACF;AC9SA,eAAsB,wBAAwB,IAAiD,EAAA;IAC7F,OAAA,CACE,mNAAM,2BAAA,AAAyB,EAAA;QAC7B,cAAgB,EAAA,8BAAA;QAChB,KAAO,EAAA;oLACL,CAAO,IAAA,CAAK,UAAU,CAAA;wNACtBC,qBAAAA,EAAoB,EAAA,MAAA,CAAO,8BAA8B,CAAA;yNACzDA,oBAAAA,AAAkB,EAAA,EAAE,MAAO,mKAAA,iBAAA,EAAe,IAAI,CAAC;SAAA;IACjD,CACD,CAAA,CAAA,CACD,CAAC,CAAA;AACL;ACyDO,SAAS,2BAA2B,IAAsD,EAAA;IAC1F,IAAA,CAAA,YAAA,GAAe,0BAA2B,CAAA,IAAA,CAAK,YAAY,CAAA;IAC3D,IAAA,CAAA,QAAA,qKAAW,2BAAA,AAAyB,EAAA,IAAA,CAAK,QAAQ,CAAA;IAEtD,IAAI,IAAK,CAAA,QAAA,IAAY,IAAM,EAAA,IAAA,CAAK,QAAW,GAAA,CAAA;IAC3C,IAAI,CAAC,IAAA,CAAK,aAAe,EAAA,IAAA,CAAK,aAAA,GAAgB,IAAK,CAAA,QAAA;IACnD,IAAI,CAAC,IAAA,CAAK,eAAiB,EAAA,IAAA,CAAK,eAAA,GAAkB,IAAK,CAAA,QAAA;IACvD,IAAI,KAAK,eAAiB,EAAA,IAAA,CAAK,eAAkB,qKAAA,iBAAA,EAAe,KAAK,eAAe,CAAA;IAEhF,IAAA,IAAA,CAAK,YAAA,sLAAiBc,6BAA4B,EAAA;QAC9C,MAAA,eAAA,uLAAkB,aAAA,EAAU,iBAAmB,EAAA;YACnD,eAAA,EAAiB,KAAK,IAAK,CAAA,OAAA;YAC3B,SAAA,EAAW,KAAK,eAAgB,CAAA,OAAA;QAAA,CACjC,CAAA;QAEK,MAAA,qBAAA,wLAAwB,YAAA,EAAU,eAAiB,EAAA;YACvD,eAAA,EAAiB,KAAK,eAAgB,CAAA,OAAA;YACtC,IAAA,EAAM,KAAK,IAAK,CAAA,OAAA;YAChB,IAAA,EAAM,KAAK,QAAS,CAAA,IAAA;YACpB,MAAA,EAAQ,KAAK,QAAS,CAAA,MAAA;YACtB,GAAA,EAAK,KAAK,QAAS,CAAA,GAAA;YAAA,4CAAA;YAEnB,kBAAA,EAAA,aAAA,GAAA,IAAwB,GAAI;QAAA,CAC7B,CAAA;QAEM,OAAA;0LACL,8BAAA,AAA4B,EAAA;gBAC1B,OAAO,IAAK,CAAA,QAAA;gBACZ,YAAY,IAAK,CAAA,IAAA;gBAAA;;;WAAA,GAKjB,OAAO,MAAO,sLAAA,cAAA,EAAY;oBAAC,eAAe;iBAAC,CAAC,CAAA;gBAAA;;;SAAA,GAK5C,QAAA,MAAU,kMAAA,EAAkC,MAAO,sLAAA,cAAA,EAAY;oBAAC,eAAiB;oBAAA,qBAAqB;iBAAC,CAAC,CAAC,CAAA;gBACzG,gBAAgB,IAAK,CAAA,YAAA;YAAA,CACtB,CAAA;gBACD,2NAAA,AAAwC,EAAA;gBACtC,SAAA,EAAW,KAAK,aAAc,CAAA,OAAA;gBAC9B,iBAAiB,IAAK,CAAA,eAAA;gBACtB,IAAA,EAAM,KAAK,IAAK,CAAA,OAAA;YAAA,CACjB,CAAA;aACD,mNAAA,EACE;gBACE,IAAA,EAAM,KAAK,IAAK,CAAA,OAAA;gBAChB,QAAA,EAAU,MAAO,CAAA,IAAA,CAAK,QAAQ,CAAA;gBAC9B,aAAA,EAAe,KAAK,aAAc,CAAA,OAAA;gBAClC,eAAA,EAAiB,KAAK,eAAmB,IAAA;YAAA,CAC3C,EACA;gBACE,gBAAgB,IAAK,CAAA,YAAA;YAAA;iMAGzB,wCAAA,AAAsC,EAAA;gBACpC,QAAA,EAAU,KAAK,IAAK,CAAA,OAAA;gBACpB,IAAA,EAAM,KAAK,IAAK,CAAA,OAAA;gBAChB,eAAe,IAAK,CAAA,aAAA;gBACpB,IAAA,EAAM,KAAK,QAAS,CAAA,IAAA;gBACpB,MAAA,EAAQ,KAAK,QAAS,CAAA,MAAA;gBACtB,GAAA,EAAK,KAAK,QAAS,CAAA,GAAA;gBACnB,eAAA,EAAiB,KAAK,eAAgB,CAAA,OAAA;YAAA,CACvC;SAEH;IAAA,CACK,MAAA;QAEC,MAAA,KAAA,GAAgB,MAAO,qLAAA,eAAA,EAAa,CAAA;QAEnC,OAAA;0LACL,8BAAA,AAA4B,EAAA;gBAC1B,OAAO,IAAK,CAAA,QAAA;gBACZ,YAAY,IAAK,CAAA,IAAA;gBACjB,QAAA,oKAAU,oCAAA,EAAkC,KAAK,CAAA;gBACjD,KAAA;gBACA,gBAAgB,IAAK,CAAA,YAAA;YAAA,CACtB,CAAA;iMACD,+BAAA,EACE;gBACE,IAAA,EAAM,KAAK,IAAK,CAAA,OAAA;gBAChB,QAAA,EAAU,MAAO,CAAA,IAAA,CAAK,QAAQ,CAAA;gBAC9B,aAAA,EAAe,KAAK,aAAc,CAAA,OAAA;gBAClC,eAAA,EAAiB,KAAK,eAAmB,IAAA;YAAA,CAC3C,EACA;gBACE,gBAAgB,IAAK,CAAA,YAAA;YAAA;YAGzB,qCAAsC,CAAA;gBACpC,UAAU,IAAK,CAAA,eAAA;gBACf,IAAA,EAAM,KAAK,IAAK,CAAA,OAAA;gBAChB,eAAe,IAAK,CAAA,aAAA;gBACpB,OAAO,IAAK,CAAA,QAAA;gBACZ,iBAAiB,IAAK,CAAA,eAAA;gBACtB,IAAM,EAAA;oBACJ,IAAA,EAAM,KAAK,QAAS,CAAA,IAAA;oBACpB,MAAA,EAAQ,KAAK,QAAS,CAAA,MAAA;oBACtB,GAAA,EAAK,KAAK,QAAS,CAAA,GAAA;oBACnB,oBAAsB,EAAA,CAAA;oBACtB,QAAU,EAAA,IAAA;oBACV,UAAY,EAAA,IAAA;oBACZ,IAAM,EAAA;gBAAA,CACR;gBACA,SAAA,EAAW,KAAK,QAAS,CAAA,SAAA;gBACzB,iBAAmB,EAAA;YAAA,CACpB;SACH;IAAA;AAEJ;ACnIO,SAAS,0BAA0B,IAAqD,EAAA;IACxF,IAAA,CAAA,YAAA,GAAe,0BAA2B,CAAA,IAAA,CAAK,YAAY,CAAA;IAC3D,IAAA,CAAA,QAAA,IAAW,4LAAA,AAAyB,EAAA,IAAA,CAAK,QAAQ,CAAA;IACjD,IAAA,CAAA,IAAA,qKAAO,iBAAA,AAAe,EAAA,IAAA,CAAK,IAAI,CAAA;IAE7B,OAAA;QAAA,+FAAA;6LAEL,gDAA8C,AAA9C,EAA8C;YAC5C,KAAA,oKAAO,iBAAA,AAAe,EAAA,IAAA,CAAK,WAAW,CAAA;YACtC,MAAM,IAAK,CAAA,IAAA;YACX,KAAK,IAAK,CAAA,GAAA;YACV,OAAO,IAAK,CAAA,QAAA;YACZ,cAAc,IAAK,CAAA,YAAA;QAAA,CACpB,CAAA;QACD,4MAAA,EACE;YACE,MAAM,IAAK,CAAA,IAAA;YACX,eAAe,IAAK,CAAA,aAAA;YACpB,OAAO,IAAK,CAAA,GAAA;YACZ,QAAQ,IAAK,CAAA,MAAA;QAAA,CACf,EACA;YACE,gBAAgB,IAAK,CAAA,YAAA;QAAA;KAG3B;AACF;ACjBO,SAAS,8BAA8B,IAAyD,EAAA;IAChG,IAAA,CAAA,YAAA,GAAe,0BAA2B,CAAA,IAAA,CAAK,YAAY,CAAA;IAC3D,IAAA,CAAA,QAAA,qKAAW,2BAAA,AAAyB,EAAA,IAAA,CAAK,QAAQ,CAAA;IACjD,IAAA,CAAA,IAAA,IAAO,kLAAA,AAAe,EAAA,IAAA,CAAK,IAAI,CAAA;IAE7B,OAAA;QAAA,+FAAA;6LAELC,gDAAAA,AAA8C,EAAA;YAC5C,KAAA,EAAO,mLAAA,AAAe,EAAA,IAAA,CAAK,WAAW,CAAA;YACtC,MAAM,IAAK,CAAA,IAAA;YACX,KAAK,IAAK,CAAA,cAAA;YACV,OAAO,IAAK,CAAA,QAAA;YACZ,cAAc,IAAK,CAAA,YAAA;QAAA,CACpB,CAAA;6LACD,yBAAA,EACE;YACE,WAAW,IAAK,CAAA,SAAA;YAChB,QAAQ,IAAK,CAAA,SAAA;YACb,aAAa,IAAK,CAAA,cAAA;YAClB,QAAQ,IAAK,CAAA,MAAA;QAAA,CACf,EACA;YACE,gBAAgB,IAAK,CAAA,YAAA;QAAA;KAG3B;AACF;AC7BA,eAAsB,4BAIpB,IAA0G,EAAA;IACrG,IAAA,CAAA,YAAA,GAAe,0BAA2B,CAAA,IAAA,CAAK,YAAY,CAAA;IAC3D,IAAA,CAAA,QAAA,qKAAW,2BAAA,AAAyB,EAAA,IAAA,CAAK,QAAQ,CAAA;IAElD,IAAA,eAAA,GAAkB,KAAK,IAAK,CAAA,OAAA;IAE5B,IAAA,IAAA,CAAK,YAAA,KAAiB,qBAAuB,EAAA;QAC7B,eAAA,GAAA,MAAM,uBAAwB,CAAA,IAAA,CAAK,IAAI,CAAA;QAGrD,IAAA,CAAC,KAAK,gBAAkB,EAAA;YAG1B,IAAA,CAAK,gBAAmB,GAAA,GAAA;QAAA;IAC1B,CACF,MAAA,IAAW,IAAK,CAAA,YAAA,KAAiBD,8MAA4B,EAAA;QACvD,IAAA,CAAC,KAAK,gBAAkB,EAAA;YAG1B,IAAA,CAAK,gBAAmB,GAAA,GAAA;QAAA;IAC1B;IAGK,yKAAA,oBAAA,EAAA,CACJ;YAAC,EAAE,QAAA,EAAU,OAAA,EAAS,gBAAkB,EAAA,gBAAA,EAAkB,eAAA,EAAoC;eAAA;YAC7F,QAAA;YACA,SAAS,OAAW,IAAA,QAAA;YACpB,gBAAA;YACA,gBAAA;YACA,eAAA;YACA,YAAc,EAAA,0BAAA,CAAA,CACX;oBAAC,EACA,QAAA,EACA,aAAA,EACA,eAAA,EACA,eAAA,EACA,QAAA,EACA,QAAAE,EAAAA,SAAAA,EACA,YAAA,EACA,IAAA,EACkB;uBAAA;oBAClB,IAAA;oBACA,QAAAA,EAAAA,SAAAA;oBACA,eAAA;oBACA,QAAA;oBACA,QAAA;oBACA,aAAA;oBACA,eAAA;oBACA,eAAA;oBACA;gBAAA;aAAA,EACE,IAAI;QACV;KAAA,EACE,IAAI;AAEZ;;ACxDA,eAAsB,2BAIpB,IAA0G,EAAA;IACrG,IAAA,CAAA,YAAA,GAAe,0BAA2B,CAAA,IAAA,CAAK,YAAY,CAAA;IAC3D,IAAA,CAAA,QAAA,qKAAW,2BAAA,AAAyB,EAAA,IAAA,CAAK,QAAQ,CAAA;IACjD,IAAA,CAAA,IAAA,IAAO,kLAAA,AAAe,EAAA,IAAA,CAAK,IAAI,CAAA;IAEhC,IAAA,CAAC,KAAK,GAAK,EAAA;QACR,IAAA,CAAA,GAAA,GAAM,MAAM,gCAAiC,CAAA,IAAA,CAAK,IAAA,EAAM,IAAK,CAAA,WAAA,EAAa,KAAK,YAAY,CAAA;IAAA;IAI9F,IAAA,CAAC,KAAK,gBAAkB,EAAA;QAY1B,IAAA,CAAK,gBAAmB,GAAA,IAAA;IAAA;IAGnB,yKAAA,oBAAA,EAAA,CACJ;YAAC,EAAE,QAAA,EAAU,OAAA,EAAS,gBAAkB,EAAA,gBAAA,EAAkB,eAAA,EAAoC;eAAA;YAC7F,QAAA;YACA,SAAS,OAAW,IAAA,QAAA;YACpB,gBAAA;YACA,gBAAA;YACA,eAAA;YACA,YAAc,EAAA,yBAAA,CACX,CAAA;oBAAC,EAAE,YAAA,EAAc,QAAAA,EAAAA,SAAAA,EAAU,IAAA,EAAM,GAAK,EAAA,aAAA,EAAe,MAAQ,EAAA,WAAA,EAAgC;uBAAA;oBAC5F,YAAA;oBACA,QAAAA,EAAAA,SAAAA;oBACA,IAAA;oBACA,aAAA;oBACA,GAAA;oBACA,MAAA;oBACA;gBAAA;aAAA,EACE,IAAI;QACV;KAAA,EACE,IAAI;AAEZ;;AC/CA,eAAsB,+BAIpB,IAA6G,EAAA;IACxG,IAAA,CAAA,YAAA,GAAe,0BAA2B,CAAA,IAAA,CAAK,YAAY,CAAA;IAC3D,IAAA,CAAA,QAAA,qKAAW,2BAAA,AAAyB,EAAA,IAAA,CAAK,QAAQ,CAAA;IACjD,IAAA,CAAA,IAAA,GAAO,mLAAe,AAAf,EAAe,IAAA,CAAK,IAAI,CAAA;IAEpC,CAAC,KAAK,cAAgB,EAAA,IAAA,CAAK,SAAS,CAAI,GAAA,MAAM,QAAQ,GAAI,CAAA;QACxD,CAAC,IAAK,CAAA,cAAA,GACF,gCAAiC,CAAA,IAAA,CAAK,IAAM,EAAA,IAAA,CAAK,WAAa,EAAA,IAAA,CAAK,YAAY,CAAA,GAC/E,IAAK,CAAA,cAAA;QACT,CAAC,IAAK,CAAA,SAAA,GAAY,gCAAiC,CAAA,IAAA,CAAK,IAAM,EAAA,IAAA,CAAK,SAAW,EAAA,IAAA,CAAK,YAAY,CAAA,GAAI,IAAK,CAAA,SAAA;KACzG,CAAA;IAGG,IAAA,CAAC,KAAK,gBAAkB,EAAA;QAY1B,IAAA,CAAK,gBAAmB,GAAA,IAAA;IAAA;IAGnB,QAAA,qLAAA,EAAA,CACJ;YAAC,EAAE,QAAA,EAAU,OAAA,EAAS,gBAAkB,EAAA,gBAAA,EAAkB,eAAA,EAAoC;eAAA;YAC7F,QAAA;YACA,SAAS,OAAW,IAAA,QAAA;YACpB,gBAAA;YACA,gBAAA;YACA,eAAA;YACA,YAAc,EAAA,6BAAA,CAAA,CACX;oBAAC,EACA,YAAA,EACA,QAAAA,EAAAA,SAAAA,EACA,IAAA,EACA,MAAA,EACA,WAAA,EACA,SAAA,EACA,cAAA,EACA,SAAA,EACkB;uBAAA;oBAClB,YAAA;oBACA,QAAAA,EAAAA,SAAAA;oBACA,IAAA;oBACA,MAAA;oBACA,SAAA;oBACA,WAAA;oBACA,SAAA;oBACA;gBAAA;aAAA,EACE,IAAI;QACV;KAAA,EACE,IAAI;AAEZ;;AC3HO,SAAS,qBAAA,CAAsB,QAAA,EAAkB,QAA0B,EAAA;IAG1E,MAAA,WAAA,GAAc,QAAS,CAAA,OAAA,CAAQ,QAAQ,CAAA;IAGvC,MAAA,iBAAA,GAAoB,WAAY,CAAA,OAAA,CAAQ,GAAG,CAAA;IAE7C,IAAA,WAAA;IACA,IAAA,cAAA;IAEJ,IAAI,sBAAsB,CAAI,CAAA,EAAA;QAEd,WAAA,GAAA,WAAA;QACG,cAAA,GAAA,EAAA;IAAA,CACZ,MAAA;QACS,WAAA,GAAA,WAAA,CAAY,SAAU,CAAA,CAAA,EAAG,iBAAiB,CAAA;QACvC,cAAA,GAAA,WAAA,CAAY,SAAU,CAAA,iBAAA,GAAoB,CAAC,CAAA;IAAA;IAI1D,IAAA,cAAA,CAAe,MAAA,GAAS,QAAU,EAAA;QACnB,cAAA,GAAA,cAAA,CAAe,SAAU,CAAA,CAAA,EAAG,QAAQ,CAAA;IAAA,CAChD,MAAA;QACY,cAAA,GAAA,cAAA,CAAe,MAAO,CAAA,QAAA,EAAU,GAAG,CAAA;IAAA;IAItD,MAAM,eAAe,WAAc,GAAA,cAAA;IACnC,IAAI,YAAa,CAAA,OAAA,CAAQ,IAAM,EAAA,EAAE,MAAM,EAAI,EAAA;QACzC,OAAO,OAAO,CAAC,CAAA;IAAA;IAEjB,OAAO,OAAO,YAAY,CAAA;AAC5B;AAQO,SAAS,qBAAA,CAAsB,MAAA,EAAgB,QAA0B,EAAA;IAE1E,IAAA,SAAA,GAAY,OAAO,QAAS,EAAA;IAG5B,IAAA,SAAA,CAAU,MAAA,IAAU,QAAU,EAAA;QAChC,SAAA,GAAY,SAAU,CAAA,QAAA,CAAS,QAAW,GAAA,CAAA,EAAG,GAAG,CAAA;IAAA;IAI5C,MAAA,eAAA,GAAkB,UAAU,MAAS,GAAA,QAAA;IAC3C,MAAM,SAAY,GAAA,SAAA,CAAU,SAAU,CAAA,CAAA,EAAG,eAAe,CAAA;IAClD,MAAA,cAAA,GAAiB,SAAU,CAAA,SAAA,CAAU,eAAe,CAAA;IAG1D,MAAM,WAAc,GAAA,UAAG,SAAa,IAAA,GAAG,EAAA,KAAkB,CAAA,MAAd,cAAc;IAGzD,OAAO,WAAW,WAAW,CAAA;AAC/B","debugId":null}}]
}