{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/kit/node_modules/@solana/transaction-messages/dist/index.browser.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/blockhash.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/codecs/address-table-lookup.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/codecs/header.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/codecs/instruction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/codecs/transaction-version.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/codecs/message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compile/accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compile/address-table-lookups.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compile/header.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compile/instructions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compile/lifetime-token.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compile/static-accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compile/message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/compress-transaction-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/create-transaction-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/durable-nonce-instruction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/durable-nonce.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/fee-payer.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/instructions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/decompile-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/kit/node_modules/%40solana/transaction-messages/src/deprecated.ts"],"sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithLifetime>,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    transformDecoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n        memoizedAddressTableLookupDecoder = transformDecoder(\n            getStructDecoder([\n                ['lookupTableAddress', getAddressDecoder()],\n                ['writableIndexes', indexEncoder],\n                ['readonlyIndexes', indexEncoder],\n            ]),\n            lookupTable =>\n                'readableIndices' in lookupTable\n                    ? ({\n                          ...lookupTable,\n                          readonlyIndexes: lookupTable.readableIndices,\n                          // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n                          writableIndexes: lookupTable.writableIndices,\n                      } as AddressTableLookup)\n                    : lookupTable,\n        );\n    }\n\n    // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledTransactionMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledTransactionMessage>,\n        (value: CompiledTransactionMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledTransactionMessage, { readonly version: 'legacy' }>;\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', fixEncoderSize(getBase58Encoder(), 32)],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledTransactionMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<CompiledTransactionMessage> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledTransactionMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<CompiledTransactionMessage> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** @deprecated Use `readonlyIndexes` */\n    readableIndices: readonly number[];\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n    /** @deprecated Use `writableIndexes` */\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            /** @deprecated Remove in a future major version */\n            readableIndices: [],\n            readonlyIndexes: [],\n            writableIndexes: [],\n            /** @deprecated Remove in a future major version */\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n            /** @deprecated Remove in a future major version */\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            /** @deprecated Remove in a future major version */\n            entry.readableIndices.push(account.addressIndex);\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { CompilableTransactionMessage } from '../compilable-transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): VersionedCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): CompiledTransactionMessage {\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transactionMessage.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { compressTransactionMessageUsingAddressLookupTables } from '@solana/transaction-messages';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const accountAddress = address('5n2ADjHPsqB4EVUNEX48xRqtnmuLu5XSHDwkJRR98qpM');\n * const lookupTableAddresses: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: [accountAddress],\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     lookupTableAddresses,\n * );\n * ```\n *\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const lookupTableAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap(a => a));\n\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !lookupTableAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transactions';\n *\n * const NONCE_VALUE_OFFSET =\n *     4 + // version(u32)\n *     4 + // state(u32)\n *     32; // nonce authority(pubkey)\n * // Then comes the nonce value.\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n * const { value: nonceAccount } = await rpc\n *     .getAccountInfo(nonceAccountAddress, {\n *         dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n *         encoding: 'base58',\n *     })\n *     .send();\n * const nonce =\n *     // This works because we asked for the exact slice of data representing the nonce\n *     // value, and furthermore asked for it in `base58` encoding.\n *     nonceAccount!.data[0] as unknown as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Omit<\n    // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? TTransactionMessage\n        : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n    // 2. Remove the instructions array as we are going to replace it with a new one.\n    'instructions'\n> & {\n    // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n    readonly instructions: TTransactionMessage['instructions'] extends readonly [\n        AdvanceNonceAccountInstruction,\n        ...infer TTail extends readonly Instruction[],\n    ]\n        ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n        : readonly [\n              AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n              ...TTransactionMessage['instructions'],\n          ];\n    // 4. Set the lifetime constraint to the nonce value.\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n};\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends BaseTransactionMessage> = Omit<\n    TTransactionMessage,\n    'feePayer'\n>;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as Omit<TTransactionMessage, 'feePayer'> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n    readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n};\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<\n    ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n    'instructions'\n> & {\n    readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n};\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    });\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    });\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransactionMessage } from './compilable-transaction-message';\nimport { CompiledTransactionMessage } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { BaseTransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes =\n            lookup.readonlyIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.readableIndices;\n        const writableIndexes =\n            lookup.writableIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.writableIndices;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    config?: DecompileTransactionMessageConfig,\n): CompilableTransactionMessage {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as BaseTransactionMessage & TransactionMessageWithFeePayer,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n","import type { Address } from '@solana/addresses';\n\nimport {\n    assertIsTransactionMessageWithDurableNonceLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n} from './durable-nonce';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n *\n * @deprecated Use {@link TransactionMessageWithFeePayer} instead. It was only renamed.\n */\nexport interface ITransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @deprecated Use {@link assertIsTransactionMessageWithDurableNonceLifetime} instead. It was only renamed.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport const assertIsDurableNonceTransactionMessage = assertIsTransactionMessageWithDurableNonceLifetime;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @deprecated Use {@link isTransactionMessageWithDurableNonceLifetime} instead. It was only renamed.\n *\n * @example\n * ```ts\n * import { isDurableNonceTransaction } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isDurableNonceTransaction(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport const isDurableNonceTransaction = isTransactionMessageWithDurableNonceLifetime;\n"],"names":["alphabet","SolanaError","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","transformDecoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","AccountRole","getAddressComparator","isWritableRole","isSignerRole"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1104, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transaction-confirmation/node_modules/@solana/transaction-messages/dist/index.browser.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/blockhash.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/codecs/address-table-lookup.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/codecs/header.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/codecs/instruction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/codecs/transaction-version.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/codecs/message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compile/accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compile/address-table-lookups.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compile/header.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compile/instructions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compile/lifetime-token.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compile/static-accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compile/message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/compress-transaction-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/create-transaction-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/durable-nonce-instruction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/durable-nonce.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/fee-payer.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/instructions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/decompile-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-confirmation/node_modules/%40solana/transaction-messages/src/deprecated.ts"],"sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithLifetime>,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    transformDecoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n        memoizedAddressTableLookupDecoder = transformDecoder(\n            getStructDecoder([\n                ['lookupTableAddress', getAddressDecoder()],\n                ['writableIndexes', indexEncoder],\n                ['readonlyIndexes', indexEncoder],\n            ]),\n            lookupTable =>\n                'readableIndices' in lookupTable\n                    ? ({\n                          ...lookupTable,\n                          readonlyIndexes: lookupTable.readableIndices,\n                          // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n                          writableIndexes: lookupTable.writableIndices,\n                      } as AddressTableLookup)\n                    : lookupTable,\n        );\n    }\n\n    // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledTransactionMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledTransactionMessage>,\n        (value: CompiledTransactionMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledTransactionMessage, { readonly version: 'legacy' }>;\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', fixEncoderSize(getBase58Encoder(), 32)],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledTransactionMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<CompiledTransactionMessage> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledTransactionMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<CompiledTransactionMessage> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** @deprecated Use `readonlyIndexes` */\n    readableIndices: readonly number[];\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n    /** @deprecated Use `writableIndexes` */\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            /** @deprecated Remove in a future major version */\n            readableIndices: [],\n            readonlyIndexes: [],\n            writableIndexes: [],\n            /** @deprecated Remove in a future major version */\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n            /** @deprecated Remove in a future major version */\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            /** @deprecated Remove in a future major version */\n            entry.readableIndices.push(account.addressIndex);\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { CompilableTransactionMessage } from '../compilable-transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): VersionedCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): CompiledTransactionMessage {\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transactionMessage.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { compressTransactionMessageUsingAddressLookupTables } from '@solana/transaction-messages';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const accountAddress = address('5n2ADjHPsqB4EVUNEX48xRqtnmuLu5XSHDwkJRR98qpM');\n * const lookupTableAddresses: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: [accountAddress],\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     lookupTableAddresses,\n * );\n * ```\n *\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const lookupTableAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap(a => a));\n\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !lookupTableAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transactions';\n *\n * const NONCE_VALUE_OFFSET =\n *     4 + // version(u32)\n *     4 + // state(u32)\n *     32; // nonce authority(pubkey)\n * // Then comes the nonce value.\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n * const { value: nonceAccount } = await rpc\n *     .getAccountInfo(nonceAccountAddress, {\n *         dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n *         encoding: 'base58',\n *     })\n *     .send();\n * const nonce =\n *     // This works because we asked for the exact slice of data representing the nonce\n *     // value, and furthermore asked for it in `base58` encoding.\n *     nonceAccount!.data[0] as unknown as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Omit<\n    // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? TTransactionMessage\n        : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n    // 2. Remove the instructions array as we are going to replace it with a new one.\n    'instructions'\n> & {\n    // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n    readonly instructions: TTransactionMessage['instructions'] extends readonly [\n        AdvanceNonceAccountInstruction,\n        ...infer TTail extends readonly Instruction[],\n    ]\n        ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n        : readonly [\n              AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n              ...TTransactionMessage['instructions'],\n          ];\n    // 4. Set the lifetime constraint to the nonce value.\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n};\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends BaseTransactionMessage> = Omit<\n    TTransactionMessage,\n    'feePayer'\n>;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as Omit<TTransactionMessage, 'feePayer'> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n    readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n};\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<\n    ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n    'instructions'\n> & {\n    readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n};\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    });\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    });\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransactionMessage } from './compilable-transaction-message';\nimport { CompiledTransactionMessage } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { BaseTransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes =\n            lookup.readonlyIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.readableIndices;\n        const writableIndexes =\n            lookup.writableIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.writableIndices;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    config?: DecompileTransactionMessageConfig,\n): CompilableTransactionMessage {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as BaseTransactionMessage & TransactionMessageWithFeePayer,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n","import type { Address } from '@solana/addresses';\n\nimport {\n    assertIsTransactionMessageWithDurableNonceLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n} from './durable-nonce';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n *\n * @deprecated Use {@link TransactionMessageWithFeePayer} instead. It was only renamed.\n */\nexport interface ITransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @deprecated Use {@link assertIsTransactionMessageWithDurableNonceLifetime} instead. It was only renamed.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport const assertIsDurableNonceTransactionMessage = assertIsTransactionMessageWithDurableNonceLifetime;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @deprecated Use {@link isTransactionMessageWithDurableNonceLifetime} instead. It was only renamed.\n *\n * @example\n * ```ts\n * import { isDurableNonceTransaction } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isDurableNonceTransaction(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport const isDurableNonceTransaction = isTransactionMessageWithDurableNonceLifetime;\n"],"names":["alphabet","SolanaError","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","transformDecoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","AccountRole","getAddressComparator","isWritableRole","isSignerRole"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DO,SAAS,0CACZ,kBACsF,EAAA;IACtF,OACI,oBAAwB,IAAA,kBAAA,IACxB,OAAO,kBAAA,CAAmB,kBAAA,CAAmB,SAAc,KAAA,QAAA,IAC3D,OAAO,kBAAA,CAAmB,kBAAA,CAAmB,oBAAyB,KAAA,QAAA,4OACtE,cAAA,AAAY,EAAA,kBAAA,CAAmB,kBAAA,CAAmB,SAAS,CAAA;AAEnE;AAwBO,SAAS,gDACZ,kBAC8F,EAAA;IAC1F,IAAA,CAAC,yCAA0C,CAAA,kBAAkB,CAAG,EAAA;QAC1D,MAAA,kOAAI,cAAA,+NAAY,yDAAsD,CAAA;IAAA;AAEpF;AAeO,SAAS,2CAAA,CAGZ,2BAAA,EACA,kBACgG,EAAA;IAGhG,IACI,wBAAwB,kBACxB,IAAA,kBAAA,CAAmB,kBACnB,IAAA,WAAA,IAAe,mBAAmB,kBAClC,IAAA,kBAAA,CAAmB,kBAAmB,CAAA,SAAA,KAAc,4BAA4B,SAChF,IAAA,kBAAA,CAAmB,kBAAmB,CAAA,oBAAA,KAAyB,4BAA4B,oBAC7F,EAAA;QACS,OAAA,kBAAA;IAAA;IAGX,OAAO,OAAO,MAAO,CAAA;QACjB,GAAG,kBAAA;QACH,kBAAA,EAAoB,MAAO,CAAA,MAAA,CAAO,2BAA2B;IAAA,CAChE,CAAA;AACL;ACpHO,SAAS,qBAAsBA,CAAAA,SAAAA,EAAkB,SAAmB;qBAAA,UAAA,uDAAa,SAAW,EAAA;IAC3F,IAAA,CAAC,UAAU,KAAM,CAAA,IAAI,OAAO,AAAKA,EAAAA,UAAAA,SAAQ,EAAK,GAAA,CAAA,CAAC,CAAG,IAAA;QAC5C,MAAA,iOAAIC,eAAAA,CAAY,8QAA+C,EAAA;YACjE,QAAAD,EAAAA,SAAAA;YACA,IAAA,EAAMA,SAAS,CAAA,MAAA;YACf,KAAO,EAAA;SACV,CAAA;IAAA;AAET;ACEa,IAAA,eAAA,GAAkB,CAACA,SAAkD,KAAA;IAC9E,iPAAO,gBAAA,AAAc,EAAA;QACjB,gBAAA,EAAkB,CAAC,KAA0B,KAAA;YACnC,MAAA,CAAC,eAAe,SAAS,CAAA,GAAI,uBAAuB,KAAOA,EAAAA,SAAAA,CAAS,CAAC,CAAC,CAAA;YACxE,IAAA,CAAC,SAAW,EAAA,OAAO,KAAM,CAAA,MAAA;YAEvB,MAAA,YAAA,GAAe,kBAAmB,CAAA,SAAA,EAAWA,SAAQ,CAAA;YACpD,OAAA,aAAA,CAAc,MAAA,GAAS,IAAK,CAAA,IAAA,CAAK,aAAa,QAAS,CAAA,EAAE,CAAE,CAAA,MAAA,GAAS,CAAC,CAAA;QAAA,CAAA;QAEhF,KAAM,EAAA,KAAA,EAAe,KAAA,EAAO,MAAQ,EAAA;YAEhC,qBAAA,CAAsBA,WAAU,KAAK,CAAA;YACjC,IAAA,KAAA,KAAU,IAAW,OAAA,MAAA;YAGnB,MAAA,CAAC,eAAe,SAAS,CAAA,GAAI,uBAAuB,KAAOA,EAAAA,SAAAA,CAAS,CAAC,CAAC,CAAA;YAC5E,IAAI,CAAC,SAAW,EAAA;gBACN,KAAA,CAAA,GAAA,CAAI,IAAI,UAAW,CAAA,aAAA,CAAc,MAAM,CAAE,CAAA,IAAA,CAAK,CAAC,CAAA,EAAG,MAAM,CAAA;gBAC9D,OAAO,SAAS,aAAc,CAAA,MAAA;YAAA;YAI9B,IAAA,YAAA,GAAe,kBAAmB,CAAA,SAAA,EAAWA,SAAQ,CAAA;YAGzD,MAAM,YAAsB,EAAA;YAC5B,MAAO,eAAe,EAAI,CAAA;gBACtB,SAAA,CAAU,OAAQ,CAAA,MAAA,CAAO,YAAe,GAAA,IAAI,CAAC,CAAA;gBAC7B,YAAA,IAAA,IAAA;YAAA;YAGd,MAAA,UAAA,GAAa,CAAC;mBAAG,KAAM,CAAA,aAAA,CAAc,MAAM,CAAA,CAAE,IAAK,CAAA,CAAC,CAAG,EAAA;mBAAG,SAAS;aAAA;YAClE,KAAA,CAAA,GAAA,CAAI,YAAY,MAAM,CAAA;YAC5B,OAAO,SAAS,UAAW,CAAA,MAAA;QAAA;KAElC,CAAA;AACL,CAAA;AAuBa,IAAA,eAAA,GAAkB,CAACA,SAAkD,KAAA;IAC9E,iPAAO,gBAAc,AAAd,EAAc;QACjB,IAAA,EAAK,QAAA,EAAU,MAA0B,EAAA;YACrC,MAAM,QAAQ,MAAW,KAAA,CAAA,GAAI,QAAW,GAAA,QAAA,CAAS,KAAA,CAAM,MAAM,CAAA;YAC7D,IAAI,MAAM,MAAW,KAAA,CAAA,EAAU,OAAA;gBAAC;gBAAI,CAAC;aAAA;YAGrC,IAAI,aAAa,KAAM,CAAA,SAAA,CAAU,CAAA,CAAA,GAAK,MAAM,CAAC,CAAA;YAChC,UAAA,GAAA,UAAA,KAAe,CAAA,CAAK,GAAA,KAAA,CAAM,MAAS,GAAA,UAAA;YAChD,MAAM,aAAgBA,GAAAA,SAAAA,CAAS,CAAC,CAAA,CAAE,MAAA,CAAO,UAAU,CAAA;YACnD,IAAI,eAAe,KAAM,CAAA,MAAA,EAAA,OAAe;gBAAC,aAAA;gBAAe,SAAS,MAAM;aAAA;YAGvE,MAAM,YAAe,GAAA,KAAA,CAAM,KAAM,CAAA,UAAU,EAAE,MAAO,CAAA,CAAC,GAAK,EAAA,IAAA,GAAS,GAAM,GAAA,IAAA,GAAO,MAAO,CAAA,IAAI,GAAG,EAAE,CAAA;YAG1F,MAAA,SAAA,GAAY,kBAAmB,CAAA,YAAA,EAAcA,SAAQ,CAAA;YAE3D,OAAO;gBAAC,aAAA,GAAgB,SAAW;gBAAA,QAAA,CAAS,MAAM;aAAA;QAAA;KAEzD,CAAA;AACL,CAAA;AAkDA,SAAS,sBAAA,CACL,KAAA,EACA,aACqD,EAAA;IAC/C,MAAA,CAAC,YAAc,EAAA,SAAS,CAAI,GAAA,KAAA,CAAM,KAAM,CAAA,IAAI,MAAO,CAAA,IAAA,UAAO,aAAa,EAAA,IAAA,CAAM,CAAC,CAAA;IAC7E,OAAA;QAAC;QAAc,SAAS;KAAA;AACnC;AAEA,SAAS,kBAAA,CAAmB,KAAA,EAAeA,SAA0B,EAAA;IAC3D,MAAA,IAAA,GAAO,MAAOA,CAAAA,SAAAA,CAAS,MAAM,CAAA;IACnC,IAAI,GAAM,GAAA,EAAA;IACV,KAAA,MAAW,QAAQ,KAAO,CAAA;QACf,GAAA,IAAA,IAAA;QACP,GAAA,IAAO,MAAOA,CAAAA,SAAAA,CAAS,OAAQ,CAAA,IAAI,CAAC,CAAA;IAAA;IAEjC,OAAA,GAAA;AACX;AAEA,SAAS,kBAAA,CAAmB,KAAA,EAAeA,SAA0B,EAAA;IAC3D,MAAA,IAAA,GAAO,MAAOA,CAAAA,SAAAA,CAAS,MAAM,CAAA;IACnC,MAAM,YAAY,EAAA;IAClB,MAAO,QAAQ,EAAI,CAAA;QACf,SAAA,CAAU,OAAA,CAAQA,SAAS,CAAA,MAAA,CAAO,KAAQ,GAAA,IAAI,CAAC,CAAC,CAAA;QACvC,KAAA,IAAA,IAAA;IAAA;IAEN,OAAA,SAAA,CAAU,IAAA,CAAK,EAAE,CAAA;AAC5B;AC1LA,IAAMA,SAAW,GAAA,4DAAA;AAqBJ,IAAA,gBAAA,GAAmB,IAAM,eAAA,CAAgBA,SAAQ,CAAA;AAoBjD,IAAA,gBAAA,GAAmB,IAAM,eAAA,CAAgBA,SAAQ,CAAA;AC3B9D,IAAI,iCAAA;AACG,SAAS,4BAAwE,GAAA;IACpF,IAAI,CAAC,iCAAmC,EAAA;QAC9B,MAAA,YAAA,2PAAe,kBAAA,+OAAgB,eAAa,AAAb,EAAa,GAAG;YAAE,IAAM,+OAAA,qBAAA;QAAA,CAAsB,CAAA;QAGnF,iCAAA,2PAAoC,mBAAA,AAAiB,EAAA;YACjD;gBAAC,oBAAsB;qPAAA,oBAAA,EAAmB;aAAA;YAC1C;gBAAC;gBAAmB,YAAY;aAAA;YAChC;gBAAC;gBAAmB,YAAY;aAAA;SACnC,CAAA;IAAA;IAGE,OAAA,iCAAA;AACX;AAEA,IAAI,iCAAA;AACG,SAAS,4BAAwE,GAAA;IACpF,IAAI,CAAC,iCAAmC,EAAA;QAC9B,MAAA,YAAA,2PAAe,kBAAA,EAAgB,4PAAA,AAAa,EAAA,GAAG;YAAE,IAAM,+OAAA,qBAAA;QAAA,CAAsB,CAAA;QAE/C,iCAAA,6OAAA,mBAAA,0PAChC,mBAAiB,AAAjB,EAAiB;YACb;gBAAC,oBAAsB;iBAAA,wPAAA,EAAmB;aAAA;YAC1C;gBAAC;gBAAmB,YAAY;aAAA;YAChC;gBAAC;gBAAmB,YAAY;aAAA;SACnC,CAAA,EACD,CAAA,WAAA,GACI,qBAAqB,WACd,GAAA;gBACG,GAAG,WAAA;gBACH,iBAAiB,WAAY,CAAA,eAAA;gBAAA,oFAAA;gBAE7B,iBAAiB,WAAY,CAAA,eAAA;YAAA,CAEjC,GAAA;IACd;IAIG,OAAA,iCAAA;AACX;ACjDA,IAAI,iBAAA;AACJ,SAAS,oBAAoD,GAAA;IACrD,IAAA,CAAC,iBAAmB,EAAA,iBAAA,+OAAoBE,gBAAa,AAAbA,EAAa;IAClD,OAAA,iBAAA;AACX;AAEA,IAAI,iBAAA;AACJ,SAAS,oBAAoD,GAAA;IACrD,IAAA,CAAC,iBAAmB,EAAA,iBAAA,gPAAoBC,eAAAA,AAAa,EAAA;IAClD,OAAA,iBAAA;AACX;AAQO,SAAS,uBAA8D,GAAA;IAC1E,+PAAOC,mBAAiB,AAAjBA,EAAiB;QACpB;YAAC,mBAAqB;YAAA,oBAAA,EAAsB;SAAA;QAC5C;YAAC,2BAA6B;YAAA,oBAAA,EAAsB;SAAA;QACpD;YAAC,8BAAgC;YAAA,oBAAA,EAAsB;SAAA;KAC1D,CAAA;AACL;AAEO,SAAS,uBAA8D,GAAA;IAC1E,+PAAOC,mBAAAA,AAAiB,EAAA;QACpB;YAAC,mBAAqB;YAAA,oBAAA,EAAsB;SAAA;QAC5C;YAAC,2BAA6B;YAAA,oBAAA,EAAsB;SAAA;QACpD;YAAC,8BAAgC;YAAA,oBAAA,EAAsB;SAAA;KAC1D,CAAA;AACL;AChBA,IAAI,6BAAA;AACG,SAAS,qBAA0D,GAAA;IACtE,IAAI,CAAC,6BAA+B,EAAA;QACA,6BAAA,6OAAA,mBAAA,0PAC5BD,mBAAAA,AAAiB,EAAA;YACb;gBAAC,qBAAuBF;4PAAAA,gBAAAA,EAAc;aAAA;YACtC;gBAAC,gBAAkBI;wQAAAA,kBAAAA,+OAAgBJ,eAAAA,AAAa,EAAA,GAAG;oBAAE,IAAMK,8OAAAA,sBAAAA,EAAqB;gBAAA,CAAC,CAAC;aAAA;YAClF;gBAAC,MAAQ;0PAAA,uBAAA,0PAAqB,kBAAA,EAAmBA,+OAAAA,sBAAAA,EAAoB,CAAC;aAAA;SACzE,CAAA,EAAA,oDAAA;QAED,CAAC,WAAoD,KAAA;YACjD,IAAI,WAAY,CAAA,cAAA,KAAmB,KAAA,CAAa,IAAA,WAAA,CAAY,IAAA,KAAS,KAAA,CAAW,EAAA;gBACrE,OAAA,WAAA;YAAA;;YAEJ,OAAA;gBACH,GAAG,WAAA;gBACH,cAAA,6CAA4B,cAAA,uDAAZ,WAAY,mBAAkB,EAAC;gBAC/C,IAAM,uBAAA,WAAA,CAAY,IAAQ,iEAAA,IAAI,WAAW,CAAC;YAAA,CAC9C;QAAA;IAER;IAGG,OAAA,6BAAA;AACX;AAEA,IAAI,6BAAA;AACG,SAAS,qBAA0D,GAAA;IACtE,IAAI,CAAC,6BAA+B,EAAA;QACAC,6BAAAA,6OAAAA,mBAAAA,0PAC5BH,mBAAAA,AAAiB,EAAA;YACb;gBAAC,qBAAuBF;6PAAAA,eAAAA,EAAc;aAAA;YACtC;gBAAC,gBAAkBM;uQAAAA,mBAAAA,+OAAgBN,eAAAA,AAAa,EAAA,GAAG;oBAAE,IAAMO,+OAAAA,qBAAAA,EAAqB;gBAAA,CAAC,CAAC;aAAA;YAClF;gBACI,MAAA;0PACA,uBAAA,AAAqB,0PAAA,kBAAA,EAAmBA,gPAAAA,qBAAAA,EAAoB;aAAA;SAEnE,CAAA,EAAA,sEAAA;QAED,CAAC,WAAoD,KAAA;YACjD,IAAI,WAAY,CAAA,cAAA,CAAe,MAAU,IAAA,WAAA,CAAY,IAAA,CAAK,UAAY,EAAA;gBAC3D,OAAA,WAAA;YAAA;YAEX,MAAM,EAAE,cAAA,EAAgB,IAAM,EAAA,GAAG,MAAS,GAAA,WAAA;YACnC,OAAA;gBACH,GAAG,IAAA;gBACH,GAAI,cAAA,CAAe,MAAS,GAAA;oBAAE;gBAAA,CAAmB,GAAA,IAAA;gBACjD,GAAI,IAAA,CAAK,UAAa,GAAA;oBAAE;gBAAA,CAAS,GAAA,IAAA;YAAA,CACrC;QAAA;IAER;IAEG,OAAA,6BAAA;AACX;ACjEA,IAAM,iBAAoB,GAAA,GAAA;AAQnB,SAAS,4BAAwE,GAAA;IACpF,gPAAOC,iBAAAA,AAAc,EAAA;QACjB,gBAAkB,EAAA,CAAA,KAAA,GAAU,KAAU,KAAA,QAAA,GAAW,CAAI,GAAA,CAAA;QACrD,OAAS,EAAA,CAAA;QACT,KAAO,EAAA,CAAC,KAAO,EAAA,KAAA,EAAO,MAAW,KAAA;YAC7B,IAAI,UAAU,QAAU,EAAA;gBACb,OAAA,MAAA;YAAA;YAEP,IAAA,KAAA,GAAQ,CAAK,IAAA,KAAA,GAAQ,GAAK,EAAA;gBACpB,MAAA,IAAIV,4OAAAA,+NAAY,yDAAwD,EAAA;oBAC1E,aAAe,EAAA;gBAAA,CAClB,CAAA;YAAA;YAEL,KAAA,CAAM,GAAI,CAAA;gBAAC,KAAQ,GAAA,iBAAiB;aAAA,EAAG,MAAM,CAAA;YAC7C,OAAO,MAAS,GAAA,CAAA;QAAA;IACpB,CACH,CAAA;AACL;AASO,SAAS,4BAAwE,GAAA;IACpF,iPAAOW,gBAAc,AAAdA,EAAc;QACjB,OAAS,EAAA,CAAA;QACT,IAAA,EAAM,CAAC,KAAA,EAAO,MAAW,KAAA;YACf,MAAA,SAAA,GAAY,KAAA,CAAM,MAAM,CAAA;YACzB,IAAA,CAAA,SAAA,GAAY,iBAAA,MAAuB,CAAG,EAAA;gBAEhC,OAAA;oBAAC;oBAAU,MAAM;iBAAA;YAAA,CACrB,MAAA;gBACH,MAAM,UAAW,SAAY,GAAA,iBAAA;gBACtB,OAAA;oBAAC,OAAS;oBAAA,MAAA,GAAS,CAAC;iBAAA;YAAA;QAC/B;IACJ,CACH,CAAA;AACL;AAQO,SAAS,0BAAoE,GAAA;IAChF,OAAOC,yPAAAA,AAAa,EAAA,4BAAA,EAAgC,EAAA,4BAAA,EAA8B,CAAA;AACtF;;AC9CA,SAAS,+BAAmF,GAAA;IACjFT,+PAAAA,mBAAAA,EAAiB,8BAA8B,CAAA;AAC1D;AAEA,SAAS,kCAAsF,GAAA;IACpFU,gPAAAA,oBAAAA,0PACHV,mBAAAA,AAAiB,EAAA;WACV,4BAA6B,EAAA;QAChC;YAAC,qBAAuB;YAAA,iCAAA,EAAmC;SAAA;KAC9D,CAAA,EACD,CAAC,KAAsC,KAAA;QAC/B,IAAA,KAAA,CAAM,OAAA,KAAY,QAAU,EAAA;YACrB,OAAA,KAAA;QAAA;YAIc,KAAM;QAFxB,OAAA;YACH,GAAG,KAAA;YACH,mBAAA,sCAA2B,mBAAA,mFAAuB,EAAA;QAAC,CACvD;IAAA;AAGZ;AAEA,SAAS,4BAA+B,GAAA;IAC7B,OAAA;QACH;YAAC,SAAW;YAAA,4BAAA,EAA8B;SAAA;QAC1C;YAAC,QAAU;YAAA,uBAAA,EAAyB;SAAA;QACpC;YAAC,gBAAkBE;oQAAAA,kBAAAA,uOAAgBS,oBAAAA,AAAkB,EAAA,GAAG;gBAAE,IAAMR,+OAAAA,qBAAAA,EAAqB;YAAA,CAAC,CAAC;SAAA;QACvF;YAAC,eAAiB;sPAAA,iBAAA,EAAe,gBAAiB,EAAA,EAAG,EAAE,CAAC;SAAA;QACxD;YAAC,cAAgBD;oQAAAA,kBAAAA,EAAgB,qBAAsB,EAAA,EAAG;gBAAE,IAAMC,GAAAA,iQAAAA,EAAqB;YAAA,CAAC,CAAC;SAAA;KAC7F;AACJ;AAEA,SAAS,4BAA+B,GAAA;IAC7B,OAAA;QACH;YAAC,SAAW;YAAA,4BAAA,EAAiD;SAAA;QAC7D;YAAC,QAAU;YAAA,uBAAA,EAAyB;SAAA;QACpC;YAAC,gBAAkBE;YAAAA,0QAAAA,uOAAgBO,oBAAAA,AAAkB,EAAA,GAAG;gBAAE,IAAMN,+OAAAA,qBAAAA,EAAqB;YAAA,CAAC,CAAC;SAAA;QACvF;YAAC,eAAiB;sPAAA,iBAAA,EAAe,gBAAiB,EAAA,EAAG,EAAE,CAAC;SAAA;QACxD;YAAC,cAAgBD;gBAAAA,sQAAAA,EAAgB,qBAAsB,EAAA,EAAG;gBAAE,IAAMC,+OAAAA,qBAAAA,EAAqB;YAAA,CAAC,CAAC;SAAA;QACzF;YAAC,qBAAuB;YAAA,iCAAA,EAAmC;SAAA;KAC/D;AACJ;AAEA,SAAS,iCAAoC,GAAA;IACzC,+PAAOJ,kBAAAA,EAAgB,4BAA6B,EAAA,EAAG;QAAE,IAAMC,+OAAAA,qBAAAA;IAAAA,CAAsB,CAAA;AACzF;AAEA,SAAS,iCAAoC,GAAA;IACzC,OAAOE,0QAAAA,EAAgB,4BAA6B,EAAA,EAAG;QAAE,IAAMC,+OAAAA,qBAAAA;IAAAA,CAAsB,CAAA;AACzF;AASO,SAAS,oCAAwF,GAAA;IACpG,iPAAOC,gBAAAA,AAAc,EAAA;QACjB,gBAAA,EAAkB,CAAC,eAAgD,KAAA;YAC3D,IAAA,eAAA,CAAgB,OAAA,KAAY,QAAU,EAAA;gBAC/B,OAAA,+BAAA,EAAkC,CAAA,gBAAA,CAAiB,eAAe,CAAA;YAAA,CACtE,MAAA;gBACI,OAAA,kCAAA,EAAqC,CAAA,gBAAA,CAAiB,eAAe,CAAA;YAAA;QAChF,CACJ;QACA,KAAO,EAAA,CAAC,eAAiB,EAAA,KAAA,EAAO,MAAW,KAAA;YACnC,IAAA,eAAA,CAAgB,OAAA,KAAY,QAAU,EAAA;gBACtC,OAAO,+BAAgC,EAAA,CAAE,KAAM,CAAA,eAAA,EAAiB,OAAO,MAAM,CAAA;YAAA,CAC1E,MAAA;gBACH,OAAO,kCAAmC,EAAA,CAAE,KAAM,CAAA,eAAA,EAAiB,OAAO,MAAM,CAAA;YAAA;QACpF;IACJ,CACH,CAAA;AACL;AASO,SAAS,oCAAwF,GAAA;IAC7FH,WAAAA,yPAAAA,0PACHH,mBAAAA,EAAiB,8BAA8B,CAAA,EAG/C;YAAC,EAAE,mBAAqB,EAAA,GAAG,eAAoB,KAAA;QAC3C,IAAI,aAAc,CAAA,OAAA,KAAY,QAAY,IAAA,4EAAC,oBAAqB,MAAQ,GAAA;YAC7D,OAAA,aAAA;QAAA;QAEJ,OAAA;YAAE,GAAG,aAAA;YAAe,mBAAoB;QAAA,CAAA;IAAA;AAM3D;AAQO,SAAS,kCAAoF,GAAA;IAChG,iPAAOQ,eAAAA,AAAa,EAAA,oCAAA,EAAwC,EAAA,oCAAA,EAAsC,CAAA;AACtG;ACzFA,SAAS,MAAA,CACL,UACA,EAAA,OAAA,EACA,MAGF,EAAA;QAC+B;IAAlB,UAAA,CAAA,OAAO,CAAI,GAAA,MAAA,kCAAkB,CAAA,OAAO,CAAA,qEAAK;QAAE,IAAA,sOAAM,cAAY,CAAA,QAAA;IAAA,CAAU,CAAA;AACtF;AAEA,IAAM,IAAA,GAAO,OAAO,wBAAwB,CAAA;AAGrC,SAAS,6BAAA,CAA8B,QAAA,EAAmB,YAAkD,EAAA;IAC/G,MAAM,UAAyB,GAAA;QAC3B,CAAC,QAAQ,CAAA,EAAG;YAAE,CAAC,IAAI,CAAA,EAAG,CAAA,CAAA,aAAA;YAA+B,IAAM,sOAAA,cAAA,CAAY,eAAgB;QAAA;IAAA,CAC3F;IACM,MAAA,0BAAA,GAAA,aAAA,GAAA,IAAiC,GAAa,EAAA;IACpD,KAAA,MAAW,eAAe,YAAc,CAAA;QAC7B,MAAA,CAAA,UAAA,EAAY,WAAY,CAAA,cAAA,EAAgB,CAAS,KAAA,KAAA;YACzB,0BAAA,CAAA,GAAA,CAAI,YAAY,cAAc,CAAA;YACzD,IAAI,QAAQ,KAAO,EAAA;gBACX,4OAAA,iBAAA,EAAe,KAAM,CAAA,IAAI,CAAG,EAAA;oBACpB,OAAA,KAAA,CAAM,IAAI,CAAG;wBACjB,KAAK,CAAA,CAAA,aAAA;4BACK,MAAA,kOAAIZ,cAAAA,+NAAY,8DAA6D,EAAA;gCAC/E,gBAAgB,WAAY,CAAA,cAAA;4BAAA,CAC/B,CAAA;wBACL;4BACU,MAAA,kOAAIA,cAAAA,+NAAY,mEAAkE,EAAA;gCACpF,gBAAgB,WAAY,CAAA,cAAA;4BAAA,CAC/B,CAAA;oBAAA;gBACT;gBAEA,IAAA,KAAA,CAAM,IAAI,CAAA,KAAM,CAA4B,CAAA,UAAA,KAAA;oBACrC,OAAA,KAAA;gBAAA;YACX;YAEJ,OAAO;gBAAE,CAAC,IAAI,CAAA,EAAG,CAA4B,CAAA,UAAA;gBAAA,IAAA,sOAAM,cAAA,CAAY,QAAS;YAAA,CAAA;QAAA,CAC3E,CAAA;QACG,IAAA,iBAAA;QACA,IAAA,CAAC,YAAY,QAAU,EAAA;YACvB;QAAA;QAEO,KAAA,MAAA,OAAA,IAAW,YAAY,QAAU,CAAA;YACjC,MAAA,CAAA,UAAA,EAAY,OAAQ,CAAA,OAAA,EAAS,CAAS,KAAA,KAAA;gBACnC,MAAA,EAAA,6DAAA;gBAEF,OAAS,EAAA,CAAA,EACT,GAAG,aACH,GAAA,OAAA;gBACJ,IAAI,QAAQ,KAAO,EAAA;oBACP,OAAA,KAAA,CAAM,IAAI,CAAG;wBACjB,KAAK,CAAA,CAAA,aAAA;4BAGM,OAAA,KAAA;wBACX,KAAK,CAAkC,CAAA,gBAAA;4BAAA;gCACnC,MAAM,QAAW,OAAA,iPAAA,EAAW,KAAM,CAAA,IAAA,EAAM,YAAY,IAAI,CAAA;gCACxD,IAAI,wBAAwB,WAAa,EAAA;oCAC/B,MAAA,kBAAA,GAAA,qEAAA;oCAEF,KAAA,CAAM,kBAAA,KAAuB,WAAY,CAAA,kBAAA,IAAA,wCAAA;oCAAA,uBAExC,wPAAsB,wBAAqB,AAArB,IAAqB,EACxC,WAAY,CAAA,kBAAA,EACZ,KAAM,CAAA,kBAAA,IACN;oCACR,IAAI,kBAAoB,EAAA;wCACb,OAAA;4CACH,CAAC,IAAI,CAAA,EAAG,CAAA,CAAA,gBAAA;4CACR,GAAG,WAAA;4CACH,IAAM,EAAA;wCAAA,CACV;oCAAA;gCACJ,CACO,MAAA,4OAAA,eAAA,EAAa,WAAY,CAAA,IAAI,CAAG,EAAA;oCAEhC,OAAA;wCACH,CAAC,IAAI,CAAA,EAAG,CAAA,CAAA,UAAA;wCACR,IAAM,EAAA;oCAAA,CACV;gCAAA;gCAEA,IAAA,KAAA,CAAM,IAAA,KAAS,QAAU,EAAA;oCAClB,OAAA;wCACH,GAAG,KAAA;wCACH,IAAM,EAAA;oCAAA,CACV;gCAAA,CACG,MAAA;oCACI,OAAA,KAAA;gCAAA;4BACX;wBAEJ,KAAK,CAA4B,CAAA,UAAA;4BAAA;gCAC7B,MAAM,QAAW,GAAA,qPAAA,EAAW,KAAM,CAAA,IAAA,EAAM,YAAY,IAAI,CAAA;gCACxD,IAAA,oEAAA;gCAAA,uBAAA;gCAGI,0BAAA,CAA2B,GAAI,CAAA,OAAA,CAAQ,OAAO,GAChD;oCACM,4OAAA,iBAAA,EAAe,WAAY,CAAA,IAAI,CAAG,EAAA;wCAClC,MAAM,kOAAIA,cAAAA,+NACN,mEAAA,EACA;4CACI,gBAAgB,OAAQ,CAAA,OAAA;wCAAA;oCAEhC;oCAEA,IAAA,KAAA,CAAM,IAAA,KAAS,QAAU,EAAA;wCAClB,OAAA;4CACH,GAAG,KAAA;4CACH,IAAM,EAAA;wCAAA,CACV;oCAAA,CACG,MAAA;wCACI,OAAA,KAAA;oCAAA;gCACX,OAAA,IAEA,oBAAwB,IAAA,WAAA,IAAA,gEAAA;gCAAA,wDAAA;gCAGxB,yOAAC,eAAA,EAAa,KAAM,CAAA,IAAI,CAC1B,EAAA;oCACS,OAAA;wCACH,GAAG,WAAA;wCACH,CAAC,IAAI,CAAA,EAAG,CAAA,CAAA,gBAAA;wCACR,IAAM,EAAA;oCAAA,CACV;gCAAA,CACG,MAAA;oCACC,IAAA,KAAA,CAAM,IAAA,KAAS,QAAU,EAAA;wCAElB,OAAA;4CACH,GAAG,KAAA;4CACH,IAAM,EAAA;wCAAA,CACV;oCAAA,CACG,MAAA;wCACI,OAAA,KAAA;oCAAA;gCACX;4BACJ;oBACJ;gBACJ;gBAEJ,IAAI,wBAAwB,WAAa,EAAA;oBAC9B,OAAA;wBACH,GAAG,WAAA;wBACH,CAAC,IAAI,CAAA,EAAG,CAAA,CAAA,gBAAA;oBAAA,CACZ;gBAAA,CACG,MAAA;oBACI,OAAA;wBACH,GAAG,WAAA;wBACH,CAAC,IAAI,CAAA,EAAG,CAAA,CAAA,UAAA;oBAAA,CACZ;gBAAA;YACJ,CACH,CAAA;QAAA;IACL;IAEG,OAAA,UAAA;AACX;AAEO,SAAS,iCAAiC,UAAyC,EAAA;IAClF,IAAA,iBAAA;IACJ,MAAM,eAAuD,GAAA,MAAA,CAAO,OAAQ,CAAA,UAAU,EACjF,IAAK,CAAA;YAAC,CAAC,WAAA,EAAa,SAAS,CAAA,UAAG,CAAC,YAAA,EAAc,UAAU,CAAM,KAAA;QAE5D,IAAI,SAAU,CAAA,IAAI,CAAM,KAAA,UAAA,CAAW,IAAI,CAAG,EAAA;YAClC,IAAA,SAAA,CAAU,IAAI,CAAA,KAAM,CAA+B,CAAA,aAAA,KAAA;gBAC5C,OAAA,CAAA,CAAA;YAAA,CACA,MAAA,IAAA,UAAA,CAAW,IAAI,CAAA,KAAM,CAA+B,CAAA,aAAA,KAAA;gBACpD,OAAA,CAAA;YAAA,CACA,MAAA,IAAA,SAAA,CAAU,IAAI,CAAA,KAAM,CAA4B,CAAA,UAAA,KAAA;gBAChD,OAAA,CAAA,CAAA;YAAA,CACA,MAAA,IAAA,UAAA,CAAW,IAAI,CAAA,KAAM,CAA4B,CAAA,UAAA,KAAA;gBACjD,OAAA,CAAA;YAAA;QACX;QAGE,MAAA,YAAA,2OAAe,eAAA,AAAa,EAAA,SAAA,CAAU,IAAI,CAAA;QAChD,IAAI,YAAiB,6OAAA,eAAA,EAAa,UAAW,CAAA,IAAI,CAAG,EAAA;YAChD,OAAO,eAAe,CAAA,CAAK,GAAA,CAAA;QAAA;QAEzB,MAAA,cAAA,2OAAiB,iBAAA,AAAe,EAAA,SAAA,CAAU,IAAI,CAAA;QACpD,IAAI,cAAmB,6OAAA,iBAAA,EAAe,UAAW,CAAA,IAAI,CAAG,EAAA;YACpD,OAAO,iBAAiB,CAAA,CAAK,GAAA,CAAA;QAAA;8BAGjC,iBAAA,wOAAsB,uBAAA,AAAqB,EAAA;QAEvC,IAAA,SAAA,CAAU,IAAI,CAAA,KAAM,CACpB,CAAA,gBAAA,OAAA,UAAA,CAAW,IAAI,CAAA,KAAM,CACrB,CAAA,gBAAA,OAAA,SAAA,CAAU,kBAAuB,KAAA,UAAA,CAAW,kBAC9C,EAAA;YACE,OAAO,iBAAkB,CAAA,SAAA,CAAU,kBAAoB,EAAA,UAAA,CAAW,kBAAkB,CAAA;QAAA,CACjF,MAAA;YACI,OAAA,iBAAA,CAAkB,aAAa,YAAY,CAAA;QAAA;IACtD,CACH,CACA,CAAA,GAAA,CAAI;YAAC,CAAC,OAAA,EAAS,WAAW,CAAO;eAAA;YAC9B,OAAA;YACA,GAAG,WAAA;QAAA,CACL,CAAA,CAAA;;IACC,OAAA,eAAA;AACX;AChOO,SAAS,+BAA+B,eAAwD,EAAA;IACnG,MAAM,QAKF,CAAA,CAAC;IACL,KAAA,MAAW,WAAW,eAAiB,CAAA;YAIpB,QAAM,OAAQ;QAHzB,IAAA,CAAA,CAAE,wBAAwB,OAAU,CAAA,EAAA;YACpC;QAAA;QAEJ,MAAM,KAAS,0DAAc,kBAAkB,YAAhC,6BAAsC,GAAA;YAAA,iDAAA,GAEjD,iBAAiB,EAAC;YAClB,iBAAiB,EAAC;YAClB,iBAAiB,EAAC;YAAA,iDAAA,GAElB,iBAAiB,EAAA;QAAC,CACtB;QACI,IAAA,OAAA,CAAQ,IAASgB,yOAAAA,cAAAA,CAAY,QAAU,EAAA;YACjC,KAAA,CAAA,eAAA,CAAgB,IAAK,CAAA,OAAA,CAAQ,YAAY,CAAA;YAEzC,KAAA,CAAA,eAAA,CAAgB,IAAK,CAAA,OAAA,CAAQ,YAAY,CAAA;QAAA,CAC5C,MAAA;YAEG,KAAA,CAAA,eAAA,CAAgB,IAAK,CAAA,OAAA,CAAQ,YAAY,CAAA;YACzC,KAAA,CAAA,eAAA,CAAgB,IAAK,CAAA,OAAA,CAAQ,YAAY,CAAA;QAAA;IACnD;IAEG,OAAA,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,CACnB,IAAA,sOAAKC,uBAAqB,AAArBA,EAAsB,CAC3B,EAAA,GAAA,CAAI,CAAuB,kBAAA,GAAA,CAAA;YACxB,kBAAA;YACA,GAAG,KAAA,CAAM,kBAAwC,CAAA;QAAA,CACnD,CAAA,CAAA;AACV;ACnBO,SAAS,yBAAyB,eAAiD,EAAA;IACtF,IAAI,4BAA+B,GAAA,CAAA;IACnC,IAAI,yBAA4B,GAAA,CAAA;IAChC,IAAI,iBAAoB,GAAA,CAAA;IACxB,KAAA,MAAW,WAAW,eAAiB,CAAA;QACnC,IAAI,wBAAwB,OAAS,EAAA;YACjC;QAAA;QAEE,MAAA,iBAAA,2OAAoBC,iBAAAA,AAAe,EAAA,OAAA,CAAQ,IAAI,CAAA;QACjDC,IAAAA,uPAAAA,EAAa,OAAQ,CAAA,IAAI,CAAG,EAAA;YAC5B,iBAAA,EAAA;YACA,IAAI,CAAC,iBAAmB,EAAA;gBACpB,yBAAA,EAAA;YAAA;QACJ,CACJ,MAAA,IAAW,CAAC,iBAAmB,EAAA;YAC3B,4BAAA,EAAA;QAAA;IACJ;IAEG,OAAA;QACH,4BAAA;QACA,yBAAA;QACA;IAAA,CACJ;AACJ;;ACpCA,SAAS,gBAAgB,eAAkC,EAAA;IACvD,MAAM,MAA+B,CAAA,CAAC;IACtC,KAAA,MAAW,CAAC,KAAO,EAAA,OAAO,CAAK,IAAA,eAAA,CAAgB,OAAA,EAAW,CAAA;QAClD,GAAA,CAAA,OAAA,CAAQ,OAAO,CAAI,GAAA,KAAA;IAAA;IAEpB,OAAA,GAAA;AACX;AAEO,SAAS,uBAAA,CACZ,YAAA,EACA,eACqB,EAAA;IACf,MAAA,YAAA,GAAe,gBAAgB,eAAe,CAAA;IACpD,OAAO,aAAa,GAAI,CAAA;YAAC,EAAE,QAAU,EAAA,IAAA,EAAM,cAAA,EAAqB,KAAA;QACrD,OAAA;YACH,mBAAA,EAAqB,YAAA,CAAa,cAAc,CAAA;YAChD,GAAI,QAAA,GAAW;gBAAE,cAAA,EAAgB,SAAS,GAAI,CAAA;wBAAC,EAAE,OAAA,EAAc;2BAAA,YAAA,CAAa,OAAO,CAAC;;YAAA,CAAM,GAAA,IAAA;YAC1F,GAAI,IAAA,GAAO;gBAAE,IAAA;YAAA,CAAS,GAAA,IAAA;QAAA,CAC1B;IAAA,CACH,CAAA;AACL;;ACvCO,SAAS,yBACZ,kBAIM,EAAA;IACN,IAAI,WAAW,kBAAoB,EAAA;QAC/B,OAAO,kBAAmB,CAAA,KAAA;IAAA;IAE9B,OAAO,kBAAmB,CAAA,SAAA;AAC9B;;ACRO,SAAS,0BAA0B,eAA6C,EAAA;IACnF,MAAM,4BAA+B,GAAA,eAAA,CAAgB,SAAU,CAAA,CAAA,OAAA,GAAW,wBAAwB,OAAO,CAAA;IACzG,MAAM,wBACF,4BAAiC,KAAA,CAAA,CAAA,GAAK,kBAAkB,eAAgB,CAAA,KAAA,CAAM,GAAG,4BAA4B,CAAA;IACjH,OAAO,sBAAsB,GAAI,CAAA;YAAC,EAAE,OAAA,EAAA;eAAc,OAAO,CAAA;;AAC7D;;ACwDO,SAAS,0BACZ,kBAC0B,EAAA;IAC1B,MAAM,UAAa,GAAA,6BAAA,CACf,mBAAmB,QAAS,CAAA,OAAA,EAC5B,kBAAmB,CAAA,YAAA;IAEjB,MAAA,eAAA,GAAkB,iCAAiC,UAAU,CAAA;IAC5D,OAAA;QACH,GAAI,mBAAmB,OAAY,KAAA,QAAA,GAC7B;YAAE,mBAAqB,EAAA,8BAAA,CAA+B,eAAe,CAAA;QAAA,CACrE,GAAA,IAAA;QACN,MAAA,EAAQ,yBAAyB,eAAe,CAAA;QAChD,YAAc,EAAA,uBAAA,CAAwB,kBAAmB,CAAA,YAAA,EAAc,eAAe,CAAA;QACtF,aAAA,EAAe,wBAAyB,CAAA,kBAAA,CAAmB,kBAAkB,CAAA;QAC7E,cAAA,EAAgB,0BAA0B,eAAe,CAAA;QACzD,SAAS,kBAAmB,CAAA,OAAA;IAAA,CAChC;AACJ;ACxEA,SAAS,yBAAA,CACL,OACA,EAAA,IAAA,EACA,6BAC6B,EAAA;IAC7B,KAAA,MAAW,CAAC,kBAAoB,EAAA,SAAS,CAAA,IAAK,MAAO,CAAA,OAAA,CAAQ,6BAA6B,CAAG,CAAA;QACzF,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,SAAA,CAAU,MAAA,EAAQ,CAAK,EAAA,CAAA;YACnC,IAAA,OAAA,KAAY,SAAU,CAAA,CAAC,CAAG,EAAA;gBACnB,OAAA;oBACH,OAAA;oBACA,YAAc,EAAA,CAAA;oBACd,kBAAA;oBACA;gBAAA,CACJ;YAAA;QACJ;IACJ;AAER;AAwDO,SAAS,kDAAA,CAGZ,kBAAA,EACA,6BAC8E,EAAA;IACxE,MAAA,oBAAA,GAAuB,IAAI,GAAA,CAAI,MAAO,CAAA,MAAA,CAAO,6BAA6B,CAAE,CAAA,OAAA,CAAQ,CAAK,CAAA,GAAA,CAAC,CAAC,CAAA;IAEjG,MAAM,kBAAiC,EAAC;IACxC,IAAI,sBAAyB,GAAA,KAAA;IAClB,KAAA,MAAA,WAAA,IAAe,mBAAmB,YAAc,CAAA;QACnD,IAAA,CAAC,YAAY,QAAU,EAAA;YACvB,eAAA,CAAgB,IAAA,CAAK,WAAW,CAAA;YAChC;QAAA;QAGJ,MAAM,cAA6D,EAAC;QACpE,IAAI,kBAAqB,GAAA,KAAA;QACd,KAAA,MAAA,OAAA,IAAW,YAAY,QAAU,CAAA;YAGpC,IAAA,oBAAA,IAAwB,OACxB,IAAA,CAAC,oBAAqB,CAAA,GAAA,CAAI,OAAQ,CAAA,OAAO,CACzCA,QAAAA,mPAAAA,EAAa,OAAQ,CAAA,IAAI,CAC3B,EAAA;gBACE,WAAA,CAAY,IAAA,CAAK,OAAO,CAAA;gBACxB;YAAA;YAIJ,MAAM,iBAAoB,GAAA,yBAAA,CACtB,OAAQ,CAAA,OAAA,EACR,OAAQ,CAAA,IAAA,EACR;YAEJ,WAAA,CAAY,IAAK,CAAA,MAAA,CAAO,MAAO,CAAA,iBAAiB,CAAC,CAAA;YAC5B,kBAAA,GAAA,IAAA;YACI,sBAAA,GAAA,IAAA;QAAA;QAGb,eAAA,CAAA,IAAA,CACZ,MAAA,CAAO,MAAA,CAAO,kBAAqB,GAAA;YAAE,GAAG,WAAa;YAAA,QAAA,EAAU,WAAY;QAAA,CAAA,GAAI,WAAW;IAC9F;IAGJ,OAAO,MAAO,CAAA,MAAA,CACV,yBAAyB;QAAE,GAAG,kBAAoB;QAAA,YAAA,EAAc;IAAA,CAAoB,GAAA;AAE5F;;AC5GO,SAAS,yBACZ,MACiC,EAAA;IACjC,OAAO,OAAO,MAAO,CAAA;QACjB,YAAc,EAAA,MAAA,CAAO,MAAO,CAAA,EAAE,CAAA;QAC9B,SAAS,MAAO,CAAA,OAAA;IAAA,CACnB,CAAA;AACL;ACDA,IAAM,iCACF,GAAA,6CAAA;AACJ,IAAM,sBAAyB,GAAA,kCAAA;AAexB,SAAS,oCAAA,CAIZ,mBAAA,EACA,qBAC4E,EAAA;IACrE,OAAA;QACH,QAAU,EAAA;YACN;gBAAE,OAAA,EAAS,mBAAqB;gBAAA,IAAA,EAAMH,kPAAAA,CAAY,QAAS;YAAA,CAAA;YAC3D;gBACI,OAAS,EAAA,iCAAA;gBACT,0OAAMA,cAAY,CAAA,QAAA;YAAA,CACtB;YACA;gBAAE,OAAA,EAAS,qBAAuB;gBAAA,IAAA,sOAAMA,cAAAA,CAAY,eAAgB;YAAA;SACxE;QACA,IAAA,EAAM,IAAI,UAAW,CAAA;YAAC;YAAG,CAAG;YAAA,CAAA;YAAG,CAAC;SAAC,CAAA;QACjC,cAAgB,EAAA;IAAA,CACpB;AACJ;AAmBO,SAAS,iCACZ,WAC6C,EAAA;QAKY,8BAAA;IAErD,WAAA;IANJ,OACI,YAAY,cAAmB,KAAA,sBAAA,IAAA,kDAAA;IAE/B,WAAY,CAAA,IAAA,IAAQ,IACpB,IAAA,oCAAA,CAAqC,YAAY,IAAI,CAAA,0CAEzC,QAAA,gFAAU,MAAW,MAAA,CAAA,IAAA,yCAAA;IAEjC,WAAA,CAAY,QAAS,CAAA,CAAC,CAAE,CAAA,OAAA,IAAW,IACnC,IAAA,WAAA,CAAY,QAAS,CAAA,CAAC,CAAE,CAAA,IAAA,yOAASA,cAAY,CAAA,QAAA,IAAA,8CAAA;IAE7C,WAAA,CAAY,QAAS,CAAA,CAAC,CAAE,CAAA,OAAA,KAAY,iCACpC,IAAA,WAAA,CAAY,QAAS,CAAA,CAAC,CAAE,CAAA,IAAA,yOAASA,cAAY,CAAA,QAAA,IAAA,2CAAA;IAE7C,WAAA,CAAY,QAAS,CAAA,CAAC,CAAE,CAAA,OAAA,IAAW,IACnCG,QAAAA,mPAAAA,EAAa,WAAY,CAAA,QAAA,CAAS,CAAC,CAAA,CAAE,IAAI,CAAA;AAEjD;AAEA,SAAS,qCAAqC,IAAsE,EAAA;IAEhH,OAAO,KAAK,UAAe,KAAA,CAAA,IAAK,IAAK,CAAA,CAAC,CAAA,KAAM,CAAK,IAAA,IAAA,CAAK,CAAC,CAAA,KAAM,KAAK,IAAK,CAAA,CAAC,CAAA,KAAM,CAAK,IAAA,IAAA,CAAK,CAAC,CAAM,KAAA,CAAA;AACnG;;ACfO,SAAS,6CACZ,kBACyF,EAAA;IACzF,OACI,wBAAwB,kBACxB,IAAA,OAAO,kBAAmB,CAAA,kBAAA,CAAmB,KAAA,KAAU,QACvD,IAAA,kBAAA,CAAmB,YAAa,CAAA,CAAC,CAAA,IAAK,IACtC,IAAA,gCAAA,CAAiC,kBAAmB,CAAA,YAAA,CAAa,CAAC,CAAC,CAAA;AAE3E;AAwBO,SAAS,mDACZ,kBACiG,EAAA;IAC7F,IAAA,CAAC,4CAA6C,CAAA,kBAAkB,CAAG,EAAA;QAC7D,MAAA,kOAAInB,cAAAA,+NAAY,qDAAkD,CAAA;IAAA;AAEhF;AAEA,SAAS,wCAAA,CAIL,WACA,EAAA,mBAAA,EACA,qBAC2F,EAAA;IAEvF,OAAA,WAAA,CAAY,QAAS,CAAA,CAAC,CAAE,CAAA,OAAA,KAAY,uBACpC,WAAY,CAAA,QAAA,CAAS,CAAC,CAAA,CAAE,OAAY,KAAA,qBAAA;AAE5C;AAyCO,SAAS,8CAMZ,QAKA,kBAMF,EAAA;UAVM,KAAA,EACA,mBAAA,EACA,qBAAA,EACJ,GAJA;IAmBI,IAAA,eAAA;IAKE,MAAA,gBAAA,GAAmB,kBAAmB,CAAA,YAAA,CAAa,CAAC,CAAA;IACtD,IAAA,gBAAA,IAAoB,gCAAiC,CAAA,gBAAgB,CAAG,EAAA;QACxE,IAAI,wCAAyC,CAAA,gBAAA,EAAkB,mBAAqB,EAAA,qBAAqB,CAAG,EAAA;YACxG,IACI,6CAA6C,kBAAkB,CAAA,IAC/D,kBAAmB,CAAA,kBAAA,CAAmB,KAAA,KAAU,KAClD,EAAA;gBACS,OAAA,kBAAA;YAAA,CACJ,MAAA;gBAEH,eAAA,GAAkB;oBAAC,gBAAkB,EAAA;uBAAG,mBAAmB,YAAa,CAAA,KAAA,CAAM,CAAC,CAAC;iBAAA;YAAA;QACpF,CACG,MAAA;YAEe,eAAA,GAAA;gBACd,MAAO,CAAA,MAAA,CAAO,oCAAqC,CAAA,mBAAA,EAAqB,qBAAqB,CAAC,CAAA;mBAC3F,kBAAA,CAAmB,YAAa,CAAA,KAAA,CAAM,CAAC;aAC9C;QAAA;IACJ,CACG,MAAA;QAEe,eAAA,GAAA;YACd,MAAO,CAAA,MAAA,CAAO,oCAAqC,CAAA,mBAAA,EAAqB,qBAAqB,CAAC,CAAA;eAC3F,kBAAmB,CAAA,YAAA;SAC1B;IAAA;IAGJ,OAAO,OAAO,MAAO,CAAA;QACjB,GAAG,kBAAA;QACH,YAAA,EAAc,MAAO,CAAA,MAAA,CAAO,eAAe,CAAA;QAC3C,kBAAoB,EAAA,MAAA,CAAO,MAAO,CAAA;YAAE;QAAA,CAAO;IAAA,CAC9C,CAAA;AACL;;ACzNO,SAAS,6BAAA,CAIZ,QAAA,EACA,kBACyG,EAAA;;IAErG,IAAA,UAAA,IAAc,sBACd,QAAa,yDAAmB,QAAA,iEAAnB,kBAAA,WAA6B,OAC1C,KAAA,qBAAA,CAAsB,kBAAmB,CAAA,QAAQ,CACnD,EAAA;QACS,OAAA,kBAAA;IAAA;IAGX,MAAM,GAAM,GAAA;QACR,GAAG,kBAAA;QACH,UAAU,MAAO,CAAA,MAAA,CAAO;YAAE,OAAA,EAAS;QAAA,CAAU;IAAA,CACjD;IACA,MAAA,CAAO,MAAA,CAAO,GAAG,CAAA;IACV,OAAA,GAAA;AACX;AAEA,SAAS,sBACL,QACgC,EAAA;IAChC,OACI,CAAC,CAAC,QACF,IAAA,SAAA,IAAa,QACb,IAAA,OAAO,QAAS,CAAA,OAAA,KAAY,QAC5B,IAAA,MAAA,CAAO,IAAK,CAAA,QAAQ,EAAE,MAAW,KAAA,CAAA;AAEzC;;ACdO,SAAS,mCAAA,CAIZ,WAAA,EACA,kBACyE,EAAA;IACzE,OAAO,oCAAqC,CAAA;QAAC,WAAW;KAAA,EAAG,kBAAkB,CAAA;AACjF;AA6BO,SAAS,oCAAA,CAIZ,YAAA,EACA,kBACwE,EAAA;IACxE,OAAO,OAAO,MAAO,CAAA;QACjB,GAAG,kBAAA;QACH,YAAA,EAAc,OAAO,MAAO,CAAA;eACpB,kBAAmB,CAAA,YAAA;eACpB;SACiE;IAAA,CAC3E,CAAA;AACL;AAuBO,SAAS,oCAAA,CAIZ,WAAA,EACA,kBAC0E,EAAA;IAC1E,OAAO,qCAAsC,CAAA;QAAC,WAAW;KAAA,EAAG,kBAAkB,CAAA;AAClF;AA6BO,SAAS,qCAAA,CAIZ,YAAA,EACA,kBACyE,EAAA;IACzE,OAAO,OAAO,MAAO,CAAA;QACjB,GAAI,kBAAA;QACJ,YAAA,EAAc,OAAO,MAAO,CAAA;eACrB,YAAA;eACC,kBAAmB,CAAA,YAAA;SAC6C;IAAA,CAC3E,CAAA;AACL;;ACzJA,SAAS,gBAAgB,OAAoD,EAAA;IACnE,MAAA,EAAE,MAAA,EAAW,GAAA,OAAA;IACb,MAAA,yBAAA,GAA4B,MAAO,CAAA,iBAAA,GAAoB,MAAO,CAAA,yBAAA;IACpE,MAAM,+BACF,OAAQ,CAAA,cAAA,CAAe,MAAS,GAAA,MAAA,CAAO,iBAAA,GAAoB,MAAO,CAAA,4BAAA;IAEtE,MAAM,eAA8B,EAAC;IAErC,IAAI,YAAe,GAAA,CAAA;IACnB,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,yBAAA,EAA2B,CAAK,EAAA,CAAA;QAChD,YAAA,CAAa,IAAK,CAAA;YACd,OAAA,EAAS,OAAQ,CAAA,cAAA,CAAe,YAAY,CAAA;YAC5C,0OAAMgB,cAAY,CAAA,eAAA;QAAA,CACrB,CAAA;QACD,YAAA,EAAA;IAAA;IAGJ,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,yBAAA,EAA2B,CAAK,EAAA,CAAA;QACvD,YAAA,CAAa,IAAK,CAAA;YACd,OAAA,EAAS,OAAQ,CAAA,cAAA,CAAe,YAAY,CAAA;YAC5C,0OAAMA,cAAY,CAAA,eAAA;QAAA,CACrB,CAAA;QACD,YAAA,EAAA;IAAA;IAGJ,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,4BAAA,EAA8B,CAAK,EAAA,CAAA;QACnD,YAAA,CAAa,IAAK,CAAA;YACd,OAAA,EAAS,OAAQ,CAAA,cAAA,CAAe,YAAY,CAAA;YAC5C,0OAAMA,cAAY,CAAA,QAAA;QAAA,CACrB,CAAA;QACD,YAAA,EAAA;IAAA;IAGJ,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,4BAAA,EAA8B,CAAK,EAAA,CAAA;QAC1D,YAAA,CAAa,IAAK,CAAA;YACd,OAAA,EAAS,OAAQ,CAAA,cAAA,CAAe,YAAY,CAAA;YAC5C,0OAAMA,cAAY,CAAA,QAAA;QAAA,CACrB,CAAA;QACD,YAAA,EAAA;IAAA;IAGG,OAAA,YAAA;AACX;AAEA,SAAS,qBAAA,CACL,2BAAA,EACA,6BACmB,EAAA;IAEnB,MAAM,mCAAsC,GAAA,2BAAA,CAA4B,GAAI,CAAA,CAAA,CAAA,GAAK,EAAE,kBAAkB,CAAA;IACrG,MAAM,UAAU,mCAAoC,CAAA,MAAA,CAAO,CAAA,IAAK,6BAA8B,CAAA,CAAC,CAAA,KAAM,KAAA,CAAS,CAAA;IAC1G,IAAA,OAAA,CAAQ,MAAA,GAAS,CAAG,EAAA;QACd,MAAA,kOAAIhB,cAAAA,+NAAY,uFAAsF,EAAA;YACxG,oBAAsB,EAAA;QAAA,CACzB,CAAA;IAAA;IAGL,MAAM,gBAAqC,EAAC;IAC5C,MAAM,gBAAqC,EAAC;IAG5C,KAAA,MAAW,UAAU,2BAA6B,CAAA;QACxC,MAAA,SAAA,GAAY,6BAA8B,CAAA,MAAA,CAAO,kBAAkB,CAAA;YAErE,MAAO;QADX,MAAM,oDACK,eAAA,6EAAA,iDAAA,GAEP,MAAO,CAAA,eAAA;;QACX,MAAM,oDACK,eAAA,mDAAP,MAAO,oBAAA,iDAAA,GAEP,MAAO,CAAA,eAAA;QAEX,MAAM,eAAe,IAAK,CAAA,GAAA,CAAI,GAAG,eAAA,EAAiB,GAAG,eAAe,CAAA;QAChE,IAAA,YAAA,IAAgB,UAAU,MAAQ,EAAA;YAClC,MAAM,kOAAIA,cAAAA,8NACN,0FAAA,EACA;gBACI,iBAAA,EAAmB,UAAU,MAAS,GAAA,CAAA;gBACtC,qBAAuB,EAAA,YAAA;gBACvB,oBAAoB,MAAO,CAAA,kBAAA;YAAA;QAEnC;QAGE,MAAA,iBAAA,GAAyC,eAAgB,CAAA,GAAA,CAAI,CAAM,CAAA,GAAA,CAAA;gBACrE,OAAA,EAAS,SAAA,CAAU,CAAC,CAAA;gBACpB,YAAc,EAAA,CAAA;gBACd,oBAAoB,MAAO,CAAA,kBAAA;gBAC3B,0OAAMgB,cAAY,CAAA,QAAA;YAAA,CACpB,CAAA,CAAA;QACY,aAAA,CAAA,IAAA,CAAK,GAAG,iBAAiB,CAAA;QAEjC,MAAA,iBAAA,GAAyC,eAAgB,CAAA,GAAA,CAAI,CAAM,CAAA,GAAA,CAAA;gBACrE,OAAA,EAAS,SAAA,CAAU,CAAC,CAAA;gBACpB,YAAc,EAAA,CAAA;gBACd,oBAAoB,MAAO,CAAA,kBAAA;gBAC3B,0OAAMA,cAAY,CAAA,QAAA;YAAA,CACpB,CAAA,CAAA;QACY,aAAA,CAAA,IAAA,CAAK,GAAG,iBAAiB,CAAA;IAAA;IAG3C,OAAO,CAAC;WAAG,aAAe,EAAA;WAAG,aAAa;KAAA;AAC9C;AAEA,SAAS,kBAAA,CACL,WAAA,EACA,YACW,EAAA;uDAQM,WAAY;IAP7B,MAAM,cAAiB,gEAAA,CAAa,WAAY,CAAA,mBAAmB,CAAG,kFAA/C,8CAA+C,OAAA;IACtE,IAAI,CAAC,cAAgB,EAAA;QACX,MAAA,kOAAIhB,cAAAA,+NAAY,uFAAsF,EAAA;YACxG,OAAO,WAAY,CAAA,mBAAA;QAAA,CACtB,CAAA;IAAA;IAGL,MAAM,sDAAuB,cAAA,4FAAgB,GAAA,CAAI,CAAgB,YAAA,GAAA,YAAA,CAAa,YAAY,CAAC,CAAA;IACrF,MAAA,EAAE,IAAA,EAAS,GAAA,WAAA;IAEjB,OAAO,OAAO,MAAO,CAAA;QACjB,cAAA;QACA,GAAI,QAAY,IAAA,QAAA,CAAS,MAAS,GAAA;YAAE,QAAU,EAAA,MAAA,CAAO,MAAO,CAAA,QAAQ,CAAE;QAAA,CAAA,GAAI,CAAA,CAAC;QAC3E,GAAI,IAAQ,IAAA,IAAA,CAAK,MAAA,GAAS;YAAE,IAAA;QAAA,IAAS,CAAA,CAAA;IAAC,CACzC,CAAA;AACL;AAaA,SAAS,qBAAA,CACL,oBACA,EAAA,gBAAA,EACA,oBACkB,EAAA;IAClB,IAAI,CAAC,gBAAA,IAAoB,CAAC,gCAAA,CAAiC,gBAAgB,CAAG,EAAA;QAEnE,OAAA;YACH,SAAW,EAAA,oBAAA;YACX,oBAAA,qEAAsB,oBAAwB,GAAA,EAAA,IAAM,GAAM,GAAA,EAAA;QAAA,CAC9D;IAAA,CACG,MAAA;QAEH,MAAM,mBAAsB,GAAA,gBAAA,CAAiB,QAAS,CAAA,CAAC,CAAE,CAAA,OAAA;SACzD,sPAAA,EAAgB,mBAAmB,CAAA;QAEnC,MAAM,qBAAwB,GAAA,gBAAA,CAAiB,QAAS,CAAA,CAAC,CAAE,CAAA,OAAA;QAC3D,uPAAA,EAAgB,qBAAqB,CAAA;QAE9B,OAAA;YACH,KAAO,EAAA,oBAAA;YACP,mBAAA;YACA;QAAA,CACJ;IAAA;AAER;AA8BO,SAAS,2BAAA,CACZ,0BAAA,EACA,MAC4B,EAAA;IACtB,MAAA,QAAA,GAAW,0BAA2B,CAAA,cAAA,CAAe,CAAC,CAAA;IAC5D,IAAI,CAAC,QAAU,EAAA;QACL,MAAA,kOAAIA,cAAAA,+NAAY,mEAAgE,CAAA;IAAA;IAGpF,MAAA,YAAA,GAAe,gBAAgB,0BAA0B,CAAA;;IACzD,MAAA,kBAAA,GACF,yBAAyB,0BACzB,IAAA,0BAAA,CAA2B,mBAAA,KAAwB,KAAA,CACnD,IAAA,0BAAA,CAA2B,mBAAoB,CAAA,MAAA,GAAS,CAClD,GAAA,qBAAA,CACI,0BAA2B,CAAA,mBAAA,EAC3B,MAAA,0FAAQ,6BAAA,yGAAiC,CAAA,KAE7C,EAAC;IACX,MAAM,gBAAmB,GAAA,CAAC;WAAG,YAAA,EAAc;WAAG,kBAAkB;KAAA;IAE1D,MAAA,YAAA,GAA8B,2BAA2B,YAAa,CAAA,GAAA,CAAI,CAAA,mBAAA,GAC5E,kBAAmB,CAAA,mBAAA,EAAqB,gBAAgB;IAGtD,MAAA,gBAAA,GAAmB,YAAA,CAAa,CAAC,CAAA;IACvC,MAAM,kBAAqB,GAAA,qBAAA,CACvB,0BAA2B,CAAA,aAAA,EAC3B,gBAAA,kDACA,MAAQ,CAAA,oBAAA;IAGL,QAAA,4OAAA,EACH,wBAAyB,CAAA;QAAE,OAAS,EAAA,0BAAA,CAA2B,OAAA;IAAA,CAA+B,CAAA,EAC9F,CAAA,CAAA,GAAK,6BAA8B,CAAA,QAAA,EAAU,CAAC,CAAA,EAC9C,CAAA,IACI,YAAa,CAAA,MAAA,CACT,CAAC,GAAA,EAAK,WAAgB,GAAA,mCAAA,CAAoC,aAAa,GAAG,CAAA,EAC1E,IAER,CAAA,CAAA,GACI,eAAe,kBACT,GAAA,2CAAA,CAA4C,oBAAoB,CAAC,CAAA,GACjE,8CAA+C,CAAA,kBAAA,EAAoB,CAAC;AAEtF;;AC3NO,IAAM,sCAAyC,GAAA;AA2B/C,IAAM,yBAA4B,GAAA","debugId":null}},
    {"offset": {"line": 2203, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana/transaction-messages/dist/index.browser.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/blockhash.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/codecs-strings/src/assertions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/codecs-strings/src/baseX.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/codecs-strings/src/base58.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/codecs/address-table-lookup.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/codecs/header.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/codecs/instruction.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/codecs/transaction-version.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/codecs/message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compile/accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compile/address-table-lookups.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compile/header.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compile/instructions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compile/lifetime-token.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compile/static-accounts.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compile/message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/compress-transaction-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/create-transaction-message.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/durable-nonce.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/fee-payer.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/instructions.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana/transaction-messages/src/decompile-message.ts"],"sourcesContent":["import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { assertIsBlockhash, type Blockhash } from '@solana/rpc-types';\n\nimport { TransactionMessageWithDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    const lifetimeConstraintShapeMatches =\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint';\n    if (!lifetimeConstraintShapeMatches) return false;\n    try {\n        assertIsBlockhash(transactionMessage.lifetimeConstraint.blockhash);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): Omit<TTransactionMessage, 'lifetimeConstraint'> & TransactionMessageWithBlockhashLifetime;\n\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends\n        | BaseTransactionMessage\n        | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): TransactionMessageWithBlockhashLifetime & TTransactionMessage;\n\nexport function setTransactionMessageLifetimeUsingBlockhash(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n) {\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage;\n    }\n    const out = {\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    };\n    Object.freeze(out);\n    return out;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    transformDecoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n        memoizedAddressTableLookupDecoder = transformDecoder(\n            getStructDecoder([\n                ['lookupTableAddress', getAddressDecoder()],\n                ['writableIndexes', indexEncoder],\n                ['readonlyIndexes', indexEncoder],\n            ]),\n            lookupTable =>\n                'readableIndices' in lookupTable\n                    ? ({\n                          ...lookupTable,\n                          readonlyIndexes: lookupTable.readableIndices,\n                          // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n                          writableIndexes: lookupTable.writableIndices,\n                      } as AddressTableLookup)\n                    : lookupTable,\n        );\n    }\n\n    // @ts-expect-error Remove when `readableIndices` and `writableIndices` are removed.\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<CompiledTransactionMessage>;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<CompiledTransactionMessage>,\n        (value: CompiledTransactionMessage) => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            } as Exclude<CompiledTransactionMessage, { readonly version: 'legacy' }>;\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', fixEncoderSize(getBase58Encoder(), 32)],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<CompiledTransactionMessage> {\n    return createEncoder({\n        getSizeFromValue: (compiledMessage: CompiledTransactionMessage) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<CompiledTransactionMessage> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage & { addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups> }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups } as Exclude<\n                CompiledTransactionMessage,\n                { readonly version: 'legacy' }\n            >;\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<CompiledTransactionMessage> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountRole,\n    IAccountLookupMeta,\n    IAccountMeta,\n    IInstruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(IAccountLookupMeta | IAccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly IInstruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (IAccountLookupMeta | IAccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** @deprecated Use `readonlyIndexes` */\n    readableIndices: readonly number[];\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n    /** @deprecated Use `writableIndexes` */\n    writableIndices: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            /** @deprecated Remove in a future major version */\n            readableIndices: [],\n            readonlyIndexes: [],\n            writableIndexes: [],\n            /** @deprecated Remove in a future major version */\n            writableIndices: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n            /** @deprecated Remove in a future major version */\n            entry.writableIndices.push(account.addressIndex);\n        } else {\n            /** @deprecated Remove in a future major version */\n            entry.readableIndices.push(account.addressIndex);\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { IInstruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly IInstruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { CompilableTransactionMessage } from '../compilable-transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage & Readonly<{ version: 'legacy' }>,\n): LegacyCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): VersionedCompiledTransactionMessage;\nexport function compileTransactionMessage(\n    transactionMessage: CompilableTransactionMessage,\n): CompiledTransactionMessage {\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        lifetimeToken: getCompiledLifetimeToken(transactionMessage.lifetimeConstraint),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be IAccountLookupMeta | IAccountMeta\ntype WidenInstructionAccounts<TInstruction extends IInstruction> =\n    TInstruction extends IInstruction<infer TProgramAddress, infer TAccounts>\n        ? IInstruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends IAccountMeta<infer TAddress>\n                      ? IAccountLookupMeta<TAddress> | IAccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link IAccountLookupMeta}\n * instead of an {@link IAccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { compressTransactionMessageUsingAddressLookupTables } from '@solana/transaction-messages';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const accountAddress = address('5n2ADjHPsqB4EVUNEX48xRqtnmuLu5XSHDwkJRR98qpM');\n * const lookupTableAddresses: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: [accountAddress],\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     lookupTableAddresses,\n * );\n * ```\n *\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const lookupTableAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap(a => a));\n\n    const newInstructions: IInstruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<IInstruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !lookupTableAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): Extract<TransactionMessage, { version: TVersion }>;\nexport function createTransactionMessage<TVersion extends TransactionVersion>({\n    version,\n}: TransactionConfig<TVersion>): TransactionMessage {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version,\n    }) as TransactionMessage;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport {\n    AccountRole,\n    IInstruction,\n    IInstructionWithAccounts,\n    IInstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\ntype AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = IInstruction<'11111111111111111111111111111111'> &\n    IInstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    IInstructionWithData<AdvanceNonceAccountInstructionData>;\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsDurableNonceTransactionMessage } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsDurableNonceTransactionMessage(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsDurableNonceTransactionMessage(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isDurableNonceTransaction(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nfunction createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: IInstruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isDurableNonceTransaction(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transactions';\n *\n * const NONCE_VALUE_OFFSET =\n *     4 + // version(u32)\n *     4 + // state(u32)\n *     32; // nonce authority(pubkey)\n * // Then comes the nonce value.\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n * const { value: nonceAccount } = await rpc\n *     .getAccountInfo(nonceAccountAddress, {\n *         dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },\n *         encoding: 'base58',\n *     })\n *     .send();\n * const nonce =\n *     // This works because we asked for the exact slice of data representing the nonce\n *     // value, and furthermore asked for it in `base58` encoding.\n *     nonceAccount!.data[0] as unknown as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage | (TransactionMessageWithDurableNonceLifetime & TTransactionMessage),\n): TransactionMessageWithDurableNonceLifetime<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n    TTransactionMessage {\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...IInstruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isDurableNonceTransaction(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as TransactionMessageWithDurableNonceLifetime<\n                    TNonceAccountAddress,\n                    TNonceAuthorityAddress,\n                    TNonceValue\n                > &\n                    TTransactionMessage;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({\n            nonce,\n        }),\n    }) as TransactionMessageWithDurableNonceLifetime<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue> &\n        TTransactionMessage;\n}\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface ITransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link ITransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<ITransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ITransactionMessageWithFeePayer<TFeePayerAddress> & Omit<TTransactionMessage, 'feePayer'> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as ITransactionMessageWithFeePayer<TFeePayerAddress> &\n            Omit<TTransactionMessage, 'feePayer'>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<ITransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { TransactionMessageWithDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<TTransactionMessage extends BaseTransactionMessage>(\n    instruction: TTransactionMessage['instructions'][number],\n    transactionMessage: TTransactionMessage,\n): TTransactionMessage {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<TTransactionMessage extends BaseTransactionMessage>(\n    instructions: ReadonlyArray<TTransactionMessage['instructions'][number]>,\n    transactionMessage: TTransactionMessage,\n): TTransactionMessage {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([...transactionMessage.instructions, ...instructions]),\n    });\n}\n\n// Durable nonce advance instruction must be the first instruction in the transaction message\n// So if instructions are prepended, we strip the durable nonce transaction message type\ntype ExcludeDurableNonce<T> = T extends TransactionMessageWithDurableNonceLifetime\n    ? BaseTransactionMessage & Omit<T, keyof TransactionMessageWithDurableNonceLifetime>\n    : T;\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<TTransactionMessage extends BaseTransactionMessage>(\n    instruction: TTransactionMessage['instructions'][number],\n    transactionMessage: TTransactionMessage,\n): ExcludeDurableNonce<TTransactionMessage> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<TTransactionMessage extends BaseTransactionMessage>(\n    instructions: ReadonlyArray<TTransactionMessage['instructions'][number]>,\n    transactionMessage: TTransactionMessage,\n): ExcludeDurableNonce<TTransactionMessage> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([...instructions, ...transactionMessage.instructions]),\n    }) as ExcludeDurableNonce<TTransactionMessage>;\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountRole, IAccountLookupMeta, IAccountMeta, IInstruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompilableTransactionMessage } from './compilable-transaction-message';\nimport { CompiledTransactionMessage } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport {\n    isAdvanceNonceAccountInstruction,\n    Nonce,\n    setTransactionMessageLifetimeUsingDurableNonce,\n} from './durable-nonce';\nimport { setTransactionMessageFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): IAccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: IAccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): IAccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: IAccountLookupMeta[] = [];\n    const writableMetas: IAccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes =\n            lookup.readonlyIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.readableIndices;\n        const writableIndexes =\n            lookup.writableIndexes ??\n            /** @deprecated Remove in a future major version */\n            lookup.writableIndices;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: IAccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: IAccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: IAccountMeta[],\n): IInstruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: IInstruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage,\n    config?: DecompileTransactionMessageConfig,\n): CompilableTransactionMessage {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: IInstruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce((acc, instruction) => {\n                return appendTransactionMessageInstruction(instruction, acc);\n            }, m),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n"],"names":["alphabet","SolanaError","getU8Encoder","getU8Decoder","getStructEncoder","getStructDecoder","getArrayEncoder","getShortU16Encoder","transformDecoder","getArrayDecoder","getShortU16Decoder","createEncoder","createDecoder","combineCodec","transformEncoder","getAddressEncoder","getAddressDecoder","AccountRole","getAddressComparator","isWritableRole","isSignerRole"],"mappings":"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","debugId":null}}]
}