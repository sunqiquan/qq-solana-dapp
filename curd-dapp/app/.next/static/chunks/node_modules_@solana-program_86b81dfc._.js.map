{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana-program/compute-budget/dist/src/index.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/generated/programs/computeBudget.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/generated/instructions/requestHeapFrame.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/generated/instructions/requestUnits.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/generated/instructions/setComputeUnitLimit.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/generated/instructions/setComputeUnitPrice.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/generated/instructions/setLoadedAccountsDataSizeLimit.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/constants.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/internal.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/setComputeLimit.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/estimateAndSetComputeLimit.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/internalMoveToKit.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/estimateComputeLimitInternal.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/estimateComputeLimit.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/compute-budget/src/setComputePrice.ts"],"sourcesContent":["/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedRequestHeapFrameInstruction,\n  type ParsedRequestUnitsInstruction,\n  type ParsedSetComputeUnitLimitInstruction,\n  type ParsedSetComputeUnitPriceInstruction,\n  type ParsedSetLoadedAccountsDataSizeLimitInstruction,\n} from '../instructions';\n\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS =\n  'ComputeBudget111111111111111111111111111111' as Address<'ComputeBudget111111111111111111111111111111'>;\n\nexport enum ComputeBudgetInstruction {\n  RequestUnits,\n  RequestHeapFrame,\n  SetComputeUnitLimit,\n  SetComputeUnitPrice,\n  SetLoadedAccountsDataSizeLimit,\n}\n\nexport function identifyComputeBudgetInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): ComputeBudgetInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return ComputeBudgetInstruction.RequestUnits;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return ComputeBudgetInstruction.RequestHeapFrame;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitLimit;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return ComputeBudgetInstruction.SetComputeUnitPrice;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a computeBudget instruction.'\n  );\n}\n\nexport type ParsedComputeBudgetInstruction<\n  TProgram extends string = 'ComputeBudget111111111111111111111111111111',\n> =\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestUnits;\n    } & ParsedRequestUnitsInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.RequestHeapFrame;\n    } & ParsedRequestHeapFrameInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitLimit;\n    } & ParsedSetComputeUnitLimitInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetComputeUnitPrice;\n    } & ParsedSetComputeUnitPriceInstruction<TProgram>)\n  | ({\n      instructionType: ComputeBudgetInstruction.SetLoadedAccountsDataSizeLimit;\n    } & ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_HEAP_FRAME_DISCRIMINATOR = 1;\n\nexport function getRequestHeapFrameDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_HEAP_FRAME_DISCRIMINATOR);\n}\n\nexport type RequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestHeapFrameInstructionData = {\n  discriminator: number;\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport type RequestHeapFrameInstructionDataArgs = {\n  /**\n   * Requested transaction-wide program heap size in bytes.\n   * Must be multiple of 1024. Applies to each program, including CPIs.\n   */\n  bytes: number;\n};\n\nexport function getRequestHeapFrameInstructionDataEncoder(): Encoder<RequestHeapFrameInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['bytes', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_HEAP_FRAME_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestHeapFrameInstructionDataDecoder(): Decoder<RequestHeapFrameInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['bytes', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestHeapFrameInstructionDataCodec(): Codec<\n  RequestHeapFrameInstructionDataArgs,\n  RequestHeapFrameInstructionData\n> {\n  return combineCodec(\n    getRequestHeapFrameInstructionDataEncoder(),\n    getRequestHeapFrameInstructionDataDecoder()\n  );\n}\n\nexport type RequestHeapFrameInput = {\n  bytes: RequestHeapFrameInstructionDataArgs['bytes'];\n};\n\nexport function getRequestHeapFrameInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestHeapFrameInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestHeapFrameInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getRequestHeapFrameInstructionDataEncoder().encode(\n      args as RequestHeapFrameInstructionDataArgs\n    ),\n  } as RequestHeapFrameInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedRequestHeapFrameInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: RequestHeapFrameInstructionData;\n};\n\nexport function parseRequestHeapFrameInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedRequestHeapFrameInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestHeapFrameInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const REQUEST_UNITS_DISCRIMINATOR = 0;\n\nexport function getRequestUnitsDiscriminatorBytes() {\n  return getU8Encoder().encode(REQUEST_UNITS_DISCRIMINATOR);\n}\n\nexport type RequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type RequestUnitsInstructionData = {\n  discriminator: number;\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport type RequestUnitsInstructionDataArgs = {\n  /** Units to request for transaction-wide compute. */\n  units: number;\n  /** Prioritization fee lamports. */\n  additionalFee: number;\n};\n\nexport function getRequestUnitsInstructionDataEncoder(): Encoder<RequestUnitsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n      ['additionalFee', getU32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: REQUEST_UNITS_DISCRIMINATOR })\n  );\n}\n\nexport function getRequestUnitsInstructionDataDecoder(): Decoder<RequestUnitsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n    ['additionalFee', getU32Decoder()],\n  ]);\n}\n\nexport function getRequestUnitsInstructionDataCodec(): Codec<\n  RequestUnitsInstructionDataArgs,\n  RequestUnitsInstructionData\n> {\n  return combineCodec(\n    getRequestUnitsInstructionDataEncoder(),\n    getRequestUnitsInstructionDataDecoder()\n  );\n}\n\nexport type RequestUnitsInput = {\n  units: RequestUnitsInstructionDataArgs['units'];\n  additionalFee: RequestUnitsInstructionDataArgs['additionalFee'];\n};\n\nexport function getRequestUnitsInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: RequestUnitsInput,\n  config?: { programAddress?: TProgramAddress }\n): RequestUnitsInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getRequestUnitsInstructionDataEncoder().encode(\n      args as RequestUnitsInstructionDataArgs\n    ),\n  } as RequestUnitsInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedRequestUnitsInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: RequestUnitsInstructionData;\n};\n\nexport function parseRequestUnitsInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedRequestUnitsInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getRequestUnitsInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR = 2;\n\nexport function getSetComputeUnitLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitLimitInstructionData = {\n  discriminator: number;\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport type SetComputeUnitLimitInstructionDataArgs = {\n  /** Transaction-wide compute unit limit. */\n  units: number;\n};\n\nexport function getSetComputeUnitLimitInstructionDataEncoder(): Encoder<SetComputeUnitLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['units', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitLimitInstructionDataDecoder(): Decoder<SetComputeUnitLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['units', getU32Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitLimitInstructionDataCodec(): Codec<\n  SetComputeUnitLimitInstructionDataArgs,\n  SetComputeUnitLimitInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitLimitInstructionDataEncoder(),\n    getSetComputeUnitLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitLimitInput = {\n  units: SetComputeUnitLimitInstructionDataArgs['units'];\n};\n\nexport function getSetComputeUnitLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetComputeUnitLimitInstructionDataEncoder().encode(\n      args as SetComputeUnitLimitInstructionDataArgs\n    ),\n  } as SetComputeUnitLimitInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetComputeUnitLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitLimitInstructionData;\n};\n\nexport function parseSetComputeUnitLimitInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetComputeUnitLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR = 3;\n\nexport function getSetComputeUnitPriceDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR);\n}\n\nexport type SetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetComputeUnitPriceInstructionData = {\n  discriminator: number;\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: bigint;\n};\n\nexport type SetComputeUnitPriceInstructionDataArgs = {\n  /** Transaction compute unit price used for prioritization fees. */\n  microLamports: number | bigint;\n};\n\nexport function getSetComputeUnitPriceInstructionDataEncoder(): Encoder<SetComputeUnitPriceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['microLamports', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COMPUTE_UNIT_PRICE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetComputeUnitPriceInstructionDataDecoder(): Decoder<SetComputeUnitPriceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['microLamports', getU64Decoder()],\n  ]);\n}\n\nexport function getSetComputeUnitPriceInstructionDataCodec(): Codec<\n  SetComputeUnitPriceInstructionDataArgs,\n  SetComputeUnitPriceInstructionData\n> {\n  return combineCodec(\n    getSetComputeUnitPriceInstructionDataEncoder(),\n    getSetComputeUnitPriceInstructionDataDecoder()\n  );\n}\n\nexport type SetComputeUnitPriceInput = {\n  microLamports: SetComputeUnitPriceInstructionDataArgs['microLamports'];\n};\n\nexport function getSetComputeUnitPriceInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetComputeUnitPriceInput,\n  config?: { programAddress?: TProgramAddress }\n): SetComputeUnitPriceInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetComputeUnitPriceInstructionDataEncoder().encode(\n      args as SetComputeUnitPriceInstructionDataArgs\n    ),\n  } as SetComputeUnitPriceInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetComputeUnitPriceInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetComputeUnitPriceInstructionData;\n};\n\nexport function parseSetComputeUnitPriceInstruction<TProgram extends string>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetComputeUnitPriceInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetComputeUnitPriceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n} from '@solana/kit';\nimport { COMPUTE_BUDGET_PROGRAM_ADDRESS } from '../programs';\n\nexport const SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR = 4;\n\nexport function getSetLoadedAccountsDataSizeLimitDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<TRemainingAccounts>;\n\nexport type SetLoadedAccountsDataSizeLimitInstructionData = {\n  discriminator: number;\n  accountDataSizeLimit: number;\n};\n\nexport type SetLoadedAccountsDataSizeLimitInstructionDataArgs = {\n  accountDataSizeLimit: number;\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(): Encoder<SetLoadedAccountsDataSizeLimitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['accountDataSizeLimit', getU32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_LOADED_ACCOUNTS_DATA_SIZE_LIMIT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataDecoder(): Decoder<SetLoadedAccountsDataSizeLimitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['accountDataSizeLimit', getU32Decoder()],\n  ]);\n}\n\nexport function getSetLoadedAccountsDataSizeLimitInstructionDataCodec(): Codec<\n  SetLoadedAccountsDataSizeLimitInstructionDataArgs,\n  SetLoadedAccountsDataSizeLimitInstructionData\n> {\n  return combineCodec(\n    getSetLoadedAccountsDataSizeLimitInstructionDataEncoder(),\n    getSetLoadedAccountsDataSizeLimitInstructionDataDecoder()\n  );\n}\n\nexport type SetLoadedAccountsDataSizeLimitInput = {\n  accountDataSizeLimit: SetLoadedAccountsDataSizeLimitInstructionDataArgs['accountDataSizeLimit'];\n};\n\nexport function getSetLoadedAccountsDataSizeLimitInstruction<\n  TProgramAddress extends Address = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n>(\n  input: SetLoadedAccountsDataSizeLimitInput,\n  config?: { programAddress?: TProgramAddress }\n): SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\n  // Original args.\n  const args = { ...input };\n\n  const instruction = {\n    programAddress,\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataEncoder().encode(\n      args as SetLoadedAccountsDataSizeLimitInstructionDataArgs\n    ),\n  } as SetLoadedAccountsDataSizeLimitInstruction<TProgramAddress>;\n\n  return instruction;\n}\n\nexport type ParsedSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string = typeof COMPUTE_BUDGET_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: SetLoadedAccountsDataSizeLimitInstructionData;\n};\n\nexport function parseSetLoadedAccountsDataSizeLimitInstruction<\n  TProgram extends string,\n>(\n  instruction: IInstruction<TProgram> & IInstructionWithData<Uint8Array>\n): ParsedSetLoadedAccountsDataSizeLimitInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getSetLoadedAccountsDataSizeLimitInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * A provisory compute unit limit is used to indicate that the transaction\n * should be estimated for compute units before being sent to the network.\n *\n * Setting it to zero ensures the transaction fails unless it is properly estimated.\n */\nexport const PROVISORY_COMPUTE_UNIT_LIMIT = 0;\n\n/**\n * The maximum compute unit limit that can be set for a transaction.\n */\nexport const MAX_COMPUTE_UNIT_LIMIT = 1_400_000;\n","import {\n  BaseTransactionMessage,\n  getU32Decoder,\n  getU64Decoder,\n  IInstruction,\n  MicroLamports,\n  ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  ComputeBudgetInstruction,\n  identifyComputeBudgetInstruction,\n  SetComputeUnitLimitInstruction,\n  SetComputeUnitPriceInstruction,\n} from './generated';\n\n/**\n * Finds the index of the first `SetComputeUnitLimit` instruction in a transaction message\n * and its set limit, if any.\n */\nexport function getSetComputeUnitLimitInstructionIndexAndUnits(\n  transactionMessage: BaseTransactionMessage\n): { index: number; units: number } | null {\n  const index = getSetComputeUnitLimitInstructionIndex(transactionMessage);\n  if (index < 0) {\n    return null;\n  }\n\n  const units = getU32Decoder().decode(\n    transactionMessage.instructions[index].data as ReadonlyUint8Array,\n    1\n  );\n\n  return { index, units };\n}\n\n/**\n * Finds the index of the first `SetComputeUnitLimit` instruction in a transaction message, if any.\n */\nexport function getSetComputeUnitLimitInstructionIndex(\n  transactionMessage: BaseTransactionMessage\n) {\n  return transactionMessage.instructions.findIndex(\n    isSetComputeUnitLimitInstruction\n  );\n}\n\n/**\n * Checks if the given instruction is a `SetComputeUnitLimit` instruction.\n */\nexport function isSetComputeUnitLimitInstruction(\n  instruction: IInstruction\n): instruction is SetComputeUnitLimitInstruction {\n  return (\n    instruction.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS &&\n    identifyComputeBudgetInstruction(instruction.data as Uint8Array) ===\n      ComputeBudgetInstruction.SetComputeUnitLimit\n  );\n}\n\n/**\n * Finds the index of the first `SetComputeUnitPrice` instruction in a transaction message\n * and its set micro-lamports, if any.\n */\nexport function getSetComputeUnitPriceInstructionIndexAndMicroLamports(\n  transactionMessage: BaseTransactionMessage\n): { index: number; microLamports: MicroLamports } | null {\n  const index = getSetComputeUnitPriceInstructionIndex(transactionMessage);\n  if (index < 0) {\n    return null;\n  }\n\n  const microLamports = getU64Decoder().decode(\n    transactionMessage.instructions[index].data as ReadonlyUint8Array,\n    1\n  ) as MicroLamports;\n\n  return { index, microLamports };\n}\n\n/**\n * Finds the index of the first `SetComputeUnitPrice` instruction in a transaction message, if any.\n */\nexport function getSetComputeUnitPriceInstructionIndex(\n  transactionMessage: BaseTransactionMessage\n) {\n  return transactionMessage.instructions.findIndex(\n    isSetComputeUnitPriceInstruction\n  );\n}\n\n/**\n * Checks if the given instruction is a `SetComputeUnitPrice` instruction.\n */\nexport function isSetComputeUnitPriceInstruction(\n  instruction: IInstruction\n): instruction is SetComputeUnitPriceInstruction {\n  return (\n    instruction.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS &&\n    identifyComputeBudgetInstruction(instruction.data as Uint8Array) ===\n      ComputeBudgetInstruction.SetComputeUnitPrice\n  );\n}\n","import {\n  appendTransactionMessageInstruction,\n  BaseTransactionMessage,\n} from '@solana/kit';\nimport { PROVISORY_COMPUTE_UNIT_LIMIT } from './constants';\nimport { getSetComputeUnitLimitInstruction } from './generated';\nimport { getSetComputeUnitLimitInstructionIndexAndUnits } from './internal';\n\n/**\n * Appends a `SetComputeUnitLimit` instruction with a provisory\n * compute unit limit to a given transaction message\n * if and only if it does not already have one.\n *\n * @example\n * ```ts\n * const transactionMessage = pipe(\n *   createTransactionMessage({ version: 0 }),\n *   fillProvisorySetComputeUnitLimitInstruction,\n *   // ...\n * );\n * ```\n */\nexport function fillProvisorySetComputeUnitLimitInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(transactionMessage: TTransactionMessage) {\n  return updateOrAppendSetComputeUnitLimitInstruction(\n    (previousUnits) =>\n      previousUnits === null ? PROVISORY_COMPUTE_UNIT_LIMIT : previousUnits,\n    transactionMessage\n  );\n}\n\n/**\n * Updates the first `SetComputeUnitLimit` instruction in a transaction message\n * with the given units, or appends a new instruction if none exists.\n * A function of the current value can be provided instead of a static value.\n *\n * @param units - The new compute unit limit, or a function that takes the previous\n *                compute unit limit and returns the new limit.\n * @param transactionMessage - The transaction message to update.\n *\n * @example\n * ```ts\n * const updatedTransactionMessage = updateOrAppendSetComputeUnitLimitInstruction(\n *   // E.g. Keep the current limit if it is set, otherwise set it to the maximum.\n *   (currentUnits) => currentUnits === null ? MAX_COMPUTE_UNIT_LIMIT : currentUnits,\n *   transactionMessage,\n * );\n * ```\n */\nexport function updateOrAppendSetComputeUnitLimitInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  units: number | ((previousUnits: number | null) => number),\n  transactionMessage: TTransactionMessage\n): TTransactionMessage {\n  const getUnits = (previousUnits: number | null): number =>\n    typeof units === 'function' ? units(previousUnits) : units;\n  const instructionDetails =\n    getSetComputeUnitLimitInstructionIndexAndUnits(transactionMessage);\n\n  if (!instructionDetails) {\n    return appendTransactionMessageInstruction(\n      getSetComputeUnitLimitInstruction({ units: getUnits(null) }),\n      transactionMessage\n    );\n  }\n\n  const { index, units: previousUnits } = instructionDetails;\n  const newUnits = getUnits(previousUnits);\n  if (newUnits === previousUnits) {\n    return transactionMessage;\n  }\n\n  const newInstruction = getSetComputeUnitLimitInstruction({ units: newUnits });\n  const newInstructions = [...transactionMessage.instructions];\n  newInstructions.splice(index, 1, newInstruction);\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: newInstructions,\n  });\n}\n","import {\n  CompilableTransactionMessage,\n  ITransactionMessageWithFeePayer,\n  TransactionMessage,\n} from '@solana/kit';\nimport {\n  MAX_COMPUTE_UNIT_LIMIT,\n  PROVISORY_COMPUTE_UNIT_LIMIT,\n} from './constants';\nimport {\n  EstimateComputeUnitLimitFactoryFunction,\n  EstimateComputeUnitLimitFactoryFunctionConfig,\n} from './estimateComputeLimitInternal';\nimport { getSetComputeUnitLimitInstructionIndexAndUnits } from './internal';\nimport { updateOrAppendSetComputeUnitLimitInstruction } from './setComputeLimit';\n\ntype EstimateAndUpdateProvisoryComputeUnitLimitFactoryFunction = <\n  TTransactionMessage extends\n    | CompilableTransactionMessage\n    | (TransactionMessage & ITransactionMessageWithFeePayer),\n>(\n  transactionMessage: TTransactionMessage,\n  config?: EstimateComputeUnitLimitFactoryFunctionConfig\n) => Promise<TTransactionMessage>;\n\n/**\n * Given a transaction message, if it does not have an explicit compute unit limit,\n * estimates the compute unit limit and updates the transaction message with\n * the estimated limit. Otherwise, returns the transaction message unchanged.\n *\n * It requires a function that estimates the compute unit limit.\n *\n * @example\n * ```ts\n * const estimateAndUpdateCUs = estimateAndUpdateProvisoryComputeUnitLimitFactory(\n *     estimateComputeUnitLimitFactory({ rpc })\n * );\n *\n * const transactionMessageWithCUs = await estimateAndUpdateCUs(transactionMessage);\n * ```\n *\n * @see {@link estimateAndUpdateProvisoryComputeUnitLimitFactory}\n */\nexport function estimateAndUpdateProvisoryComputeUnitLimitFactory(\n  estimateComputeUnitLimit: EstimateComputeUnitLimitFactoryFunction\n): EstimateAndUpdateProvisoryComputeUnitLimitFactoryFunction {\n  return async function fn(transactionMessage, config) {\n    const instructionDetails =\n      getSetComputeUnitLimitInstructionIndexAndUnits(transactionMessage);\n\n    // If the transaction message already has a compute unit limit instruction\n    // which is set to a specific value — i.e. not 0 or the maximum limit —\n    // we don't need to estimate the compute unit limit.\n    if (\n      instructionDetails &&\n      instructionDetails.units !== PROVISORY_COMPUTE_UNIT_LIMIT &&\n      instructionDetails.units !== MAX_COMPUTE_UNIT_LIMIT\n    ) {\n      return transactionMessage;\n    }\n\n    return updateOrAppendSetComputeUnitLimitInstruction(\n      await estimateComputeUnitLimit(transactionMessage, config),\n      transactionMessage\n    );\n  };\n}\n","// TODO: Add these helpers to @solana/kit in v3.\n\nimport {\n  BaseTransactionMessage,\n  Blockhash,\n  setTransactionMessageLifetimeUsingBlockhash,\n  TransactionMessageWithBlockhashLifetime,\n  TransactionMessageWithDurableNonceLifetime,\n} from '@solana/kit';\n\n/**\n * An invalid blockhash lifetime constraint used as a placeholder for\n * transaction messages that are not yet ready to be compiled.\n *\n * This enables various operations on the transaction message, such as\n * simulating it or calculating its transaction size, whilst defering\n * the actual blockhash to a later stage.\n */\nexport const PROVISORY_BLOCKHASH_LIFETIME_CONSTRAINT: TransactionMessageWithBlockhashLifetime['lifetimeConstraint'] =\n  {\n    blockhash: '11111111111111111111111111111111' as Blockhash,\n    lastValidBlockHeight: 0n, // This is not included in compiled transactions; it can be anything.\n  };\n\n/**\n * Sets a provisory blockhash lifetime constraint on the transaction message\n * if and only if it doesn't already have a lifetime constraint.\n */\nexport function fillMissingTransactionMessageLifetimeUsingProvisoryBlockhash<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  transactionMessage: TTransactionMessage\n): TTransactionMessage &\n  (\n    | TransactionMessageWithBlockhashLifetime\n    | TransactionMessageWithDurableNonceLifetime\n  ) {\n  type ReturnType = TTransactionMessage &\n    (\n      | TransactionMessageWithBlockhashLifetime\n      | TransactionMessageWithDurableNonceLifetime\n    );\n\n  if ('lifetimeConstraint' in transactionMessage) {\n    return transactionMessage as ReturnType;\n  }\n\n  return setTransactionMessageLifetimeUsingProvisoryBlockhash(\n    transactionMessage\n  );\n}\n\n/**\n * Sets a provisory blockhash lifetime constraint on the transaction message.\n */\nexport function setTransactionMessageLifetimeUsingProvisoryBlockhash<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  transactionMessage: TTransactionMessage\n): TTransactionMessage & TransactionMessageWithBlockhashLifetime {\n  return setTransactionMessageLifetimeUsingBlockhash(\n    PROVISORY_BLOCKHASH_LIFETIME_CONSTRAINT,\n    transactionMessage\n  );\n}\n","import {\n  Commitment,\n  CompilableTransactionMessage,\n  compileTransaction,\n  getBase64EncodedWireTransaction,\n  isDurableNonceTransaction,\n  isSolanaError,\n  ITransactionMessageWithFeePayer,\n  pipe,\n  Rpc,\n  SimulateTransactionApi,\n  Slot,\n  SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n  SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n  SolanaError,\n  Transaction,\n  TransactionMessage,\n} from '@solana/kit';\nimport { updateOrAppendSetComputeUnitLimitInstruction } from './setComputeLimit';\nimport { MAX_COMPUTE_UNIT_LIMIT } from './constants';\nimport { fillMissingTransactionMessageLifetimeUsingProvisoryBlockhash } from './internalMoveToKit';\n\nexport type EstimateComputeUnitLimitFactoryConfig = Readonly<{\n  /** An object that supports the {@link SimulateTransactionApi} of the Solana RPC API */\n  rpc: Rpc<SimulateTransactionApi>;\n}>;\n\nexport type EstimateComputeUnitLimitFactoryFunction = (\n  transactionMessage:\n    | CompilableTransactionMessage\n    | (TransactionMessage & ITransactionMessageWithFeePayer),\n  config?: EstimateComputeUnitLimitFactoryFunctionConfig\n) => Promise<number>;\n\nexport type EstimateComputeUnitLimitFactoryFunctionConfig = {\n  abortSignal?: AbortSignal;\n  /**\n   * Compute the estimate as of the highest slot that has reached this level of commitment.\n   *\n   * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n   * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n   * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n   * default commitment applied by the server is `\"finalized\"`.\n   */\n  commitment?: Commitment;\n  /**\n   * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n   * this slot\n   */\n  minContextSlot?: Slot;\n};\n\ntype EstimateComputeUnitLimitConfig =\n  EstimateComputeUnitLimitFactoryFunctionConfig &\n    Readonly<{\n      rpc: Rpc<SimulateTransactionApi>;\n      transactionMessage:\n        | CompilableTransactionMessage\n        | (TransactionMessage & ITransactionMessageWithFeePayer);\n    }>;\n\n/**\n * Simulates a transaction message on the network and returns the number of compute units it\n * consumed during simulation.\n *\n * The estimate this function returns can be used to set a compute unit limit on the transaction.\n * Correctly budgeting a compute unit limit for your transaction message can increase the probability\n * that your transaction will be accepted for processing.\n *\n * If you don't declare a compute unit limit on your transaction, validators will assume an upper\n * limit of 200K compute units (CU) per instruction. Since validators have an incentive to pack as\n * many transactions into each block as possible, they may choose to include transactions that they\n * know will fit into the remaining compute budget for the current block over transactions that\n * might not. For this reason, you should set a compute unit limit on each of your transaction\n * messages, whenever possible.\n *\n * ## Example\n *\n * ```ts\n * import { getSetComputeLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, getComputeUnitEstimateForTransactionMessageFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const getComputeUnitEstimateForTransactionMessage =\n *     getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume.\n * const computeUnitsEstimate =\n *     await getComputeUnitEstimateForTransactionMessage(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeLimitInstruction({ units: computeUnitsEstimate }),\n *     transactionMessage,\n * );\n * ```\n *\n * > [!WARNING]\n * > The compute unit estimate is just that &ndash; an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n */\nexport async function estimateComputeUnitLimit({\n  transactionMessage,\n  ...configs\n}: EstimateComputeUnitLimitConfig): Promise<number> {\n  const replaceRecentBlockhash = !isDurableNonceTransaction(transactionMessage);\n  const transaction = pipe(\n    transactionMessage,\n    fillMissingTransactionMessageLifetimeUsingProvisoryBlockhash,\n    (m) =>\n      updateOrAppendSetComputeUnitLimitInstruction(MAX_COMPUTE_UNIT_LIMIT, m),\n    compileTransaction\n  );\n\n  return await simulateTransactionAndGetConsumedUnits({\n    transaction,\n    replaceRecentBlockhash,\n    ...configs,\n  });\n}\n\ntype SimulateTransactionAndGetConsumedUnitsConfig = Omit<\n  EstimateComputeUnitLimitConfig,\n  'transactionMessage'\n> &\n  Readonly<{ replaceRecentBlockhash?: boolean; transaction: Transaction }>;\n\nasync function simulateTransactionAndGetConsumedUnits({\n  abortSignal,\n  rpc,\n  transaction,\n  ...simulateConfig\n}: SimulateTransactionAndGetConsumedUnitsConfig): Promise<number> {\n  const wireTransactionBytes = getBase64EncodedWireTransaction(transaction);\n\n  try {\n    const {\n      value: { err: transactionError, unitsConsumed },\n    } = await rpc\n      .simulateTransaction(wireTransactionBytes, {\n        ...simulateConfig,\n        encoding: 'base64',\n        sigVerify: false,\n      })\n      .send({ abortSignal });\n    if (unitsConsumed == null) {\n      // This should never be hit, because all RPCs should support `unitsConsumed` by now.\n      throw new SolanaError(\n        SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n      );\n    }\n    // FIXME(https://github.com/anza-xyz/agave/issues/1295): The simulation response returns\n    // compute units as a u64, but the `SetComputeLimit` instruction only accepts a u32. Until\n    // this changes, downcast it.\n    const downcastUnitsConsumed =\n      unitsConsumed > 4_294_967_295n ? 4_294_967_295 : Number(unitsConsumed);\n    if (transactionError) {\n      throw new SolanaError(\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n        {\n          cause: transactionError,\n          unitsConsumed: downcastUnitsConsumed,\n        }\n      );\n    }\n    return downcastUnitsConsumed;\n  } catch (e) {\n    if (\n      isSolanaError(\n        e,\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n      )\n    )\n      throw e;\n    throw new SolanaError(\n      SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n      { cause: e }\n    );\n  }\n}\n","import {\n  estimateComputeUnitLimit,\n  EstimateComputeUnitLimitFactoryConfig,\n  EstimateComputeUnitLimitFactoryFunction,\n} from './estimateComputeLimitInternal';\n\n/**\n * Use this utility to estimate the actual compute unit cost of a given transaction message.\n *\n * Correctly budgeting a compute unit limit for your transaction message can increase the\n * probability that your transaction will be accepted for processing. If you don't declare a compute\n * unit limit on your transaction, validators will assume an upper limit of 200K compute units (CU)\n * per instruction.\n *\n * Since validators have an incentive to pack as many transactions into each block as possible, they\n * may choose to include transactions that they know will fit into the remaining compute budget for\n * the current block over transactions that might not. For this reason, you should set a compute\n * unit limit on each of your transaction messages, whenever possible.\n *\n * > [!WARNING]\n * > The compute unit estimate is just that -- an estimate. The compute unit consumption of the\n * > actual transaction might be higher or lower than what was observed in simulation. Unless you\n * > are confident that your particular transaction message will consume the same or fewer compute\n * > units as was estimated, you might like to augment the estimate by either a fixed number of CUs\n * > or a multiplier.\n *\n * > [!NOTE]\n * > If you are preparing an _unsigned_ transaction, destined to be signed and submitted to the\n * > network by a wallet, you might like to leave it up to the wallet to determine the compute unit\n * > limit. Consider that the wallet might have a more global view of how many compute units certain\n * > types of transactions consume, and might be able to make better estimates of an appropriate\n * > compute unit budget.\n *\n * > [!INFO]\n * > In the event that a transaction message does not already have a `SetComputeUnitLimit`\n * > instruction, this function will add one before simulation. This ensures that the compute unit\n * > consumption of the `SetComputeUnitLimit` instruction itself is included in the estimate.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getSetComputeUnitLimitInstruction } from '@solana-program/compute-budget';\n * import { createSolanaRpc, estimateComputeUnitLimitFactory, pipe } from '@solana/kit';\n *\n * // Create an estimator function.\n * const rpc = createSolanaRpc('http://127.0.0.1:8899');\n * const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n *\n * // Create your transaction message.\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 'legacy' }),\n *     /* ... *\\/\n * );\n *\n * // Request an estimate of the actual compute units this message will consume. This is done by\n * // simulating the transaction and grabbing the estimated compute units from the result.\n * const estimatedUnits = await estimateComputeUnitLimit(transactionMessage);\n *\n * // Set the transaction message's compute unit budget.\n * const transactionMessageWithComputeUnitLimit = prependTransactionMessageInstruction(\n *     getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n *     transactionMessage,\n * );\n * ```\n */\nexport function estimateComputeUnitLimitFactory({\n  rpc,\n}: EstimateComputeUnitLimitFactoryConfig): EstimateComputeUnitLimitFactoryFunction {\n  return async function estimateComputeUnitLimitFactoryFunction(\n    transactionMessage,\n    config\n  ) {\n    return await estimateComputeUnitLimit({\n      ...config,\n      rpc,\n      transactionMessage,\n    });\n  };\n}\n","import {\n  appendTransactionMessageInstruction,\n  BaseTransactionMessage,\n  MicroLamports,\n} from '@solana/kit';\nimport { getSetComputeUnitPriceInstruction } from './generated';\nimport { getSetComputeUnitPriceInstructionIndexAndMicroLamports } from './internal';\n\n/**\n * Sets the compute unit price of a transaction message in micro-Lamports.\n *\n * @example\n * ```ts\n * const transactionMessage = pipe(\n *   createTransactionMessage({ version: 0 }),\n *   (m) => setTransactionMessageComputeUnitPrice(10_000, m),\n *   // ...\n * );\n * ```\n */\nexport function setTransactionMessageComputeUnitPrice<\n  TTransactionMessage extends BaseTransactionMessage,\n>(microLamports: number | bigint, transactionMessage: TTransactionMessage) {\n  return appendTransactionMessageInstruction(\n    getSetComputeUnitPriceInstruction({ microLamports }),\n    transactionMessage\n  );\n}\n\n/**\n * Updates the first `SetComputeUnitPrice` instruction in a transaction message\n * with the given micro-Lamports, or appends a new instruction if none exists.\n * A function of the current value can be provided instead of a static value.\n *\n * @param microLamports - The new compute unit price, or a function that\n *                        takes the previous price and returns the new one.\n * @param transactionMessage - The transaction message to update.\n *\n * @example\n * ```ts\n * const updatedTransactionMessage = updateOrAppendSetComputeUnitPriceInstruction(\n *   // E.g. double the current price or set it to 10_000 if it isn't set.\n *   (currentPrice) => currentPrice === null ? 10_000 : currentPrice * 2,\n *   transactionMessage,\n * );\n * ```\n */\nexport function updateOrAppendSetComputeUnitPriceInstruction<\n  TTransactionMessage extends BaseTransactionMessage,\n>(\n  microLamports:\n    | MicroLamports\n    | ((previousMicroLamports: MicroLamports | null) => MicroLamports),\n  transactionMessage: TTransactionMessage\n): TTransactionMessage {\n  const getMicroLamports = (\n    previousMicroLamports: MicroLamports | null\n  ): MicroLamports =>\n    typeof microLamports === 'function'\n      ? microLamports(previousMicroLamports)\n      : microLamports;\n  const instructionDetails =\n    getSetComputeUnitPriceInstructionIndexAndMicroLamports(transactionMessage);\n\n  if (!instructionDetails) {\n    return appendTransactionMessageInstruction(\n      getSetComputeUnitPriceInstruction({\n        microLamports: getMicroLamports(null),\n      }),\n      transactionMessage\n    );\n  }\n\n  const { index, microLamports: previousMicroLamports } = instructionDetails;\n  const newMicroLamports = getMicroLamports(previousMicroLamports);\n  if (newMicroLamports === previousMicroLamports) {\n    return transactionMessage;\n  }\n\n  const newInstruction = getSetComputeUnitPriceInstruction({\n    microLamports: newMicroLamports,\n  });\n  const newInstructions = [...transactionMessage.instructions];\n  newInstructions.splice(index, 1, newInstruction);\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: newInstructions,\n  });\n}\n"],"names":["ComputeBudgetInstruction","getU8Encoder","transformEncoder","getStructEncoder","getU32Encoder","getStructDecoder","getU8Decoder","getU32Decoder","combineCodec","getU64Decoder","previousUnits","estimateComputeUnitLimit","appendTransactionMessageInstruction","previousMicroLamports"],"mappings":"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","debugId":null}},
    {"offset": {"line": 535, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@solana-program/system/dist/src/index.mjs","sources":["file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/types/nonceState.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/types/nonceVersion.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/accounts/nonce.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/programs/system.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/errors/system.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/shared/index.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/advanceNonceAccount.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/allocate.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/allocateWithSeed.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/assign.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/assignWithSeed.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/authorizeNonceAccount.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/createAccount.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/createAccountWithSeed.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/initializeNonceAccount.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/transferSol.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/transferSolWithSeed.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/upgradeNonceAccount.ts","file:///Users/sunqq/Work/solana/qq-solana-dapp/curd-dapp/app/node_modules/%40solana-program/system/src/generated/instructions/withdrawNonceAccount.ts"],"sourcesContent":["/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum NonceState {\n  Uninitialized,\n  Initialized,\n}\n\nexport type NonceStateArgs = NonceState;\n\nexport function getNonceStateEncoder(): Encoder<NonceStateArgs> {\n  return getEnumEncoder(NonceState, { size: getU32Encoder() });\n}\n\nexport function getNonceStateDecoder(): Decoder<NonceState> {\n  return getEnumDecoder(NonceState, { size: getU32Decoder() });\n}\n\nexport function getNonceStateCodec(): Codec<NonceStateArgs, NonceState> {\n  return combineCodec(getNonceStateEncoder(), getNonceStateDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum NonceVersion {\n  Legacy,\n  Current,\n}\n\nexport type NonceVersionArgs = NonceVersion;\n\nexport function getNonceVersionEncoder(): Encoder<NonceVersionArgs> {\n  return getEnumEncoder(NonceVersion, { size: getU32Encoder() });\n}\n\nexport function getNonceVersionDecoder(): Decoder<NonceVersion> {\n  return getEnumDecoder(NonceVersion, { size: getU32Decoder() });\n}\n\nexport function getNonceVersionCodec(): Codec<NonceVersionArgs, NonceVersion> {\n  return combineCodec(getNonceVersionEncoder(), getNonceVersionDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\nimport {\n  getNonceStateDecoder,\n  getNonceStateEncoder,\n  getNonceVersionDecoder,\n  getNonceVersionEncoder,\n  type NonceState,\n  type NonceStateArgs,\n  type NonceVersion,\n  type NonceVersionArgs,\n} from '../types';\n\nexport type Nonce = {\n  version: NonceVersion;\n  state: NonceState;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: bigint;\n};\n\nexport type NonceArgs = {\n  version: NonceVersionArgs;\n  state: NonceStateArgs;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: number | bigint;\n};\n\nexport function getNonceEncoder(): Encoder<NonceArgs> {\n  return getStructEncoder([\n    ['version', getNonceVersionEncoder()],\n    ['state', getNonceStateEncoder()],\n    ['authority', getAddressEncoder()],\n    ['blockhash', getAddressEncoder()],\n    ['lamportsPerSignature', getU64Encoder()],\n  ]);\n}\n\nexport function getNonceDecoder(): Decoder<Nonce> {\n  return getStructDecoder([\n    ['version', getNonceVersionDecoder()],\n    ['state', getNonceStateDecoder()],\n    ['authority', getAddressDecoder()],\n    ['blockhash', getAddressDecoder()],\n    ['lamportsPerSignature', getU64Decoder()],\n  ]);\n}\n\nexport function getNonceCodec(): Codec<NonceArgs, Nonce> {\n  return combineCodec(getNonceEncoder(), getNonceDecoder());\n}\n\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Nonce, TAddress> | MaybeAccount<Nonce, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getNonceDecoder()\n  );\n}\n\nexport async function fetchNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Nonce, TAddress>> {\n  const maybeAccount = await fetchMaybeNonce(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Nonce, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeNonce(maybeAccount);\n}\n\nexport async function fetchAllNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Nonce>[]> {\n  const maybeAccounts = await fetchAllMaybeNonce(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Nonce>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeNonce(maybeAccount));\n}\n\nexport function getNonceSize(): number {\n  return 80;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU32Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAdvanceNonceAccountInstruction,\n  type ParsedAllocateInstruction,\n  type ParsedAllocateWithSeedInstruction,\n  type ParsedAssignInstruction,\n  type ParsedAssignWithSeedInstruction,\n  type ParsedAuthorizeNonceAccountInstruction,\n  type ParsedCreateAccountInstruction,\n  type ParsedCreateAccountWithSeedInstruction,\n  type ParsedInitializeNonceAccountInstruction,\n  type ParsedTransferSolInstruction,\n  type ParsedTransferSolWithSeedInstruction,\n  type ParsedUpgradeNonceAccountInstruction,\n  type ParsedWithdrawNonceAccountInstruction,\n} from '../instructions';\n\nexport const SYSTEM_PROGRAM_ADDRESS =\n  '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport enum SystemAccount {\n  Nonce,\n}\n\nexport enum SystemInstruction {\n  CreateAccount,\n  Assign,\n  TransferSol,\n  CreateAccountWithSeed,\n  AdvanceNonceAccount,\n  WithdrawNonceAccount,\n  InitializeNonceAccount,\n  AuthorizeNonceAccount,\n  Allocate,\n  AllocateWithSeed,\n  AssignWithSeed,\n  TransferSolWithSeed,\n  UpgradeNonceAccount,\n}\n\nexport function identifySystemInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): SystemInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU32Encoder().encode(0), 0)) {\n    return SystemInstruction.CreateAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return SystemInstruction.Assign;\n  }\n  if (containsBytes(data, getU32Encoder().encode(2), 0)) {\n    return SystemInstruction.TransferSol;\n  }\n  if (containsBytes(data, getU32Encoder().encode(3), 0)) {\n    return SystemInstruction.CreateAccountWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(4), 0)) {\n    return SystemInstruction.AdvanceNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(5), 0)) {\n    return SystemInstruction.WithdrawNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(6), 0)) {\n    return SystemInstruction.InitializeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(7), 0)) {\n    return SystemInstruction.AuthorizeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(8), 0)) {\n    return SystemInstruction.Allocate;\n  }\n  if (containsBytes(data, getU32Encoder().encode(9), 0)) {\n    return SystemInstruction.AllocateWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(10), 0)) {\n    return SystemInstruction.AssignWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(11), 0)) {\n    return SystemInstruction.TransferSolWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(12), 0)) {\n    return SystemInstruction.UpgradeNonceAccount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a system instruction.'\n  );\n}\n\nexport type ParsedSystemInstruction<\n  TProgram extends string = '11111111111111111111111111111111',\n> =\n  | ({\n      instructionType: SystemInstruction.CreateAccount;\n    } & ParsedCreateAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Assign;\n    } & ParsedAssignInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSol;\n    } & ParsedTransferSolInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.CreateAccountWithSeed;\n    } & ParsedCreateAccountWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AdvanceNonceAccount;\n    } & ParsedAdvanceNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.WithdrawNonceAccount;\n    } & ParsedWithdrawNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.InitializeNonceAccount;\n    } & ParsedInitializeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AuthorizeNonceAccount;\n    } & ParsedAuthorizeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Allocate;\n    } & ParsedAllocateInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AllocateWithSeed;\n    } & ParsedAllocateWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AssignWithSeed;\n    } & ParsedAssignWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSolWithSeed;\n    } & ParsedTransferSolWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.UpgradeNonceAccount;\n    } & ParsedUpgradeNonceAccountInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\n\n/** AccountAlreadyInUse: an account with the same address already exists */\nexport const SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0x0; // 0\n/** ResultWithNegativeLamports: account does not have enough SOL to perform the operation */\nexport const SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 0x1; // 1\n/** InvalidProgramId: cannot assign account to this program id */\nexport const SYSTEM_ERROR__INVALID_PROGRAM_ID = 0x2; // 2\n/** InvalidAccountDataLength: cannot allocate account data of this length */\nexport const SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 0x3; // 3\n/** MaxSeedLengthExceeded: length of requested seed is too long */\nexport const SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 0x4; // 4\n/** AddressWithSeedMismatch: provided address does not match addressed derived from seed */\nexport const SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 0x5; // 5\n/** NonceNoRecentBlockhashes: advancing stored nonce requires a populated RecentBlockhashes sysvar */\nexport const SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 0x6; // 6\n/** NonceBlockhashNotExpired: stored nonce is still in recent_blockhashes */\nexport const SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 0x7; // 7\n/** NonceUnexpectedBlockhashValue: specified nonce does not match stored nonce */\nexport const SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 0x8; // 8\n\nexport type SystemError =\n  | typeof SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE\n  | typeof SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH\n  | typeof SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH\n  | typeof SYSTEM_ERROR__INVALID_PROGRAM_ID\n  | typeof SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED\n  | typeof SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED\n  | typeof SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES\n  | typeof SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE\n  | typeof SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS;\n\nlet systemErrorMessages: Record<SystemError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  systemErrorMessages = {\n    [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,\n    [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,\n    [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,\n    [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,\n    [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,\n    [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,\n    [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,\n    [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,\n    [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`,\n  };\n}\n\nexport function getSystemErrorMessage(code: SystemError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (systemErrorMessages as Record<SystemError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isSystemError<TProgramErrorCode extends SystemError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    SYSTEM_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type Address,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR = 4;\n\nexport function getAdvanceNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountNonceAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            IAccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AdvanceNonceAccountInstructionData = { discriminator: number };\n\nexport type AdvanceNonceAccountInstructionDataArgs = {};\n\nexport function getAdvanceNonceAccountInstructionDataEncoder(): Encoder<AdvanceNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAdvanceNonceAccountInstructionDataDecoder(): Decoder<AdvanceNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getAdvanceNonceAccountInstructionDataCodec(): Codec<\n  AdvanceNonceAccountInstructionDataArgs,\n  AdvanceNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAdvanceNonceAccountInstructionDataEncoder(),\n    getAdvanceNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AdvanceNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n};\n\nexport function getAdvanceNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AdvanceNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AdvanceNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getAdvanceNonceAccountInstructionDataEncoder().encode({}),\n  } as AdvanceNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    nonceAuthority: TAccountMetas[2];\n  };\n  data: AdvanceNonceAccountInstructionData;\n};\n\nexport function parseAdvanceNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAdvanceNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAdvanceNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_DISCRIMINATOR = 8;\n\nexport function getAllocateDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_DISCRIMINATOR);\n}\n\nexport type AllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            IAccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateInstructionData = { discriminator: number; space: bigint };\n\nexport type AllocateInstructionDataArgs = { space: number | bigint };\n\nexport function getAllocateInstructionDataEncoder(): Encoder<AllocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['space', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateInstructionDataDecoder(): Decoder<AllocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['space', getU64Decoder()],\n  ]);\n}\n\nexport function getAllocateInstructionDataCodec(): Codec<\n  AllocateInstructionDataArgs,\n  AllocateInstructionData\n> {\n  return combineCodec(\n    getAllocateInstructionDataEncoder(),\n    getAllocateInstructionDataDecoder()\n  );\n}\n\nexport type AllocateInput<TAccountNewAccount extends string = string> = {\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  space: AllocateInstructionDataArgs['space'];\n};\n\nexport function getAllocateInstruction<\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateInput<TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateInstruction<TProgramAddress, TAccountNewAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.newAccount)],\n    programAddress,\n    data: getAllocateInstructionDataEncoder().encode(\n      args as AllocateInstructionDataArgs\n    ),\n  } as AllocateInstruction<TProgramAddress, TAccountNewAccount>;\n\n  return instruction;\n}\n\nexport type ParsedAllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n  };\n  data: AllocateInstructionData;\n};\n\nexport function parseAllocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAllocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      newAccount: getNextAccount(),\n    },\n    data: getAllocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_WITH_SEED_DISCRIMINATOR = 9;\n\nexport function getAllocateWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type AllocateWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getAllocateWithSeedInstructionDataEncoder(): Encoder<AllocateWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateWithSeedInstructionDataDecoder(): Decoder<AllocateWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAllocateWithSeedInstructionDataCodec(): Codec<\n  AllocateWithSeedInstructionDataArgs,\n  AllocateWithSeedInstructionData\n> {\n  return combineCodec(\n    getAllocateWithSeedInstructionDataEncoder(),\n    getAllocateWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AllocateWithSeedInput<\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AllocateWithSeedInstructionDataArgs['base'];\n  seed: AllocateWithSeedInstructionDataArgs['seed'];\n  space: AllocateWithSeedInstructionDataArgs['space'];\n  programAddress: AllocateWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAllocateWithSeedInstruction<\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateWithSeedInput<TAccountNewAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateWithSeedInstruction<\n  TProgramAddress,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getAllocateWithSeedInstructionDataEncoder().encode(\n      args as AllocateWithSeedInstructionDataArgs\n    ),\n  } as AllocateWithSeedInstruction<\n    TProgramAddress,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AllocateWithSeedInstructionData;\n};\n\nexport function parseAllocateWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAllocateWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      newAccount: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getAllocateWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_DISCRIMINATOR = 1;\n\nexport function getAssignDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_DISCRIMINATOR);\n}\n\nexport type AssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableSignerAccount<TAccountAccount> &\n            IAccountSignerMeta<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignInstructionData = {\n  discriminator: number;\n  programAddress: Address;\n};\n\nexport type AssignInstructionDataArgs = { programAddress: Address };\n\nexport function getAssignInstructionDataEncoder(): Encoder<AssignInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignInstructionDataDecoder(): Decoder<AssignInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignInstructionDataCodec(): Codec<\n  AssignInstructionDataArgs,\n  AssignInstructionData\n> {\n  return combineCodec(\n    getAssignInstructionDataEncoder(),\n    getAssignInstructionDataDecoder()\n  );\n}\n\nexport type AssignInput<TAccountAccount extends string = string> = {\n  account: TransactionSigner<TAccountAccount>;\n  programAddress: AssignInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getAssignInstructionDataEncoder().encode(\n      args as AssignInstructionDataArgs\n    ),\n  } as AssignInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedAssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n  };\n  data: AssignInstructionData;\n};\n\nexport function parseAssignInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssignInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getAssignInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_WITH_SEED_DISCRIMINATOR = 10;\n\nexport function getAssignWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport type AssignWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport function getAssignWithSeedInstructionDataEncoder(): Encoder<AssignWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignWithSeedInstructionDataDecoder(): Decoder<AssignWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignWithSeedInstructionDataCodec(): Codec<\n  AssignWithSeedInstructionDataArgs,\n  AssignWithSeedInstructionData\n> {\n  return combineCodec(\n    getAssignWithSeedInstructionDataEncoder(),\n    getAssignWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AssignWithSeedInput<\n  TAccountAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  account: Address<TAccountAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AssignWithSeedInstructionDataArgs['base'];\n  seed: AssignWithSeedInstructionDataArgs['seed'];\n  programAddress: AssignWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignWithSeedInstruction<\n  TAccountAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignWithSeedInput<TAccountAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignWithSeedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getAssignWithSeedInstructionDataEncoder().encode(\n      args as AssignWithSeedInstructionDataArgs\n    ),\n  } as AssignWithSeedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AssignWithSeedInstructionData;\n};\n\nexport function parseAssignWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAssignWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getAssignWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR = 7;\n\nexport function getAuthorizeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountNonceAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            IAccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeNonceAccountInstructionData = {\n  discriminator: number;\n  newNonceAuthority: Address;\n};\n\nexport type AuthorizeNonceAccountInstructionDataArgs = {\n  newNonceAuthority: Address;\n};\n\nexport function getAuthorizeNonceAccountInstructionDataEncoder(): Encoder<AuthorizeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['newNonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAuthorizeNonceAccountInstructionDataDecoder(): Decoder<AuthorizeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['newNonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getAuthorizeNonceAccountInstructionDataCodec(): Codec<\n  AuthorizeNonceAccountInstructionDataArgs,\n  AuthorizeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAuthorizeNonceAccountInstructionDataEncoder(),\n    getAuthorizeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  newNonceAuthority: AuthorizeNonceAccountInstructionDataArgs['newNonceAuthority'];\n};\n\nexport function getAuthorizeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getAuthorizeNonceAccountInstructionDataEncoder().encode(\n      args as AuthorizeNonceAccountInstructionDataArgs\n    ),\n  } as AuthorizeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    nonceAuthority: TAccountMetas[1];\n  };\n  data: AuthorizeNonceAccountInstructionData;\n};\n\nexport function parseAuthorizeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedAuthorizeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAuthorizeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  BASE_ACCOUNT_SIZE,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport {\n  getAccountMetaFactory,\n  type IInstructionWithByteDelta,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ACCOUNT_DISCRIMINATOR = 0;\n\nexport function getCreateAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            IAccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountInstructionData = {\n  discriminator: number;\n  lamports: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountInstructionDataArgs = {\n  lamports: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountInstructionDataEncoder(): Encoder<CreateAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['lamports', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: CREATE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateAccountInstructionDataDecoder(): Decoder<CreateAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['lamports', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountInstructionDataCodec(): Codec<\n  CreateAccountInstructionDataArgs,\n  CreateAccountInstructionData\n> {\n  return combineCodec(\n    getCreateAccountInstructionDataEncoder(),\n    getCreateAccountInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  lamports: CreateAccountInstructionDataArgs['lamports'];\n  space: CreateAccountInstructionDataArgs['space'];\n  programAddress: CreateAccountInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountInput<TAccountPayer, TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount\n> &\n  IInstructionWithByteDelta {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [Number(args.space) + BASE_ACCOUNT_SIZE].reduce(\n    (a, b) => a + b,\n    0\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n    ],\n    programAddress,\n    data: getCreateAccountInstructionDataEncoder().encode(\n      args as CreateAccountInstructionDataArgs\n    ),\n  } as CreateAccountInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount\n  >;\n\n  return Object.freeze({ ...instruction, byteDelta });\n}\n\nexport type ParsedCreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n  };\n  data: CreateAccountInstructionData;\n};\n\nexport function parseCreateAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      newAccount: getNextAccount(),\n    },\n    data: getCreateAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR = 3;\n\nexport function getCreateAccountWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type CreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountNewAccount extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  amount: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  amount: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountWithSeedInstructionDataEncoder(): Encoder<CreateAccountWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['amount', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAccountWithSeedInstructionDataDecoder(): Decoder<CreateAccountWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['amount', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountWithSeedInstructionDataCodec(): Codec<\n  CreateAccountWithSeedInstructionDataArgs,\n  CreateAccountWithSeedInstructionData\n> {\n  return combineCodec(\n    getCreateAccountWithSeedInstructionDataEncoder(),\n    getCreateAccountWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountWithSeedInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: CreateAccountWithSeedInstructionDataArgs['base'];\n  seed: CreateAccountWithSeedInstructionDataArgs['seed'];\n  amount: CreateAccountWithSeedInstructionDataArgs['amount'];\n  space: CreateAccountWithSeedInstructionDataArgs['space'];\n  programAddress: CreateAccountWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountWithSeedInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountWithSeedInput<\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountWithSeedInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getCreateAccountWithSeedInstructionDataEncoder().encode(\n      args as CreateAccountWithSeedInstructionDataArgs\n    ),\n  } as CreateAccountWithSeedInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n    baseAccount: TAccountMetas[2];\n  };\n  data: CreateAccountWithSeedInstructionData;\n};\n\nexport function parseCreateAccountWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateAccountWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      newAccount: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getCreateAccountWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR = 6;\n\nexport function getInitializeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonceAccountInstructionData = {\n  discriminator: number;\n  nonceAuthority: Address;\n};\n\nexport type InitializeNonceAccountInstructionDataArgs = {\n  nonceAuthority: Address;\n};\n\nexport function getInitializeNonceAccountInstructionDataEncoder(): Encoder<InitializeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['nonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonceAccountInstructionDataDecoder(): Decoder<InitializeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['nonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeNonceAccountInstructionDataCodec(): Codec<\n  InitializeNonceAccountInstructionDataArgs,\n  InitializeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeNonceAccountInstructionDataEncoder(),\n    getInitializeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: InitializeNonceAccountInstructionDataArgs['nonceAuthority'];\n};\n\nexport function getInitializeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n    ],\n    programAddress,\n    data: getInitializeNonceAccountInstructionDataEncoder().encode(\n      args as InitializeNonceAccountInstructionDataArgs\n    ),\n  } as InitializeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    rentSysvar: TAccountMetas[2];\n  };\n  data: InitializeNonceAccountInstructionData;\n};\n\nexport function parseInitializeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n    },\n    data: getInitializeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_DISCRIMINATOR = 2;\n\nexport function getTransferSolDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_DISCRIMINATOR);\n}\n\nexport type TransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableSignerAccount<TAccountSource> &\n            IAccountSignerMeta<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolInstructionData = {\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type TransferSolInstructionDataArgs = { amount: number | bigint };\n\nexport function getTransferSolInstructionDataEncoder(): Encoder<TransferSolInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_SOL_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferSolInstructionDataDecoder(): Decoder<TransferSolInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferSolInstructionDataCodec(): Codec<\n  TransferSolInstructionDataArgs,\n  TransferSolInstructionData\n> {\n  return combineCodec(\n    getTransferSolInstructionDataEncoder(),\n    getTransferSolInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: TransactionSigner<TAccountSource>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolInstructionDataArgs['amount'];\n};\n\nexport function getTransferSolInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolInput<TAccountSource, TAccountDestination>,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n    ],\n    programAddress,\n    data: getTransferSolInstructionDataEncoder().encode(\n      args as TransferSolInstructionDataArgs\n    ),\n  } as TransferSolInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    destination: TAccountMetas[1];\n  };\n  data: TransferSolInstructionData;\n};\n\nexport function parseTransferSolInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferSolInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n    },\n    data: getTransferSolInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_WITH_SEED_DISCRIMINATOR = 11;\n\nexport function getTransferSolWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type TransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | IAccountMeta<string> = string,\n  TAccountBaseAccount extends string | IAccountMeta<string> = string,\n  TAccountDestination extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            IAccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolWithSeedInstructionData = {\n  discriminator: number;\n  amount: bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport type TransferSolWithSeedInstructionDataArgs = {\n  amount: number | bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport function getTransferSolWithSeedInstructionDataEncoder(): Encoder<TransferSolWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n      ['fromSeed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['fromOwner', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_SOL_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferSolWithSeedInstructionDataDecoder(): Decoder<TransferSolWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n    ['fromSeed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['fromOwner', getAddressDecoder()],\n  ]);\n}\n\nexport function getTransferSolWithSeedInstructionDataCodec(): Codec<\n  TransferSolWithSeedInstructionDataArgs,\n  TransferSolWithSeedInstructionData\n> {\n  return combineCodec(\n    getTransferSolWithSeedInstructionDataEncoder(),\n    getTransferSolWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolWithSeedInput<\n  TAccountSource extends string = string,\n  TAccountBaseAccount extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: Address<TAccountSource>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolWithSeedInstructionDataArgs['amount'];\n  fromSeed: TransferSolWithSeedInstructionDataArgs['fromSeed'];\n  fromOwner: TransferSolWithSeedInstructionDataArgs['fromOwner'];\n};\n\nexport function getTransferSolWithSeedInstruction<\n  TAccountSource extends string,\n  TAccountBaseAccount extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolWithSeedInput<\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolWithSeedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountBaseAccount,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.baseAccount),\n      getAccountMeta(accounts.destination),\n    ],\n    programAddress,\n    data: getTransferSolWithSeedInstructionDataEncoder().encode(\n      args as TransferSolWithSeedInstructionDataArgs\n    ),\n  } as TransferSolWithSeedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n    destination: TAccountMetas[2];\n  };\n  data: TransferSolWithSeedInstructionData;\n};\n\nexport function parseTransferSolWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferSolWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      baseAccount: getNextAccount(),\n      destination: getNextAccount(),\n    },\n    data: getTransferSolWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR = 12;\n\nexport function getUpgradeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type UpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpgradeNonceAccountInstructionData = { discriminator: number };\n\nexport type UpgradeNonceAccountInstructionDataArgs = {};\n\nexport function getUpgradeNonceAccountInstructionDataEncoder(): Encoder<UpgradeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpgradeNonceAccountInstructionDataDecoder(): Decoder<UpgradeNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getUpgradeNonceAccountInstructionDataCodec(): Codec<\n  UpgradeNonceAccountInstructionDataArgs,\n  UpgradeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getUpgradeNonceAccountInstructionDataEncoder(),\n    getUpgradeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type UpgradeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n};\n\nexport function getUpgradeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: UpgradeNonceAccountInput<TAccountNonceAccount>,\n  config?: { programAddress?: TProgramAddress }\n): UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.nonceAccount)],\n    programAddress,\n    data: getUpgradeNonceAccountInstructionDataEncoder().encode({}),\n  } as UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount>;\n\n  return instruction;\n}\n\nexport type ParsedUpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n  };\n  data: UpgradeNonceAccountInstructionData;\n};\n\nexport function parseUpgradeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpgradeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n    },\n    data: getUpgradeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR = 5;\n\nexport function getWithdrawNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type WithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | IAccountMeta<string> = string,\n  TAccountRecipientAccount extends string | IAccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountNonceAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecipientAccount extends string\n        ? WritableAccount<TAccountRecipientAccount>\n        : TAccountRecipientAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            IAccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawNonceAccountInstructionData = {\n  discriminator: number;\n  withdrawAmount: bigint;\n};\n\nexport type WithdrawNonceAccountInstructionDataArgs = {\n  withdrawAmount: number | bigint;\n};\n\nexport function getWithdrawNonceAccountInstructionDataEncoder(): Encoder<WithdrawNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['withdrawAmount', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawNonceAccountInstructionDataDecoder(): Decoder<WithdrawNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['withdrawAmount', getU64Decoder()],\n  ]);\n}\n\nexport function getWithdrawNonceAccountInstructionDataCodec(): Codec<\n  WithdrawNonceAccountInstructionDataArgs,\n  WithdrawNonceAccountInstructionData\n> {\n  return combineCodec(\n    getWithdrawNonceAccountInstructionDataEncoder(),\n    getWithdrawNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecipientAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recipientAccount: Address<TAccountRecipientAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  withdrawAmount: WithdrawNonceAccountInstructionDataArgs['withdrawAmount'];\n};\n\nexport function getWithdrawNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecipientAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: WithdrawNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecipientAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recipientAccount: {\n      value: input.recipientAccount ?? null,\n      isWritable: true,\n    },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recipientAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getWithdrawNonceAccountInstructionDataEncoder().encode(\n      args as WithdrawNonceAccountInstructionDataArgs\n    ),\n  } as WithdrawNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recipientAccount: TAccountMetas[1];\n    recentBlockhashesSysvar: TAccountMetas[2];\n    rentSysvar: TAccountMetas[3];\n    nonceAuthority: TAccountMetas[4];\n  };\n  data: WithdrawNonceAccountInstructionData;\n};\n\nexport function parseWithdrawNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedWithdrawNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recipientAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getWithdrawNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n"],"names":["NonceState","NonceVersion","getEnumEncoder","getU32Encoder","getEnumDecoder","getU32Decoder","combineCodec","SystemAccount","SystemInstruction","kitIsTransactionSigner","getStructEncoder","getStructDecoder","transformEncoder","getU64Encoder","getU64Decoder","getAddressEncoder","getAddressDecoder","addEncoderSizePrefix","getUtf8Encoder","addDecoderSizePrefix","getUtf8Decoder"],"mappings":"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","debugId":null}}]
}