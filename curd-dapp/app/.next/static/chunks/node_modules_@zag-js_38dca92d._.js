(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/array.ts
__turbopack_context__.s({
    "add": ()=>add,
    "addOrRemove": ()=>addOrRemove,
    "callAll": ()=>callAll,
    "cast": ()=>cast,
    "chunk": ()=>chunk,
    "clampPercent": ()=>clampPercent,
    "clampValue": ()=>clampValue,
    "clear": ()=>clear,
    "compact": ()=>compact,
    "createSplitProps": ()=>createSplitProps,
    "debounce": ()=>debounce,
    "decrementValue": ()=>decrementValue,
    "diff": ()=>diff,
    "ensure": ()=>ensure,
    "ensureProps": ()=>ensureProps,
    "first": ()=>first,
    "flatArray": ()=>flatArray,
    "fromLength": ()=>fromLength,
    "getClosestValue": ()=>getClosestValue,
    "getClosestValueIndex": ()=>getClosestValueIndex,
    "getMaxValueAtIndex": ()=>getMaxValueAtIndex,
    "getMinValueAtIndex": ()=>getMinValueAtIndex,
    "getNextStepValue": ()=>getNextStepValue,
    "getPercentValue": ()=>getPercentValue,
    "getPreviousStepValue": ()=>getPreviousStepValue,
    "getValuePercent": ()=>getValuePercent,
    "getValueRanges": ()=>getValueRanges,
    "getValueSetterAtIndex": ()=>getValueSetterAtIndex,
    "getValueTransformer": ()=>getValueTransformer,
    "has": ()=>has,
    "hasProp": ()=>hasProp,
    "identity": ()=>identity,
    "incrementValue": ()=>incrementValue,
    "insertAt": ()=>insertAt,
    "invariant": ()=>invariant,
    "isArray": ()=>isArray,
    "isBoolean": ()=>isBoolean,
    "isDev": ()=>isDev,
    "isEmpty": ()=>isEmpty,
    "isEqual": ()=>isEqual,
    "isFunction": ()=>isFunction,
    "isNaN": ()=>isNaN,
    "isNull": ()=>isNull,
    "isNumber": ()=>isNumber,
    "isObject": ()=>isObject,
    "isObjectLike": ()=>isObjectLike,
    "isPlainObject": ()=>isPlainObject,
    "isString": ()=>isString,
    "isValueAtMax": ()=>isValueAtMax,
    "isValueAtMin": ()=>isValueAtMin,
    "isValueWithinRange": ()=>isValueWithinRange,
    "json": ()=>json,
    "last": ()=>last,
    "match": ()=>match,
    "mod": ()=>mod,
    "nan": ()=>nan,
    "next": ()=>next,
    "nextIndex": ()=>nextIndex,
    "noop": ()=>noop,
    "omit": ()=>omit,
    "pick": ()=>pick,
    "prev": ()=>prev,
    "prevIndex": ()=>prevIndex,
    "remove": ()=>remove,
    "removeAt": ()=>removeAt,
    "roundToDpr": ()=>roundToDpr,
    "roundToStepPrecision": ()=>roundToStepPrecision,
    "roundValue": ()=>roundValue,
    "runIfFn": ()=>runIfFn,
    "setRafInterval": ()=>setRafInterval,
    "setRafTimeout": ()=>setRafTimeout,
    "setValueAtIndex": ()=>setValueAtIndex,
    "snapValueToStep": ()=>snapValueToStep,
    "splitProps": ()=>splitProps,
    "throttle": ()=>throttle,
    "toArray": ()=>toArray,
    "toFixedNumber": ()=>toFixedNumber,
    "toPx": ()=>toPx,
    "tryCatch": ()=>tryCatch,
    "uniq": ()=>uniq,
    "uuid": ()=>uuid,
    "warn": ()=>warn,
    "wrap": ()=>wrap
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
function toArray(v) {
    if (v == null) return [];
    return Array.isArray(v) ? v : [
        v
    ];
}
var fromLength = (length)=>Array.from(Array(length).keys());
var first = (v)=>v[0];
var last = (v)=>v[v.length - 1];
var isEmpty = (v)=>v.length === 0;
var has = (v, t)=>v.indexOf(t) !== -1;
var add = function(v) {
    for(var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        items[_key - 1] = arguments[_key];
    }
    return v.concat(items);
};
var remove = function(v) {
    for(var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        items[_key - 1] = arguments[_key];
    }
    return v.filter((t)=>!items.includes(t));
};
var removeAt = (v, i)=>v.filter((_, idx)=>idx !== i);
var insertAt = function(v, i) {
    for(var _len = arguments.length, items = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        items[_key - 2] = arguments[_key];
    }
    return [
        ...v.slice(0, i),
        ...items,
        ...v.slice(i)
    ];
};
var uniq = (v)=>Array.from(new Set(v));
var diff = (a, b)=>{
    const set = new Set(b);
    return a.filter((t)=>!set.has(t));
};
var addOrRemove = (v, item)=>{
    if (has(v, item)) return remove(v, item);
    return add(v, item);
};
function clear(v) {
    while(v.length > 0)v.pop();
    return v;
}
function nextIndex(v, idx) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const { step = 1, loop = true } = opts;
    const next2 = idx + step;
    const len = v.length;
    const last2 = len - 1;
    if (idx === -1) return step > 0 ? 0 : last2;
    if (next2 < 0) return loop ? last2 : 0;
    if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
    return next2;
}
function next(v, idx) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return v[nextIndex(v, idx, opts)];
}
function prevIndex(v, idx) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const { step = 1, loop = true } = opts;
    return nextIndex(v, idx, {
        step: -step,
        loop
    });
}
function prev(v, index) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return v[prevIndex(v, index, opts)];
}
var chunk = (v, size)=>{
    const res = [];
    return v.reduce((rows, value, index)=>{
        var _last;
        if (index % size === 0) rows.push([
            value
        ]);
        else (_last = last(rows)) === null || _last === void 0 ? void 0 : _last.push(value);
        return rows;
    }, res);
};
function flatArray(arr) {
    return arr.reduce((flat, item)=>{
        if (Array.isArray(item)) {
            return flat.concat(flatArray(item));
        }
        return flat.concat(item);
    }, []);
}
// src/equal.ts
var isArrayLike = (value)=>(value === null || value === void 0 ? void 0 : value.constructor.name) === "Array";
var isArrayEqual = (a, b)=>{
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; i++){
        if (!isEqual(a[i], b[i])) return false;
    }
    return true;
};
var isEqual = (a, b)=>{
    if (Object.is(a, b)) return true;
    if (a == null && b != null || a != null && b == null) return false;
    if (typeof (a === null || a === void 0 ? void 0 : a.isEqual) === "function" && typeof (b === null || b === void 0 ? void 0 : b.isEqual) === "function") {
        return a.isEqual(b);
    }
    if (typeof a === "function" && typeof b === "function") {
        return a.toString() === b.toString();
    }
    if (isArrayLike(a) && isArrayLike(b)) {
        return isArrayEqual(Array.from(a), Array.from(b));
    }
    if (!(typeof a === "object") || !(typeof b === "object")) return false;
    const keys = Object.keys(b !== null && b !== void 0 ? b : /* @__PURE__ */ Object.create(null));
    const length = keys.length;
    for(let i = 0; i < length; i++){
        const hasKey = Reflect.has(a, keys[i]);
        if (!hasKey) return false;
    }
    for(let i = 0; i < length; i++){
        const key = keys[i];
        if (!isEqual(a[key], b[key])) return false;
    }
    return true;
};
// src/guard.ts
var isDev = ()=>("TURBOPACK compile-time value", "development") !== "production";
var isArray = (v)=>Array.isArray(v);
var isBoolean = (v)=>v === true || v === false;
var isObjectLike = (v)=>v != null && typeof v === "object";
var isObject = (v)=>isObjectLike(v) && !isArray(v);
var isNumber = (v)=>typeof v === "number" && !Number.isNaN(v);
var isString = (v)=>typeof v === "string";
var isFunction = (v)=>typeof v === "function";
var isNull = (v)=>v == null;
var hasProp = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
var baseGetTag = (v)=>Object.prototype.toString.call(v);
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var isPlainObject = (v)=>{
    if (!isObjectLike(v) || baseGetTag(v) != "[object Object]") return false;
    const proto = Object.getPrototypeOf(v);
    if (proto === null) return true;
    const Ctor = hasProp(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
};
// src/functions.ts
var runIfFn = function(v) {
    for(var _len = arguments.length, a = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        a[_key - 1] = arguments[_key];
    }
    const res = typeof v === "function" ? v(...a) : v;
    return res !== null && res !== void 0 ? res : void 0;
};
var cast = (v)=>v;
var identity = (v)=>v();
var noop = ()=>{};
var callAll = function() {
    for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){
        fns[_key] = arguments[_key];
    }
    return function() {
        for(var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++){
            a[_key] = arguments[_key];
        }
        fns.forEach(function(fn) {
            fn === null || fn === void 0 ? void 0 : fn(...a);
        });
    };
};
var uuid = /* @__PURE__ */ (()=>{
    let id = 0;
    return ()=>{
        id++;
        return id.toString(36);
    };
})();
function match(key, record) {
    for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
        args[_key - 2] = arguments[_key];
    }
    var _Error_captureStackTrace, _Error;
    if (key in record) {
        const fn = record[key];
        return isFunction(fn) ? fn(...args) : fn;
    }
    const error = new Error("No matching key: ".concat(JSON.stringify(key), " in ").concat(JSON.stringify(Object.keys(record))));
    (_Error_captureStackTrace = (_Error = Error).captureStackTrace) === null || _Error_captureStackTrace === void 0 ? void 0 : _Error_captureStackTrace.call(_Error, error, match);
    throw error;
}
var tryCatch = (fn, fallback)=>{
    try {
        return fn();
    } catch (error) {
        if (error instanceof Error) {
            var _Error_captureStackTrace, _Error;
            (_Error_captureStackTrace = (_Error = Error).captureStackTrace) === null || _Error_captureStackTrace === void 0 ? void 0 : _Error_captureStackTrace.call(_Error, error, tryCatch);
        }
        return fallback === null || fallback === void 0 ? void 0 : fallback();
    }
};
function throttle(fn) {
    let wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let lastCall = 0;
    let timeout = null;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        const now = Date.now();
        const timeSinceLastCall = now - lastCall;
        if (timeSinceLastCall >= wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            fn(...args);
            lastCall = now;
        } else if (!timeout) {
            timeout = setTimeout(()=>{
                fn(...args);
                lastCall = Date.now();
                timeout = null;
            }, wait - timeSinceLastCall);
        }
    };
}
function debounce(fn) {
    let wait = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let timeout = null;
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        timeout = setTimeout(()=>{
            fn(...args);
        }, wait);
    };
}
// src/number.ts
var { floor, abs, round, min, max, pow, sign } = Math;
var isNaN = (v)=>Number.isNaN(v);
var nan = (v)=>isNaN(v) ? 0 : v;
var mod = (v, m)=>(v % m + m) % m;
var wrap = (v, vmax)=>(v % vmax + vmax) % vmax;
var getMinValueAtIndex = (i, v, vmin)=>i === 0 ? vmin : v[i - 1];
var getMaxValueAtIndex = (i, v, vmax)=>i === v.length - 1 ? vmax : v[i + 1];
var isValueAtMax = (v, vmax)=>nan(v) >= vmax;
var isValueAtMin = (v, vmin)=>nan(v) <= vmin;
var isValueWithinRange = (v, vmin, vmax)=>nan(v) >= vmin && nan(v) <= vmax;
var roundValue = (v, vmin, step)=>round((nan(v) - vmin) / step) * step + vmin;
var clampValue = (v, vmin, vmax)=>min(max(nan(v), vmin), vmax);
var clampPercent = (v)=>clampValue(v, 0, 1);
var getValuePercent = (v, vmin, vmax)=>(nan(v) - vmin) / (vmax - vmin);
var getPercentValue = (p, vmin, vmax, step)=>clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
var roundToStepPrecision = (v, step)=>{
    let rv = v;
    let ss = step.toString();
    let pi = ss.indexOf(".");
    let p = pi >= 0 ? ss.length - pi : 0;
    if (p > 0) {
        let pw = pow(10, p);
        rv = round(rv * pw) / pw;
    }
    return rv;
};
var roundToDpr = (v, dpr)=>typeof dpr === "number" ? floor(v * dpr + 0.5) / dpr : round(v);
var snapValueToStep = (v, vmin, vmax, step)=>{
    const min2 = vmin != null ? Number(vmin) : 0;
    const max2 = Number(vmax);
    const remainder = (v - min2) % step;
    let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;
    snapped = roundToStepPrecision(snapped, step);
    if (!isNaN(min2) && snapped < min2) {
        snapped = min2;
    } else if (!isNaN(max2) && snapped > max2) {
        const stepsInRange = floor((max2 - min2) / step);
        const largestValidStep = min2 + stepsInRange * step;
        snapped = stepsInRange <= 0 || largestValidStep < min2 ? max2 : largestValidStep;
    }
    return roundToStepPrecision(snapped, step);
};
var setValueAtIndex = (vs, i, v)=>{
    if (vs[i] === v) return vs;
    return [
        ...vs.slice(0, i),
        v,
        ...vs.slice(i + 1)
    ];
};
function getValueSetterAtIndex(index, ctx) {
    const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
    const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
    let nextValues = ctx.values.slice();
    return function setValue(value) {
        let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
        nextValues = setValueAtIndex(nextValues, index, value);
        nextValues[index] = nextValue;
        return nextValues;
    };
}
function getNextStepValue(index, ctx) {
    const nextValue = ctx.values[index] + ctx.step;
    return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
    const nextValue = ctx.values[index] - ctx.step;
    return getValueSetterAtIndex(index, ctx)(nextValue);
}
var getClosestValueIndex = (vs, t)=>{
    let i = vs.findIndex((v)=>t - v < 0);
    if (i === 0) return i;
    if (i === -1) return vs.length - 1;
    let vLeft = vs[i - 1];
    let vRight = vs[i];
    if (abs(vLeft - t) < abs(vRight - t)) return i - 1;
    return i;
};
var getClosestValue = (vs, t)=>vs[getClosestValueIndex(vs, t)];
var getValueRanges = (vs, vmin, vmax, gap)=>vs.map((v, i)=>({
            min: i === 0 ? vmin : vs[i - 1] + gap,
            max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,
            value: v
        }));
var getValueTransformer = (va, vb)=>{
    const [a, b] = va;
    const [c, d] = vb;
    return (v)=>a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);
};
var toFixedNumber = function(v) {
    let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
    const pow2 = Math.pow(b, d);
    return round(v * pow2) / pow2;
};
var countDecimals = (value)=>{
    if (!Number.isFinite(value)) return 0;
    let e = 1, p = 0;
    while(Math.round(value * e) / e !== value){
        e *= 10;
        p += 1;
    }
    return p;
};
var decimalOp = (a, op, b)=>{
    let result = op === "+" ? a + b : a - b;
    if (a % 1 !== 0 || b % 1 !== 0) {
        const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
        a = Math.round(a * multiplier);
        b = Math.round(b * multiplier);
        result = op === "+" ? a + b : a - b;
        result /= multiplier;
    }
    return result;
};
var incrementValue = (v, s)=>decimalOp(nan(v), "+", s);
var decrementValue = (v, s)=>decimalOp(nan(v), "-", s);
var toPx = (v)=>v != null ? "".concat(v, "px") : void 0;
// src/object.ts
function compact(obj) {
    if (!isPlainObject2(obj) || obj === void 0) return obj;
    const keys = Reflect.ownKeys(obj).filter((key)=>typeof key === "string");
    const filtered = {};
    for (const key of keys){
        const value = obj[key];
        if (value !== void 0) {
            filtered[key] = compact(value);
        }
    }
    return filtered;
}
var json = (v)=>JSON.parse(JSON.stringify(v));
var isPlainObject2 = (v)=>{
    return v && typeof v === "object" && v.constructor === Object;
};
function pick(obj, keys) {
    const filtered = {};
    for (const key of keys){
        const value = obj[key];
        if (value !== void 0) {
            filtered[key] = value;
        }
    }
    return filtered;
}
function splitProps(props, keys) {
    const rest = {};
    const result = {};
    const keySet = new Set(keys);
    for(const key in props){
        if (keySet.has(key)) {
            result[key] = props[key];
        } else {
            rest[key] = props[key];
        }
    }
    return [
        result,
        rest
    ];
}
var createSplitProps = (keys)=>{
    return function split(props) {
        return splitProps(props, keys);
    };
};
function omit(obj, keys) {
    return createSplitProps(keys)(obj)[1];
}
// src/timers.ts
function setRafInterval(callback, interval) {
    let start = performance.now();
    let handle;
    function loop(now) {
        handle = requestAnimationFrame(loop);
        const delta = now - start;
        if (delta >= interval) {
            start = now - delta % interval;
            callback({
                startMs: start,
                deltaMs: delta
            });
        }
    }
    handle = requestAnimationFrame(loop);
    return ()=>cancelAnimationFrame(handle);
}
function setRafTimeout(callback, delay) {
    const start = performance.now();
    let handle;
    function loop(now) {
        handle = requestAnimationFrame(loop);
        const delta = now - start;
        if (delta >= delay) {
            callback();
        }
    }
    handle = requestAnimationFrame(loop);
    return ()=>cancelAnimationFrame(handle);
}
// src/warning.ts
function warn() {
    for(var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++){
        a[_key] = arguments[_key];
    }
    const m = a.length === 1 ? a[0] : a[1];
    const c = a.length === 2 ? a[0] : true;
    if (c && ("TURBOPACK compile-time value", "development") !== "production") {
        console.warn(m);
    }
}
function invariant() {
    for(var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++){
        a[_key] = arguments[_key];
    }
    const m = a.length === 1 ? a[0] : a[1];
    const c = a.length === 2 ? a[0] : true;
    if (c && ("TURBOPACK compile-time value", "development") !== "production") {
        throw new Error(m);
    }
}
function ensure(c, m) {
    if (c == null) throw new Error(m());
}
function ensureProps(props, keys, scope) {
    let missingKeys = [];
    for (const key of keys){
        if (props[key] == null) missingKeys.push(key);
    }
    if (missingKeys.length > 0) throw new Error("[zag-js".concat(scope ? " > ".concat(scope) : "", "] missing required props: ").concat(missingKeys.join(", ")));
}
;
}),
"[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/caret.ts
__turbopack_context__.s({
    "MAX_Z_INDEX": ()=>MAX_Z_INDEX,
    "addDomEvent": ()=>addDomEvent,
    "ariaAttr": ()=>ariaAttr,
    "clickIfLink": ()=>clickIfLink,
    "contains": ()=>contains,
    "createScope": ()=>createScope,
    "dataAttr": ()=>dataAttr,
    "defaultItemToId": ()=>defaultItemToId,
    "disableTextSelection": ()=>disableTextSelection,
    "dispatchInputCheckedEvent": ()=>dispatchInputCheckedEvent,
    "dispatchInputValueEvent": ()=>dispatchInputValueEvent,
    "getActiveElement": ()=>getActiveElement,
    "getBeforeInputValue": ()=>getBeforeInputValue,
    "getByText": ()=>getByText,
    "getByTypeahead": ()=>getByTypeahead,
    "getComputedStyle": ()=>getComputedStyle,
    "getDataUrl": ()=>getDataUrl,
    "getDocument": ()=>getDocument,
    "getDocumentElement": ()=>getDocumentElement,
    "getEventKey": ()=>getEventKey,
    "getEventPoint": ()=>getEventPoint,
    "getEventStep": ()=>getEventStep,
    "getEventTarget": ()=>getEventTarget,
    "getFirstFocusable": ()=>getFirstFocusable,
    "getFirstTabbable": ()=>getFirstTabbable,
    "getFocusables": ()=>getFocusables,
    "getInitialFocus": ()=>getInitialFocus,
    "getLastTabbable": ()=>getLastTabbable,
    "getNativeEvent": ()=>getNativeEvent,
    "getNearestOverflowAncestor": ()=>getNearestOverflowAncestor,
    "getNextTabbable": ()=>getNextTabbable,
    "getNodeName": ()=>getNodeName,
    "getOverflowAncestors": ()=>getOverflowAncestors,
    "getParentNode": ()=>getParentNode,
    "getPlatform": ()=>getPlatform,
    "getRelativePoint": ()=>getRelativePoint,
    "getScrollPosition": ()=>getScrollPosition,
    "getTabIndex": ()=>getTabIndex,
    "getTabbableEdges": ()=>getTabbableEdges,
    "getTabbables": ()=>getTabbables,
    "getUserAgent": ()=>getUserAgent,
    "getWindow": ()=>getWindow,
    "indexOfId": ()=>indexOfId,
    "isAnchorElement": ()=>isAnchorElement,
    "isAndroid": ()=>isAndroid,
    "isApple": ()=>isApple,
    "isCaretAtStart": ()=>isCaretAtStart,
    "isChrome": ()=>isChrome,
    "isComposingEvent": ()=>isComposingEvent,
    "isContextMenuEvent": ()=>isContextMenuEvent,
    "isCtrlOrMetaKey": ()=>isCtrlOrMetaKey,
    "isDocument": ()=>isDocument,
    "isDom": ()=>isDom,
    "isDownloadingEvent": ()=>isDownloadingEvent,
    "isEditableElement": ()=>isEditableElement,
    "isElementVisible": ()=>isElementVisible,
    "isFirefox": ()=>isFirefox,
    "isFocusable": ()=>isFocusable,
    "isHTMLElement": ()=>isHTMLElement,
    "isIPad": ()=>isIPad,
    "isIPhone": ()=>isIPhone,
    "isInView": ()=>isInView,
    "isInputElement": ()=>isInputElement,
    "isIos": ()=>isIos,
    "isKeyboardClick": ()=>isKeyboardClick,
    "isLeftClick": ()=>isLeftClick,
    "isMac": ()=>isMac,
    "isModifierKey": ()=>isModifierKey,
    "isNode": ()=>isNode,
    "isOpeningInNewTab": ()=>isOpeningInNewTab,
    "isOverflowElement": ()=>isOverflowElement,
    "isPrintableKey": ()=>isPrintableKey,
    "isRootElement": ()=>isRootElement,
    "isSafari": ()=>isSafari,
    "isSelfTarget": ()=>isSelfTarget,
    "isShadowRoot": ()=>isShadowRoot,
    "isTabbable": ()=>isTabbable,
    "isTouchDevice": ()=>isTouchDevice,
    "isTouchEvent": ()=>isTouchEvent,
    "isValidTabEvent": ()=>isValidTabEvent,
    "isVirtualClick": ()=>isVirtualClick,
    "isVirtualPointerEvent": ()=>isVirtualPointerEvent,
    "isVisualViewport": ()=>isVisualViewport,
    "isWebKit": ()=>isWebKit,
    "isWindow": ()=>isWindow,
    "itemById": ()=>itemById,
    "nextById": ()=>nextById,
    "nextTick": ()=>nextTick,
    "observeAttributes": ()=>observeAttributes,
    "observeChildren": ()=>observeChildren,
    "prevById": ()=>prevById,
    "proxyTabFocus": ()=>proxyTabFocus,
    "query": ()=>query,
    "queryAll": ()=>queryAll,
    "queueBeforeEvent": ()=>queueBeforeEvent,
    "raf": ()=>raf,
    "requestPointerLock": ()=>requestPointerLock,
    "restoreTextSelection": ()=>restoreTextSelection,
    "scrollIntoView": ()=>scrollIntoView,
    "setAttribute": ()=>setAttribute,
    "setCaretToEnd": ()=>setCaretToEnd,
    "setElementChecked": ()=>setElementChecked,
    "setElementValue": ()=>setElementValue,
    "setProperty": ()=>setProperty,
    "setStyle": ()=>setStyle,
    "setStyleProperty": ()=>setStyleProperty,
    "setVisuallyHidden": ()=>setVisuallyHidden,
    "trackElementRect": ()=>trackElementRect,
    "trackFormControl": ()=>trackFormControl,
    "trackPointerMove": ()=>trackPointerMove,
    "trackPress": ()=>trackPress,
    "trackVisualViewport": ()=>trackVisualViewport,
    "visuallyHiddenStyle": ()=>visuallyHiddenStyle,
    "waitForElement": ()=>waitForElement,
    "waitForElements": ()=>waitForElements
});
function isCaretAtStart(input) {
    if (!input) return false;
    try {
        return input.selectionStart === 0 && input.selectionEnd === 0;
    } catch (e) {
        return input.value === "";
    }
}
function setCaretToEnd(input) {
    if (!input) return;
    var _input_selectionStart;
    const start = (_input_selectionStart = input.selectionStart) !== null && _input_selectionStart !== void 0 ? _input_selectionStart : 0;
    var _input_selectionEnd;
    const end = (_input_selectionEnd = input.selectionEnd) !== null && _input_selectionEnd !== void 0 ? _input_selectionEnd : 0;
    if (Math.abs(end - start) !== 0) return;
    if (start !== 0) return;
    input.setSelectionRange(input.value.length, input.value.length);
}
// src/shared.ts
var clamp = (value)=>Math.max(0, Math.min(1, value));
var wrap = (v, idx)=>{
    return v.map((_, index)=>v[(Math.max(idx, 0) + index) % v.length]);
};
var pipe = function() {
    for(var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++){
        fns[_key] = arguments[_key];
    }
    return (arg)=>fns.reduce((acc, fn)=>fn(acc), arg);
};
var noop = ()=>void 0;
var isObject = (v)=>typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard)=>guard ? "" : void 0;
var ariaAttr = (guard)=>guard ? "true" : void 0;
// src/node.ts
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el)=>isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el)=>isObject(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el)=>isObject(el) && el === el.window;
var isVisualViewport = (el)=>isObject(el) && el.constructor.name === "VisualViewport";
var getNodeName = (node)=>{
    if (isHTMLElement(node)) return node.localName || "";
    return "#document";
};
function isRootElement(node) {
    return [
        "html",
        "body",
        "#document"
    ].includes(getNodeName(node));
}
var isNode = (el)=>isObject(el) && el.nodeType !== void 0;
var isShadowRoot = (el)=>isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el)=>isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el)=>!!(el === null || el === void 0 ? void 0 : el.matches("a[href]"));
var isElementVisible = (el)=>{
    if (!isHTMLElement(el)) return false;
    return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
    if (el == null || !isHTMLElement(el)) return false;
    try {
        return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
    } catch (e) {
        return false;
    }
}
function contains(parent, child) {
    var _child_getRootNode;
    if (!parent || !child) return false;
    if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;
    const rootNode = (_child_getRootNode = child.getRootNode) === null || _child_getRootNode === void 0 ? void 0 : _child_getRootNode.call(child);
    if (parent === child) return true;
    if (parent.contains(child)) return true;
    if (rootNode && isShadowRoot(rootNode)) {
        let next = child;
        while(next){
            if (parent === next) return true;
            next = next.parentNode || next.host;
        }
    }
    return false;
}
function getDocument(el) {
    if (isDocument(el)) return el;
    if (isWindow(el)) return el.document;
    var _el_ownerDocument;
    return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
}
function getDocumentElement(el) {
    return getDocument(el).documentElement;
}
function getWindow(el) {
    var _el_ownerDocument;
    if (isShadowRoot(el)) return getWindow(el.host);
    var _el_defaultView;
    if (isDocument(el)) return (_el_defaultView = el.defaultView) !== null && _el_defaultView !== void 0 ? _el_defaultView : window;
    var _el_ownerDocument_defaultView;
    if (isHTMLElement(el)) return (_el_ownerDocument_defaultView = (_el_ownerDocument = el.ownerDocument) === null || _el_ownerDocument === void 0 ? void 0 : _el_ownerDocument.defaultView) !== null && _el_ownerDocument_defaultView !== void 0 ? _el_ownerDocument_defaultView : window;
    return window;
}
function getActiveElement(rootNode) {
    let activeElement = rootNode.activeElement;
    while(activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot){
        const el = activeElement.shadowRoot.activeElement;
        if (el === activeElement) break;
        else activeElement = el;
    }
    return activeElement;
}
function getParentNode(node) {
    if (getNodeName(node) === "html") return node;
    const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
}
// src/computed-style.ts
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle(el) {
    if (!styleCache.has(el)) {
        styleCache.set(el, getWindow(el).getComputedStyle(el));
    }
    return styleCache.get(el);
}
// src/data-url.ts
function getDataUrl(svg, opts) {
    const { type, quality = 0.92, background } = opts;
    if (!svg) throw new Error("[zag-js > getDataUrl]: Could not find the svg element");
    const win = getWindow(svg);
    const doc = win.document;
    const svgBounds = svg.getBoundingClientRect();
    const svgClone = svg.cloneNode(true);
    if (!svgClone.hasAttribute("viewBox")) {
        svgClone.setAttribute("viewBox", "0 0 ".concat(svgBounds.width, " ").concat(svgBounds.height));
    }
    const serializer = new win.XMLSerializer();
    const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svgClone);
    const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
    if (type === "image/svg+xml") {
        return Promise.resolve(svgString).then((str)=>{
            svgClone.remove();
            return str;
        });
    }
    const dpr = win.devicePixelRatio || 1;
    const canvas = doc.createElement("canvas");
    const image = new win.Image();
    image.src = svgString;
    canvas.width = svgBounds.width * dpr;
    canvas.height = svgBounds.height * dpr;
    const context = canvas.getContext("2d");
    if (type === "image/jpeg" || background) {
        context.fillStyle = background || "white";
        context.fillRect(0, 0, canvas.width, canvas.height);
    }
    return new Promise((resolve)=>{
        image.onload = ()=>{
            context === null || context === void 0 ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL(type, quality));
            svgClone.remove();
        };
    });
}
// src/platform.ts
var isDom = ()=>typeof document !== "undefined";
function getPlatform() {
    const agent = navigator.userAgentData;
    var _agent_platform;
    return (_agent_platform = agent === null || agent === void 0 ? void 0 : agent.platform) !== null && _agent_platform !== void 0 ? _agent_platform : navigator.platform;
}
function getUserAgent() {
    const ua2 = navigator.userAgentData;
    if (ua2 && Array.isArray(ua2.brands)) {
        return ua2.brands.map((param)=>{
            let { brand, version } = param;
            return "".concat(brand, "/").concat(version);
        }).join(" ");
    }
    return navigator.userAgent;
}
var pt = (v)=>isDom() && v.test(getPlatform());
var ua = (v)=>isDom() && v.test(getUserAgent());
var vn = (v)=>isDom() && v.test(navigator.vendor);
var isTouchDevice = ()=>isDom() && !!navigator.maxTouchPoints;
var isIPhone = ()=>pt(/^iPhone/i);
var isIPad = ()=>pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;
var isIos = ()=>isIPhone() || isIPad();
var isApple = ()=>isMac() || isIos();
var isMac = ()=>pt(/^Mac/i);
var isSafari = ()=>isApple() && vn(/apple/i);
var isFirefox = ()=>ua(/Firefox/i);
var isChrome = ()=>ua(/Chrome/i);
var isWebKit = ()=>ua(/AppleWebKit/i) && !isChrome();
var isAndroid = ()=>ua(/Android/i);
// src/event.ts
function getBeforeInputValue(event) {
    const { selectionStart, selectionEnd, value } = event.currentTarget;
    return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
    var _event_composedPath, _event_nativeEvent_composedPath, _event_nativeEvent;
    var _event_composedPath1;
    return (_event_composedPath1 = (_event_composedPath = event.composedPath) === null || _event_composedPath === void 0 ? void 0 : _event_composedPath.call(event)) !== null && _event_composedPath1 !== void 0 ? _event_composedPath1 : (_event_nativeEvent = event.nativeEvent) === null || _event_nativeEvent === void 0 ? void 0 : (_event_nativeEvent_composedPath = _event_nativeEvent.composedPath) === null || _event_nativeEvent_composedPath === void 0 ? void 0 : _event_nativeEvent_composedPath.call(_event_nativeEvent);
}
function getEventTarget(event) {
    const composedPath = getComposedPath(event);
    var _composedPath_;
    return (_composedPath_ = composedPath === null || composedPath === void 0 ? void 0 : composedPath[0]) !== null && _composedPath_ !== void 0 ? _composedPath_ : event.target;
}
var isSelfTarget = (event)=>{
    return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
    const element = event.currentTarget;
    if (!element) return false;
    const validElement = element.matches("a[href], button[type='submit'], input[type='submit']");
    if (!validElement) return false;
    const isMiddleClick = event.button === 1;
    const isModKeyClick = isCtrlOrMetaKey(event);
    return isMiddleClick || isModKeyClick;
}
function isDownloadingEvent(event) {
    const element = event.currentTarget;
    if (!element) return false;
    const localName = element.localName;
    if (!event.altKey) return false;
    if (localName === "a") return true;
    if (localName === "button" && element.type === "submit") return true;
    if (localName === "input" && element.type === "submit") return true;
    return false;
}
function isComposingEvent(event) {
    return getNativeEvent(event).isComposing || event.keyCode === 229;
}
function isKeyboardClick(e) {
    return e.detail === 0 || e.clientX === 0 && e.clientY === 0;
}
function isCtrlOrMetaKey(e) {
    if (isMac()) return e.metaKey;
    return e.ctrlKey;
}
function isPrintableKey(e) {
    return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
function isVirtualPointerEvent(e) {
    return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse";
}
function isVirtualClick(e) {
    if (e.mozInputSource === 0 && e.isTrusted) return true;
    if (isAndroid() && e.pointerType) {
        return e.type === "click" && e.buttons === 1;
    }
    return e.detail === 0 && !e.pointerType;
}
var isLeftClick = (e)=>e.button === 0;
var isContextMenuEvent = (e)=>{
    return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e)=>e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event)=>"touches" in event && event.touches.length > 0;
var keyMap = {
    Up: "ArrowUp",
    Down: "ArrowDown",
    Esc: "Escape",
    " ": "Space",
    ",": "Comma",
    Left: "ArrowLeft",
    Right: "ArrowRight"
};
var rtlKeyMap = {
    ArrowLeft: "ArrowRight",
    ArrowRight: "ArrowLeft"
};
function getEventKey(event) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { dir = "ltr", orientation = "horizontal" } = options;
    let key = event.key;
    var _keyMap_key;
    key = (_keyMap_key = keyMap[key]) !== null && _keyMap_key !== void 0 ? _keyMap_key : key;
    const isRtl = dir === "rtl" && orientation === "horizontal";
    if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
    return key;
}
function getNativeEvent(event) {
    var _event_nativeEvent;
    return (_event_nativeEvent = event.nativeEvent) !== null && _event_nativeEvent !== void 0 ? _event_nativeEvent : event;
}
var pageKeys = /* @__PURE__ */ new Set([
    "PageUp",
    "PageDown"
]);
var arrowKeys = /* @__PURE__ */ new Set([
    "ArrowUp",
    "ArrowDown",
    "ArrowLeft",
    "ArrowRight"
]);
function getEventStep(event) {
    if (event.ctrlKey || event.metaKey) {
        return 0.1;
    } else {
        const isPageKey = pageKeys.has(event.key);
        const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
        return isSkipKey ? 10 : 1;
    }
}
function getEventPoint(event) {
    let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "client";
    const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
    return {
        x: point["".concat(type, "X")],
        y: point["".concat(type, "Y")]
    };
}
var addDomEvent = (target, eventName, handler, options)=>{
    const node = typeof target === "function" ? target() : target;
    node === null || node === void 0 ? void 0 : node.addEventListener(eventName, handler, options);
    return ()=>{
        node === null || node === void 0 ? void 0 : node.removeEventListener(eventName, handler, options);
    };
};
// src/form.ts
function getDescriptor(el, options) {
    const { type = "HTMLInputElement", property = "value" } = options;
    const proto = getWindow(el)[type].prototype;
    var _Object_getOwnPropertyDescriptor;
    return (_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(proto, property)) !== null && _Object_getOwnPropertyDescriptor !== void 0 ? _Object_getOwnPropertyDescriptor : {};
}
function getElementType(el) {
    if (el.localName === "input") return "HTMLInputElement";
    if (el.localName === "textarea") return "HTMLTextAreaElement";
    if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value) {
    let property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "value";
    if (!el) return;
    const type = getElementType(el);
    if (type) {
        var _descriptor_set;
        const descriptor = getDescriptor(el, {
            type,
            property
        });
        (_descriptor_set = descriptor.set) === null || _descriptor_set === void 0 ? void 0 : _descriptor_set.call(el, value);
    }
    el.setAttribute(property, value);
}
function setElementChecked(el, checked) {
    var _descriptor_set;
    if (!el) return;
    const descriptor = getDescriptor(el, {
        type: "HTMLInputElement",
        property: "checked"
    });
    (_descriptor_set = descriptor.set) === null || _descriptor_set === void 0 ? void 0 : _descriptor_set.call(el, checked);
    if (checked) el.setAttribute("checked", "");
    else el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
    const { value, bubbles = true } = options;
    if (!el) return;
    const win = getWindow(el);
    if (!(el instanceof win.HTMLInputElement)) return;
    setElementValue(el, "".concat(value));
    el.dispatchEvent(new win.Event("input", {
        bubbles
    }));
}
function dispatchInputCheckedEvent(el, options) {
    const { checked, bubbles = true } = options;
    if (!el) return;
    const win = getWindow(el);
    if (!(el instanceof win.HTMLInputElement)) return;
    setElementChecked(el, checked);
    el.dispatchEvent(new win.Event("click", {
        bubbles
    }));
}
function getClosestForm(el) {
    return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
    return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
    if (!el) return;
    const form = getClosestForm(el);
    const onReset = (e)=>{
        if (e.defaultPrevented) return;
        callback();
    };
    form === null || form === void 0 ? void 0 : form.addEventListener("reset", onReset, {
        passive: true
    });
    return ()=>form === null || form === void 0 ? void 0 : form.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
    const fieldset = el === null || el === void 0 ? void 0 : el.closest("fieldset");
    if (!fieldset) return;
    callback(fieldset.disabled);
    const win = getWindow(fieldset);
    const obs = new win.MutationObserver(()=>callback(fieldset.disabled));
    obs.observe(fieldset, {
        attributes: true,
        attributeFilter: [
            "disabled"
        ]
    });
    return ()=>obs.disconnect();
}
function trackFormControl(el, options) {
    if (!el) return;
    const { onFieldsetDisabledChange, onFormReset } = options;
    const cleanups = [
        trackFormReset(el, onFormReset),
        trackFieldsetDisabled(el, onFieldsetDisabledChange)
    ];
    return ()=>cleanups.forEach((cleanup)=>cleanup === null || cleanup === void 0 ? void 0 : cleanup());
}
// src/tabbable.ts
var isFrame = (el)=>isHTMLElement(el) && el.tagName === "IFRAME";
var hasTabIndex = (el)=>!Number.isNaN(parseInt(el.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el)=>parseInt(el.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = function(container) {
    let includeContainer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!container) return [];
    const elements = Array.from(container.querySelectorAll(focusableSelector));
    const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
    if (include && isHTMLElement(container) && isFocusable(container)) {
        elements.unshift(container);
    }
    const focusableElements = elements.filter(isFocusable);
    focusableElements.forEach((element, i)=>{
        if (isFrame(element) && element.contentDocument) {
            const frameBody = element.contentDocument.body;
            focusableElements.splice(i, 1, ...getFocusables(frameBody));
        }
    });
    return focusableElements;
};
function isFocusable(element) {
    if (!element || element.closest("[inert]")) return false;
    return element.matches(focusableSelector) && isElementVisible(element);
}
function getFirstFocusable(container, includeContainer) {
    const [first] = getFocusables(container, includeContainer);
    return first || null;
}
function getTabbables(container, includeContainer) {
    if (!container) return [];
    const elements = Array.from(container.querySelectorAll(focusableSelector));
    const tabbableElements = elements.filter(isTabbable);
    if (includeContainer && isTabbable(container)) {
        tabbableElements.unshift(container);
    }
    tabbableElements.forEach((element, i)=>{
        if (isFrame(element) && element.contentDocument) {
            const frameBody = element.contentDocument.body;
            const allFrameTabbable = getTabbables(frameBody);
            tabbableElements.splice(i, 1, ...allFrameTabbable);
        }
    });
    if (!tabbableElements.length && includeContainer) {
        return elements;
    }
    return tabbableElements;
}
function isTabbable(el) {
    if (el != null && el.tabIndex > 0) return true;
    return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getFirstTabbable(container, includeContainer) {
    const [first] = getTabbables(container, includeContainer);
    return first || null;
}
function getLastTabbable(container, includeContainer) {
    const elements = getTabbables(container, includeContainer);
    return elements[elements.length - 1] || null;
}
function getTabbableEdges(container, includeContainer) {
    const elements = getTabbables(container, includeContainer);
    const first = elements[0] || null;
    const last = elements[elements.length - 1] || null;
    return [
        first,
        last
    ];
}
function getNextTabbable(container, current) {
    const tabbables = getTabbables(container);
    const doc = (container === null || container === void 0 ? void 0 : container.ownerDocument) || document;
    const currentElement = current !== null && current !== void 0 ? current : doc.activeElement;
    if (!currentElement) return null;
    const index = tabbables.indexOf(currentElement);
    return tabbables[index + 1] || null;
}
function getTabIndex(node) {
    if (node.tabIndex < 0) {
        if ((/^(audio|video|details)$/.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {
            return 0;
        }
    }
    return node.tabIndex;
}
// src/initial-focus.ts
function getInitialFocus(options) {
    const { root, getInitialEl, filter, enabled = true } = options;
    if (!enabled) return;
    let node = null;
    node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
    node || (node = root === null || root === void 0 ? void 0 : root.querySelector("[data-autofocus],[autofocus]"));
    if (!node) {
        const tabbables = getTabbables(root);
        node = filter ? tabbables.filter(filter)[0] : tabbables[0];
    }
    return node || root || void 0;
}
function isValidTabEvent(event) {
    const container = event.currentTarget;
    if (!container) return false;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container);
    const doc = container.ownerDocument || document;
    if (doc.activeElement === firstTabbable && event.shiftKey) return false;
    if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
    if (!firstTabbable && !lastTabbable) return false;
    return true;
}
// src/raf.ts
function nextTick(fn) {
    const set = /* @__PURE__ */ new Set();
    function raf2(fn2) {
        const id = globalThis.requestAnimationFrame(fn2);
        set.add(()=>globalThis.cancelAnimationFrame(id));
    }
    raf2(()=>raf2(fn));
    return function cleanup() {
        set.forEach((fn2)=>fn2());
    };
}
function raf(fn) {
    let cleanup;
    const id = globalThis.requestAnimationFrame(()=>{
        cleanup = fn();
    });
    return ()=>{
        globalThis.cancelAnimationFrame(id);
        cleanup === null || cleanup === void 0 ? void 0 : cleanup();
    };
}
function queueBeforeEvent(el, type, cb) {
    const cancelTimer = raf(()=>{
        el.removeEventListener(type, exec, true);
        cb();
    });
    const exec = ()=>{
        cancelTimer();
        cb();
    };
    el.addEventListener(type, exec, {
        once: true,
        capture: true
    });
    return cancelTimer;
}
// src/mutation-observer.ts
function observeAttributesImpl(node, options) {
    if (!node) return;
    const { attributes, callback: fn } = options;
    const win = node.ownerDocument.defaultView || window;
    const obs = new win.MutationObserver((changes)=>{
        for (const change of changes){
            if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
                fn(change);
            }
        }
    });
    obs.observe(node, {
        attributes: true,
        attributeFilter: attributes
    });
    return ()=>obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups.push(observeAttributesImpl(node, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
function observeChildrenImpl(node, options) {
    const { callback: fn } = options;
    if (!node) return;
    const win = node.ownerDocument.defaultView || window;
    const obs = new win.MutationObserver(fn);
    obs.observe(node, {
        childList: true,
        subtree: true
    });
    return ()=>obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups.push(observeChildrenImpl(node, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
// src/navigate.ts
function clickIfLink(el) {
    const click = ()=>el.click();
    if (isFirefox()) {
        queueBeforeEvent(el, "keyup", click);
    } else {
        queueMicrotask(click);
    }
}
// src/overflow.ts
function getNearestOverflowAncestor(el) {
    const parentNode = getParentNode(el);
    if (isRootElement(parentNode)) return getDocument(parentNode).body;
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
    return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el) {
    let list = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const scrollableAncestor = getNearestOverflowAncestor(el);
    const isBody = scrollableAncestor === el.ownerDocument.body;
    const win = getWindow(scrollableAncestor);
    if (isBody) {
        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
var getElementRect = (el)=>{
    if (isHTMLElement(el)) return el.getBoundingClientRect();
    if (isVisualViewport(el)) return {
        top: 0,
        left: 0,
        bottom: el.height,
        right: el.width
    };
    return {
        top: 0,
        left: 0,
        bottom: el.innerHeight,
        right: el.innerWidth
    };
};
function isInView(el, ancestor) {
    if (!isHTMLElement(el)) return true;
    const ancestorRect = getElementRect(ancestor);
    const elRect = el.getBoundingClientRect();
    return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
    const win = getWindow(el);
    const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
    return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![
        "inline",
        "contents"
    ].includes(display);
}
function isScrollable(el) {
    return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
    const { rootEl, ...scrollOptions } = options || {};
    if (!el || !rootEl) return;
    if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
    el.scrollIntoView(scrollOptions);
}
function getScrollPosition(element) {
    if (isHTMLElement(element)) {
        return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
        };
    }
    return {
        scrollLeft: element.scrollX,
        scrollTop: element.scrollY
    };
}
// src/point.ts
function getRelativePoint(point, element) {
    const { left, top, width, height } = element.getBoundingClientRect();
    const offset = {
        x: point.x - left,
        y: point.y - top
    };
    const percent = {
        x: clamp(offset.x / width),
        y: clamp(offset.y / height)
    };
    function getPercentValue() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const { dir = "ltr", orientation = "horizontal", inverted } = options;
        const invertX = typeof inverted === "object" ? inverted.x : inverted;
        const invertY = typeof inverted === "object" ? inverted.y : inverted;
        if (orientation === "horizontal") {
            return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
        }
        return invertY ? 1 - percent.y : percent.y;
    }
    return {
        offset,
        percent,
        getPercentValue
    };
}
// src/pointer-lock.ts
function requestPointerLock(doc, fn) {
    const body = doc.body;
    const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
    const isLocked = ()=>!!doc.pointerLockElement;
    function onPointerChange() {
        fn === null || fn === void 0 ? void 0 : fn(isLocked());
    }
    function onPointerError(event) {
        if (isLocked()) fn === null || fn === void 0 ? void 0 : fn(false);
        console.error("PointerLock error occurred:", event);
        doc.exitPointerLock();
    }
    if (!supported) return;
    try {
        body.requestPointerLock();
    } catch (e) {}
    const cleanup = [
        addDomEvent(doc, "pointerlockchange", onPointerChange, false),
        addDomEvent(doc, "pointerlockerror", onPointerError, false)
    ];
    return ()=>{
        cleanup.forEach((cleanup2)=>cleanup2());
        doc.exitPointerLock();
    };
}
// src/text-selection.ts
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { target, doc } = options;
    const docNode = doc !== null && doc !== void 0 ? doc : document;
    const rootEl = docNode.documentElement;
    if (isIos()) {
        if (state === "default") {
            userSelect = rootEl.style.webkitUserSelect;
            rootEl.style.webkitUserSelect = "none";
        }
        state = "disabled";
    } else if (target) {
        elementMap.set(target, target.style.userSelect);
        target.style.userSelect = "none";
    }
    return ()=>restoreTextSelection({
            target,
            doc: docNode
        });
}
function restoreTextSelection() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { target, doc } = options;
    const docNode = doc !== null && doc !== void 0 ? doc : document;
    const rootEl = docNode.documentElement;
    if (isIos()) {
        if (state !== "disabled") return;
        state = "restoring";
        setTimeout(()=>{
            nextTick(()=>{
                if (state === "restoring") {
                    if (rootEl.style.webkitUserSelect === "none") {
                        rootEl.style.webkitUserSelect = userSelect || "";
                    }
                    userSelect = "";
                    state = "default";
                }
            });
        }, 300);
    } else {
        if (target && elementMap.has(target)) {
            const prevUserSelect = elementMap.get(target);
            if (target.style.userSelect === "none") {
                target.style.userSelect = prevUserSelect !== null && prevUserSelect !== void 0 ? prevUserSelect : "";
            }
            if (target.getAttribute("style") === "") {
                target.removeAttribute("style");
            }
            elementMap.delete(target);
        }
    }
}
function disableTextSelection() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { defer, target, ...restOptions } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = typeof target === "function" ? target() : target;
        cleanups.push(disableTextSelectionImpl({
            ...restOptions,
            target: node
        }));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
// src/pointer-move.ts
function trackPointerMove(doc, handlers) {
    const { onPointerMove, onPointerUp } = handlers;
    const handleMove = (event)=>{
        const point = getEventPoint(event);
        const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
        const moveBuffer = event.pointerType === "touch" ? 10 : 5;
        if (distance < moveBuffer) return;
        if (event.pointerType === "mouse" && event.button === 0) {
            onPointerUp();
            return;
        }
        onPointerMove({
            point,
            event
        });
    };
    const cleanups = [
        addDomEvent(doc, "pointermove", handleMove, false),
        addDomEvent(doc, "pointerup", onPointerUp, false),
        addDomEvent(doc, "pointercancel", onPointerUp, false),
        addDomEvent(doc, "contextmenu", onPointerUp, false),
        disableTextSelection({
            doc
        })
    ];
    return ()=>{
        cleanups.forEach((cleanup)=>cleanup());
    };
}
// src/press.ts
function trackPress(options) {
    const { pointerNode, keyboardNode = pointerNode, onPress, onPressStart, onPressEnd, isValidKey = (e)=>e.key === "Enter" } = options;
    if (!pointerNode) return noop;
    const win = getWindow(pointerNode);
    const doc = getDocument(pointerNode);
    let removeStartListeners = noop;
    let removeEndListeners = noop;
    let removeAccessibleListeners = noop;
    const getInfo = (event)=>({
            point: getEventPoint(event),
            event
        });
    function startPress(event) {
        onPressStart === null || onPressStart === void 0 ? void 0 : onPressStart(getInfo(event));
    }
    function cancelPress(event) {
        onPressEnd === null || onPressEnd === void 0 ? void 0 : onPressEnd(getInfo(event));
    }
    const startPointerPress = (startEvent)=>{
        removeEndListeners();
        const endPointerPress = (endEvent)=>{
            const target = getEventTarget(endEvent);
            if (contains(pointerNode, target)) {
                onPress === null || onPress === void 0 ? void 0 : onPress(getInfo(endEvent));
            } else {
                onPressEnd === null || onPressEnd === void 0 ? void 0 : onPressEnd(getInfo(endEvent));
            }
        };
        const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, {
            passive: !onPress,
            once: true
        });
        const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, {
            passive: !onPressEnd,
            once: true
        });
        removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
        if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
            startEvent.preventDefault();
        }
        startPress(startEvent);
    };
    const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, {
        passive: !onPressStart
    });
    const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
    removeStartListeners = pipe(removePointerListener, removeFocusListener);
    function startAccessiblePress() {
        const handleKeydown = (keydownEvent)=>{
            if (!isValidKey(keydownEvent)) return;
            const handleKeyup = (keyupEvent)=>{
                if (!isValidKey(keyupEvent)) return;
                const evt2 = new win.PointerEvent("pointerup");
                const info = getInfo(evt2);
                onPress === null || onPress === void 0 ? void 0 : onPress(info);
                onPressEnd === null || onPressEnd === void 0 ? void 0 : onPressEnd(info);
            };
            removeEndListeners();
            removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
            const evt = new win.PointerEvent("pointerdown");
            startPress(evt);
        };
        const handleBlur = ()=>{
            const evt = new win.PointerEvent("pointercancel");
            cancelPress(evt);
        };
        const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
        const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
        removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    }
    return ()=>{
        removeStartListeners();
        removeEndListeners();
        removeAccessibleListeners();
    };
}
// src/proxy-tab-focus.ts
function proxyTabFocusImpl(container) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { triggerElement, onFocus, onFocusEnter } = options;
    const doc = (container === null || container === void 0 ? void 0 : container.ownerDocument) || document;
    const body = doc.body;
    function onKeyDown(event) {
        if (event.key !== "Tab") return;
        let elementToFocus = null;
        const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
        const nextTabbableAfterTrigger = getNextTabbable(body, triggerElement);
        const noTabbableElements = !firstTabbable && !lastTabbable;
        if (event.shiftKey && nextTabbableAfterTrigger === doc.activeElement) {
            onFocusEnter === null || onFocusEnter === void 0 ? void 0 : onFocusEnter();
            elementToFocus = lastTabbable;
        } else if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
            elementToFocus = triggerElement;
        } else if (!event.shiftKey && doc.activeElement === triggerElement) {
            onFocusEnter === null || onFocusEnter === void 0 ? void 0 : onFocusEnter();
            elementToFocus = firstTabbable;
        } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
            elementToFocus = nextTabbableAfterTrigger;
        }
        if (!elementToFocus) return;
        event.preventDefault();
        if (typeof onFocus === "function") {
            onFocus(elementToFocus);
        } else {
            elementToFocus.focus();
        }
    }
    return addDomEvent(doc, "keydown", onKeyDown, true);
}
function proxyTabFocus(container, options) {
    const { defer, triggerElement, ...restOptions } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = typeof container === "function" ? container() : container;
        const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
        cleanups.push(proxyTabFocusImpl(node, {
            triggerElement: trigger,
            ...restOptions
        }));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
// src/query.ts
function queryAll(root, selector) {
    var _root_querySelectorAll;
    return Array.from((_root_querySelectorAll = root === null || root === void 0 ? void 0 : root.querySelectorAll(selector)) !== null && _root_querySelectorAll !== void 0 ? _root_querySelectorAll : []);
}
function query(root, selector) {
    var _root_querySelector;
    return (_root_querySelector = root === null || root === void 0 ? void 0 : root.querySelector(selector)) !== null && _root_querySelector !== void 0 ? _root_querySelector : null;
}
var defaultItemToId = (v)=>v.id;
function itemById(v, id) {
    let itemToId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultItemToId;
    return v.find((item)=>itemToId(item) === id);
}
function indexOfId(v, id) {
    let itemToId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultItemToId;
    const item = itemById(v, id, itemToId);
    return item ? v.indexOf(item) : -1;
}
function nextById(v, id) {
    let loop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let idx = indexOfId(v, id);
    idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
    return v[idx];
}
function prevById(v, id) {
    let loop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    let idx = indexOfId(v, id);
    if (idx === -1) return loop ? v[v.length - 1] : null;
    idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
    return v[idx];
}
// src/resize-observer.ts
function trackElementRect(elements, options) {
    const { onEntry, measure, box = "border-box" } = options;
    const elems = (Array.isArray(elements) ? elements : [
        elements
    ]).filter(isHTMLElement);
    const win = getWindow(elems[0]);
    const trigger = (entries)=>{
        const rects = elems.map((el)=>measure(el));
        onEntry({
            rects,
            entries
        });
    };
    trigger([]);
    const obs = new win.ResizeObserver(trigger);
    elems.forEach((el)=>obs.observe(el, {
            box
        }));
    return ()=>obs.disconnect();
}
// src/scope.ts
function createScope(methods) {
    const dom = {
        getRootNode: (ctx)=>{
            var _ctx_getRootNode;
            var _ctx_getRootNode1;
            return (_ctx_getRootNode1 = (_ctx_getRootNode = ctx.getRootNode) === null || _ctx_getRootNode === void 0 ? void 0 : _ctx_getRootNode.call(ctx)) !== null && _ctx_getRootNode1 !== void 0 ? _ctx_getRootNode1 : document;
        },
        getDoc: (ctx)=>getDocument(dom.getRootNode(ctx)),
        getWin: (ctx)=>{
            var _dom_getDoc_defaultView;
            return (_dom_getDoc_defaultView = dom.getDoc(ctx).defaultView) !== null && _dom_getDoc_defaultView !== void 0 ? _dom_getDoc_defaultView : window;
        },
        getActiveElement: (ctx)=>getActiveElement(dom.getRootNode(ctx)),
        isActiveElement: (ctx, elem)=>elem === dom.getActiveElement(ctx),
        getById: (ctx, id)=>dom.getRootNode(ctx).getElementById(id),
        setValue: (elem, value)=>{
            if (elem == null || value == null) return;
            setElementValue(elem, value.toString());
        }
    };
    return {
        ...dom,
        ...methods
    };
}
// src/searchable.ts
var sanitize = (str)=>str.split("").map((char)=>{
        const code = char.charCodeAt(0);
        if (code > 0 && code < 128) return char;
        if (code >= 128 && code <= 255) return "/x".concat(code.toString(16)).replace("/", "\\");
        return "";
    }).join("").trim();
var getValueText = (el)=>{
    var _el_dataset;
    var _el_dataset_valuetext, _ref;
    return sanitize((_ref = (_el_dataset_valuetext = (_el_dataset = el.dataset) === null || _el_dataset === void 0 ? void 0 : _el_dataset.valuetext) !== null && _el_dataset_valuetext !== void 0 ? _el_dataset_valuetext : el.textContent) !== null && _ref !== void 0 ? _ref : "");
};
var match = (valueText, query2)=>{
    return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text, currentId) {
    let itemToId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultItemToId;
    const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
    let items = currentId ? wrap(v, index) : v;
    const isSingleKey = text.length === 1;
    if (isSingleKey) {
        items = items.filter((item)=>itemToId(item) !== currentId);
    }
    return items.find((item)=>match(getValueText(item), text));
}
// src/set.ts
function setAttribute(el, attr, v) {
    const prev = el.getAttribute(attr);
    const exists = prev != null;
    el.setAttribute(attr, v);
    return ()=>{
        if (!exists) {
            el.removeAttribute(attr);
        } else {
            el.setAttribute(attr, prev);
        }
    };
}
function setProperty(el, prop, v) {
    const exists = prop in el;
    const prev = el[prop];
    el[prop] = v;
    return ()=>{
        if (!exists) {
            delete el[prop];
        } else {
            el[prop] = prev;
        }
    };
}
function setStyle(el, style) {
    if (!el) return noop;
    const prev = Object.keys(style).reduce((acc, key)=>{
        acc[key] = el.style.getPropertyValue(key);
        return acc;
    }, {});
    Object.assign(el.style, style);
    return ()=>{
        Object.assign(el.style, prev);
        if (el.style.length === 0) {
            el.removeAttribute("style");
        }
    };
}
function setStyleProperty(el, prop, value) {
    if (!el) return noop;
    const prev = el.style.getPropertyValue(prop);
    el.style.setProperty(prop, value);
    return ()=>{
        el.style.setProperty(prop, prev);
        if (el.style.length === 0) {
            el.removeAttribute("style");
        }
    };
}
// src/typeahead.ts
function getByTypeaheadImpl(baseItems, options) {
    const { state: state2, activeId, key, timeout = 350, itemToId } = options;
    const search = state2.keysSoFar + key;
    const isRepeated = search.length > 1 && Array.from(search).every((char)=>char === search[0]);
    const query2 = isRepeated ? search[0] : search;
    let items = baseItems.slice();
    const next = getByText(items, query2, activeId, itemToId);
    function cleanup() {
        clearTimeout(state2.timer);
        state2.timer = -1;
    }
    function update(value) {
        state2.keysSoFar = value;
        cleanup();
        if (value !== "") {
            state2.timer = +setTimeout(()=>{
                update("");
                cleanup();
            }, timeout);
        }
    }
    update(search);
    return next;
}
var getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {
    defaultOptions: {
        keysSoFar: "",
        timer: -1
    },
    isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
    return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
// src/visual-viewport.ts
function trackVisualViewport(doc, fn) {
    const win = (doc === null || doc === void 0 ? void 0 : doc.defaultView) || window;
    const onResize = ()=>{
        fn === null || fn === void 0 ? void 0 : fn(getViewportSize(win));
    };
    onResize();
    var _win_visualViewport;
    return addDomEvent((_win_visualViewport = win.visualViewport) !== null && _win_visualViewport !== void 0 ? _win_visualViewport : win, "resize", onResize);
}
function getViewportSize(win) {
    var _win_visualViewport, _win_visualViewport1;
    return {
        width: ((_win_visualViewport = win.visualViewport) === null || _win_visualViewport === void 0 ? void 0 : _win_visualViewport.width) || win.innerWidth,
        height: ((_win_visualViewport1 = win.visualViewport) === null || _win_visualViewport1 === void 0 ? void 0 : _win_visualViewport1.height) || win.innerHeight
    };
}
// src/visually-hidden.ts
var visuallyHiddenStyle = {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px",
    whiteSpace: "nowrap",
    wordWrap: "normal"
};
function setVisuallyHidden(el) {
    Object.assign(el.style, visuallyHiddenStyle);
}
// src/wait-for.ts
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
    const el = query2();
    if (isHTMLElement(el) && el.isConnected) {
        cb(el);
        return ()=>void 0;
    } else {
        const timerId = setInterval(()=>{
            const el2 = query2();
            if (isHTMLElement(el2) && el2.isConnected) {
                cb(el2);
                clearInterval(timerId);
            }
        }, fps);
        return ()=>clearInterval(timerId);
    }
}
function waitForElements(queries, cb) {
    const cleanups = [];
    queries === null || queries === void 0 ? void 0 : queries.forEach((query2)=>{
        const clean = waitForElement(query2, cb);
        cleanups.push(clean);
    });
    return ()=>{
        cleanups.forEach((fn)=>fn());
    };
}
;
}),
"[project]/node_modules/@zag-js/core/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "INIT_STATE": ()=>INIT_STATE,
    "MachineStatus": ()=>MachineStatus,
    "createGuards": ()=>createGuards,
    "createMachine": ()=>createMachine,
    "createScope": ()=>createScope,
    "memo": ()=>memo,
    "mergeProps": ()=>mergeProps,
    "setup": ()=>setup
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
;
;
// src/merge-props.ts
var clsx = function() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    return args.map((str)=>{
        var _str_trim;
        return str === null || str === void 0 ? void 0 : (_str_trim = str.trim) === null || _str_trim === void 0 ? void 0 : _str_trim.call(str);
    }).filter(Boolean).join(" ");
};
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style)=>{
    const res = {};
    let match;
    while(match = CSS_REGEX.exec(style)){
        res[match[1]] = match[2];
    }
    return res;
};
var css = (a, b)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(a)) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(b)) return "".concat(a, ";").concat(b);
        a = serialize(a);
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(b)) {
        b = serialize(b);
    }
    return Object.assign({}, a !== null && a !== void 0 ? a : {}, b !== null && b !== void 0 ? b : {});
};
function mergeProps() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    let result = {};
    for (let props of args){
        for(let key in result){
            if (key.startsWith("on") && typeof result[key] === "function" && typeof props[key] === "function") {
                result[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callAll"])(props[key], result[key]);
                continue;
            }
            if (key === "className" || key === "class") {
                result[key] = clsx(result[key], props[key]);
                continue;
            }
            if (key === "style") {
                result[key] = css(result[key], props[key]);
                continue;
            }
            result[key] = props[key] !== void 0 ? props[key] : result[key];
        }
        for(let key in props){
            if (result[key] === void 0) {
                result[key] = props[key];
            }
        }
    }
    return result;
}
function memo(getDeps, fn, opts) {
    let deps = [];
    let result;
    return (depArgs)=>{
        var _opts_onChange;
        const newDeps = getDeps(depArgs);
        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEqual"])(deps[index], dep));
        if (!depsChanged) return result;
        deps = newDeps;
        result = fn(...newDeps);
        opts === null || opts === void 0 ? void 0 : (_opts_onChange = opts.onChange) === null || _opts_onChange === void 0 ? void 0 : _opts_onChange.call(opts, result);
        return result;
    };
}
// src/create-machine.ts
function createGuards() {
    return {
        and: function() {
            for(var _len = arguments.length, guards = new Array(_len), _key = 0; _key < _len; _key++){
                guards[_key] = arguments[_key];
            }
            return function andGuard(params) {
                return guards.every((str)=>params.guard(str));
            };
        },
        or: function() {
            for(var _len = arguments.length, guards = new Array(_len), _key = 0; _key < _len; _key++){
                guards[_key] = arguments[_key];
            }
            return function orGuard(params) {
                return guards.some((str)=>params.guard(str));
            };
        },
        not: (guard)=>{
            return function notGuard(params) {
                return !params.guard(guard);
            };
        }
    };
}
function createMachine(config) {
    return config;
}
function setup() {
    return {
        guards: createGuards(),
        createMachine: (config)=>{
            return createMachine(config);
        },
        choose: (transitions)=>{
            return function chooseFn(param) {
                let { choose } = param;
                var _choose;
                return (_choose = choose(transitions)) === null || _choose === void 0 ? void 0 : _choose.actions;
            };
        }
    };
}
// src/types.ts
var MachineStatus = /* @__PURE__ */ ((MachineStatus2)=>{
    MachineStatus2["NotStarted"] = "Not Started";
    MachineStatus2["Started"] = "Started";
    MachineStatus2["Stopped"] = "Stopped";
    return MachineStatus2;
})(MachineStatus || {});
var INIT_STATE = "__init__";
function createScope(props) {
    const getRootNode = ()=>{
        var _props_getRootNode;
        var _props_getRootNode1;
        return (_props_getRootNode1 = (_props_getRootNode = props.getRootNode) === null || _props_getRootNode === void 0 ? void 0 : _props_getRootNode.call(props)) !== null && _props_getRootNode1 !== void 0 ? _props_getRootNode1 : document;
    };
    const getDoc = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])(getRootNode());
    const getWin = ()=>{
        var _getDoc_defaultView;
        return (_getDoc_defaultView = getDoc().defaultView) !== null && _getDoc_defaultView !== void 0 ? _getDoc_defaultView : window;
    };
    const getActiveElementFn = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveElement"])(getRootNode());
    const isActiveElement = (elem)=>elem === getActiveElementFn();
    const getById = (id)=>getRootNode().getElementById(id);
    return {
        ...props,
        getRootNode,
        getDoc,
        getWin,
        getActiveElement: getActiveElementFn,
        isActiveElement,
        getById
    };
}
;
}),
"[project]/node_modules/@zag-js/types/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/prop-types.ts
__turbopack_context__.s({
    "createNormalizer": ()=>createNormalizer,
    "createProps": ()=>createProps
});
function createNormalizer(fn) {
    return new Proxy({}, {
        get (_target, key) {
            if (key === "style") return (props)=>{
                return fn({
                    style: props
                }).style;
            };
            return fn;
        }
    });
}
// src/create-props.ts
var createProps = ()=>(props)=>Array.from(new Set(props));
;
}),
"[project]/node_modules/@zag-js/react/dist/index.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Portal": ()=>Portal,
    "normalizeProps": ()=>normalizeProps,
    "useMachine": ()=>useMachine
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/core/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/types/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
"use client";
;
;
;
;
;
;
;
;
// src/index.ts
var useSafeLayoutEffect = typeof globalThis.document !== "undefined" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayoutEffect"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"];
// src/bindable.ts
function useBindable(props) {
    var _props_value;
    const initial = (_props_value = props().value) !== null && _props_value !== void 0 ? _props_value : props().defaultValue;
    var _props_isEqual;
    const eq = (_props_isEqual = props().isEqual) !== null && _props_isEqual !== void 0 ? _props_isEqual : Object.is;
    const [initialValue] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(initial);
    const [value, setValue] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(initialValue);
    const controlled = props().value !== void 0;
    const valueRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(value);
    valueRef.current = controlled ? props().value : value;
    const prevValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(valueRef.current);
    useSafeLayoutEffect({
        "useBindable.useSafeLayoutEffect": ()=>{
            prevValue.current = valueRef.current;
        }
    }["useBindable.useSafeLayoutEffect"], [
        value,
        props().value
    ]);
    const setFn = (value2)=>{
        const prev = prevValue.current;
        const next = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(value2) ? value2(prev) : value2;
        if (props().debug) {
            console.log("[bindable > ".concat(props().debug, "] setValue"), {
                next,
                prev
            });
        }
        if (!controlled) setValue(next);
        if (!eq(next, prev)) {
            var _props_onChange, _props;
            (_props_onChange = (_props = props()).onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(_props, next, prev);
        }
    };
    function get() {
        return controlled ? props().value : value;
    }
    return {
        initial: initialValue,
        ref: valueRef,
        get,
        set (value2) {
            const exec = props().sync ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flushSync"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"];
            exec(()=>setFn(value2));
        },
        invoke (nextValue, prevValue2) {
            var _props_onChange, _props;
            (_props_onChange = (_props = props()).onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(_props, nextValue, prevValue2);
        },
        hash (value2) {
            var _props_hash, _props;
            var _props_hash1;
            return (_props_hash1 = (_props_hash = (_props = props()).hash) === null || _props_hash === void 0 ? void 0 : _props_hash.call(_props, value2)) !== null && _props_hash1 !== void 0 ? _props_hash1 : String(value2);
        }
    };
}
useBindable.cleanup = (fn)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>fn, []);
};
useBindable.ref = (defaultValue)=>{
    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(defaultValue);
    return {
        get: ()=>value.current,
        set: (next)=>{
            value.current = next;
        }
    };
};
function useRefs(refs) {
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(refs);
    return {
        get (key) {
            return ref.current[key];
        },
        set (key, value) {
            ref.current[key] = value;
        }
    };
}
var useTrack = (deps, effect)=>{
    const render = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    const called = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(false);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTrack.useEffect": ()=>{
            const mounted = render.current;
            const run = mounted && called.current;
            if (run) return effect();
            called.current = true;
        }
    }["useTrack.useEffect"], [
        ...(deps !== null && deps !== void 0 ? deps : []).map({
            "useTrack.useEffect": (d)=>typeof d === "function" ? d() : d
        }["useTrack.useEffect"])
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useTrack.useEffect": ()=>{
            render.current = true;
            return ({
                "useTrack.useEffect": ()=>{
                    render.current = false;
                }
            })["useTrack.useEffect"];
        }
    }["useTrack.useEffect"], []);
};
// src/machine.ts
function useMachine(machine) {
    let userProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _machine_props, _machine_context, _machine_refs, _machine_watch;
    const scope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useMachine.useMemo[scope]": ()=>{
            const { id, ids, getRootNode } = userProps;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createScope"])({
                id,
                ids,
                getRootNode
            });
        }
    }["useMachine.useMemo[scope]"], [
        userProps
    ]);
    const debug = function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (machine.debug) console.log(...args);
    };
    var _machine_props1;
    const props = (_machine_props1 = (_machine_props = machine.props) === null || _machine_props === void 0 ? void 0 : _machine_props.call(machine, {
        props: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compact"])(userProps),
        scope
    })) !== null && _machine_props1 !== void 0 ? _machine_props1 : userProps;
    const prop = useProp(props);
    const context = (_machine_context = machine.context) === null || _machine_context === void 0 ? void 0 : _machine_context.call(machine, {
        prop,
        bindable: useBindable,
        scope,
        flush,
        getContext () {
            return ctx;
        },
        getComputed () {
            return computed;
        },
        getRefs () {
            return refs;
        }
    });
    const contextRef = useLiveRef(context);
    const ctx = {
        get (key) {
            var _contextRef_current;
            return (_contextRef_current = contextRef.current) === null || _contextRef_current === void 0 ? void 0 : _contextRef_current[key].ref.current;
        },
        set (key, value) {
            var _contextRef_current;
            (_contextRef_current = contextRef.current) === null || _contextRef_current === void 0 ? void 0 : _contextRef_current[key].set(value);
        },
        initial (key) {
            var _contextRef_current;
            return (_contextRef_current = contextRef.current) === null || _contextRef_current === void 0 ? void 0 : _contextRef_current[key].initial;
        },
        hash (key) {
            var _contextRef_current, _contextRef_current1;
            const current = (_contextRef_current = contextRef.current) === null || _contextRef_current === void 0 ? void 0 : _contextRef_current[key].get();
            return (_contextRef_current1 = contextRef.current) === null || _contextRef_current1 === void 0 ? void 0 : _contextRef_current1[key].hash(current);
        }
    };
    const effects = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(/* @__PURE__ */ new Map());
    const transitionRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const previousEventRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(null);
    const eventRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])({
        type: ""
    });
    const getEvent = ()=>({
            ...eventRef.current,
            current () {
                return eventRef.current;
            },
            previous () {
                return previousEventRef.current;
            }
        });
    const getState = ()=>({
            ...state,
            matches () {
                for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){
                    values[_key] = arguments[_key];
                }
                return values.includes(state.ref.current);
            },
            hasTag (tag) {
                var _machine_states_state_ref_current_tags, _machine_states_state_ref_current;
                return !!((_machine_states_state_ref_current = machine.states[state.ref.current]) === null || _machine_states_state_ref_current === void 0 ? void 0 : (_machine_states_state_ref_current_tags = _machine_states_state_ref_current.tags) === null || _machine_states_state_ref_current_tags === void 0 ? void 0 : _machine_states_state_ref_current_tags.includes(tag));
            }
        });
    var _machine_refs1;
    const refs = useRefs((_machine_refs1 = (_machine_refs = machine.refs) === null || _machine_refs === void 0 ? void 0 : _machine_refs.call(machine, {
        prop,
        context: ctx
    })) !== null && _machine_refs1 !== void 0 ? _machine_refs1 : {});
    const getParams = ()=>({
            state: getState(),
            context: ctx,
            event: getEvent(),
            prop,
            send,
            action,
            guard,
            track: useTrack,
            refs,
            computed,
            flush,
            scope,
            choose
        });
    const action = (keys)=>{
        const strs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(keys) ? keys(getParams()) : keys;
        if (!strs) return;
        const fns = strs.map((s)=>{
            var _machine_implementations_actions, _machine_implementations;
            const fn = (_machine_implementations = machine.implementations) === null || _machine_implementations === void 0 ? void 0 : (_machine_implementations_actions = _machine_implementations.actions) === null || _machine_implementations_actions === void 0 ? void 0 : _machine_implementations_actions[s];
            if (!fn) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])('[zag-js] No implementation found for action "'.concat(JSON.stringify(s), '"'));
            return fn;
        });
        for (const fn of fns){
            fn === null || fn === void 0 ? void 0 : fn(getParams());
        }
    };
    const guard = (str)=>{
        var _machine_implementations_guards, _machine_implementations;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(str)) return str(getParams());
        return (_machine_implementations = machine.implementations) === null || _machine_implementations === void 0 ? void 0 : (_machine_implementations_guards = _machine_implementations.guards) === null || _machine_implementations_guards === void 0 ? void 0 : _machine_implementations_guards[str](getParams());
    };
    const effect = (keys)=>{
        const strs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(keys) ? keys(getParams()) : keys;
        if (!strs) return;
        const fns = strs.map((s)=>{
            var _machine_implementations_effects, _machine_implementations;
            const fn = (_machine_implementations = machine.implementations) === null || _machine_implementations === void 0 ? void 0 : (_machine_implementations_effects = _machine_implementations.effects) === null || _machine_implementations_effects === void 0 ? void 0 : _machine_implementations_effects[s];
            if (!fn) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])('[zag-js] No implementation found for effect "'.concat(JSON.stringify(s), '"'));
            return fn;
        });
        const cleanups = [];
        for (const fn of fns){
            const cleanup = fn === null || fn === void 0 ? void 0 : fn(getParams());
            if (cleanup) cleanups.push(cleanup);
        }
        return ()=>cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
    const choose = (transitions)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(transitions).find((t)=>{
            let result = !t.guard;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isString"])(t.guard)) result = !!guard(t.guard);
            else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(t.guard)) result = t.guard(getParams());
            return result;
        });
    };
    const computed = (key)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ensure"])(machine.computed, ()=>"[zag-js] No computed object found on machine");
        const fn = machine.computed[key];
        return fn({
            context: ctx,
            event: getEvent(),
            prop,
            refs,
            scope,
            computed
        });
    };
    const state = useBindable({
        "useMachine.useBindable[state]": ()=>({
                defaultValue: machine.initialState({
                    prop
                }),
                onChange (nextState, prevState) {
                    var _transitionRef_current, _machine_states_nextState, _machine_states_nextState1;
                    if (prevState) {
                        const exitEffects = effects.current.get(prevState);
                        exitEffects === null || exitEffects === void 0 ? void 0 : exitEffects();
                        effects.current.delete(prevState);
                    }
                    if (prevState) {
                        var _machine_states_prevState;
                        action((_machine_states_prevState = machine.states[prevState]) === null || _machine_states_prevState === void 0 ? void 0 : _machine_states_prevState.exit);
                    }
                    action((_transitionRef_current = transitionRef.current) === null || _transitionRef_current === void 0 ? void 0 : _transitionRef_current.actions);
                    const cleanup = effect((_machine_states_nextState = machine.states[nextState]) === null || _machine_states_nextState === void 0 ? void 0 : _machine_states_nextState.effects);
                    if (cleanup) effects.current.set(nextState, cleanup);
                    if (prevState === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["INIT_STATE"]) {
                        action(machine.entry);
                        const cleanup2 = effect(machine.effects);
                        if (cleanup2) effects.current.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["INIT_STATE"], cleanup2);
                    }
                    action((_machine_states_nextState1 = machine.states[nextState]) === null || _machine_states_nextState1 === void 0 ? void 0 : _machine_states_nextState1.entry);
                }
            })
    }["useMachine.useBindable[state]"]);
    const hydratedStateRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(void 0);
    const statusRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MachineStatus"].NotStarted);
    useSafeLayoutEffect({
        "useMachine.useSafeLayoutEffect": ()=>{
            queueMicrotask({
                "useMachine.useSafeLayoutEffect": ()=>{
                    const started = statusRef.current === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MachineStatus"].Started;
                    statusRef.current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MachineStatus"].Started;
                    debug(started ? "rehydrating..." : "initializing...");
                    var _hydratedStateRef_current;
                    const initialState = (_hydratedStateRef_current = hydratedStateRef.current) !== null && _hydratedStateRef_current !== void 0 ? _hydratedStateRef_current : state.initial;
                    state.invoke(initialState, started ? state.get() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["INIT_STATE"]);
                }
            }["useMachine.useSafeLayoutEffect"]);
            const fns = effects.current;
            const currentState = state.ref.current;
            return ({
                "useMachine.useSafeLayoutEffect": ()=>{
                    debug("unmounting...");
                    hydratedStateRef.current = currentState;
                    statusRef.current = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MachineStatus"].Stopped;
                    fns.forEach({
                        "useMachine.useSafeLayoutEffect": (fn)=>fn === null || fn === void 0 ? void 0 : fn()
                    }["useMachine.useSafeLayoutEffect"]);
                    effects.current = /* @__PURE__ */ new Map();
                    transitionRef.current = null;
                    queueMicrotask({
                        "useMachine.useSafeLayoutEffect": ()=>{
                            action(machine.exit);
                        }
                    }["useMachine.useSafeLayoutEffect"]);
                }
            })["useMachine.useSafeLayoutEffect"];
        }
    }["useMachine.useSafeLayoutEffect"], []);
    const getCurrentState = ()=>{
        if ("ref" in state) return state.ref.current;
        return state.get();
    };
    const send = (event)=>{
        queueMicrotask(()=>{
            var // @ts-ignore
            _machine_states_currentState_on, // @ts-ignore
            _machine_on;
            if (statusRef.current !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MachineStatus"].Started) return;
            previousEventRef.current = eventRef.current;
            eventRef.current = event;
            debug("send", event);
            let currentState = getCurrentState();
            var _machine_states_currentState_on_event_type;
            const transitions = (_machine_states_currentState_on_event_type = (_machine_states_currentState_on = machine.states[currentState].on) === null || _machine_states_currentState_on === void 0 ? void 0 : _machine_states_currentState_on[event.type]) !== null && _machine_states_currentState_on_event_type !== void 0 ? _machine_states_currentState_on_event_type : (_machine_on = machine.on) === null || _machine_on === void 0 ? void 0 : _machine_on[event.type];
            const transition = choose(transitions);
            if (!transition) return;
            transitionRef.current = transition;
            var _transition_target;
            const target = (_transition_target = transition.target) !== null && _transition_target !== void 0 ? _transition_target : currentState;
            debug("transition", transition);
            const changed = target !== currentState;
            if (changed) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flushSync"])(()=>state.set(target));
            } else if (transition.reenter && !changed) {
                state.invoke(currentState, currentState);
            } else {
                var _transition_actions;
                action((_transition_actions = transition.actions) !== null && _transition_actions !== void 0 ? _transition_actions : []);
            }
        });
    };
    (_machine_watch = machine.watch) === null || _machine_watch === void 0 ? void 0 : _machine_watch.call(machine, getParams());
    return {
        state: getState(),
        send,
        context: ctx,
        prop,
        scope,
        refs,
        computed,
        event: getEvent(),
        getStatus: ()=>statusRef.current
    };
}
function useLiveRef(value) {
    const ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(value);
    ref.current = value;
    return ref;
}
function useProp(value) {
    const ref = useLiveRef(value);
    return function get(key) {
        return ref.current[key];
    };
}
function flush(fn) {
    queueMicrotask(()=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flushSync"])(()=>fn());
    });
}
var normalizeProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNormalizer"])((v)=>v);
var Portal = (props)=>{
    const { children, container, disabled, getRootNode } = props;
    const isServer = typeof window === "undefined";
    if (isServer || disabled) return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children
    });
    var _getRootNode_ownerDocument;
    const doc = (_getRootNode_ownerDocument = getRootNode === null || getRootNode === void 0 ? void 0 : getRootNode().ownerDocument) !== null && _getRootNode_ownerDocument !== void 0 ? _getRootNode_ownerDocument : document;
    var _container_current;
    const mountNode = (_container_current = container === null || container === void 0 ? void 0 : container.current) !== null && _container_current !== void 0 ? _container_current : doc.body;
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Children"].map(children, (child)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPortal"])(child, mountNode))
    });
};
;
}),
"[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/create-anatomy.ts
__turbopack_context__.s({
    "createAnatomy": ()=>createAnatomy
});
var createAnatomy = function(name) {
    let parts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return {
        parts: function() {
            for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){
                values[_key] = arguments[_key];
            }
            if (isEmpty(parts)) {
                return createAnatomy(name, values);
            }
            throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
        },
        extendWith: function() {
            for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){
                values[_key] = arguments[_key];
            }
            return createAnatomy(name, [
                ...parts,
                ...values
            ]);
        },
        rename: (newName)=>createAnatomy(newName, parts),
        keys: ()=>parts,
        build: ()=>[
                ...new Set(parts)
            ].reduce((prev, part)=>Object.assign(prev, {
                    [part]: {
                        selector: [
                            '&[data-scope="'.concat(toKebabCase(name), '"][data-part="').concat(toKebabCase(part), '"]'),
                            '& [data-scope="'.concat(toKebabCase(name), '"][data-part="').concat(toKebabCase(part), '"]')
                        ].join(", "),
                        attrs: {
                            "data-scope": toKebabCase(name),
                            "data-part": toKebabCase(part)
                        }
                    }
                }), {})
    };
};
var toKebabCase = (value)=>value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v)=>v.length === 0;
;
}),
"[project]/node_modules/@zag-js/popper/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "arrow": ()=>arrow,
    "autoPlacement": ()=>autoPlacement,
    "autoUpdate": ()=>autoUpdate,
    "computePosition": ()=>computePosition,
    "detectOverflow": ()=>detectOverflow,
    "flip": ()=>flip,
    "hide": ()=>hide,
    "inline": ()=>inline,
    "limitShift": ()=>limitShift,
    "offset": ()=>offset,
    "platform": ()=>platform,
    "shift": ()=>shift,
    "size": ()=>size
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@floating-ui/core/dist/floating-ui.core.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-client] (ecmascript)");
;
;
;
;
function getCssDimensions(element) {
    const css = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element);
    // In testing environments, the `width` and `height` properties are empty
    // strings for SVG elements, returning NaN. Fallback to `0` in this case.
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"])(width) !== offsetWidth || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"])(height) !== offsetHeight;
    if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
    }
    return {
        width,
        height,
        $: shouldFallback
    };
}
function unwrapElement(element) {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(element) ? element.contextElement : element;
}
function getScale(element) {
    const domElement = unwrapElement(element);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(domElement)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    }
    const rect = domElement.getBoundingClientRect();
    const { width, height, $ } = getCssDimensions(domElement);
    let x = ($ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"])(rect.width) : rect.width) / width;
    let y = ($ ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["round"])(rect.height) : rect.height) / height;
    // 0, NaN, or Infinity should always fallback to 1.
    if (!x || !Number.isFinite(x)) {
        x = 1;
    }
    if (!y || !Number.isFinite(y)) {
        y = 1;
    }
    return {
        x,
        y
    };
}
const noOffsets = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
function getVisualOffsets(element) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(element);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWebKit"])() || !win.visualViewport) {
        return noOffsets;
    }
    return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
    };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
        isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(element)) {
        return false;
    }
    return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
        includeScale = false;
    }
    if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    if (includeScale) {
        if (offsetParent) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(offsetParent)) {
                scale = getScale(offsetParent);
            }
        } else {
            scale = getScale(element);
        }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
        const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(domElement);
        const offsetWin = offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(offsetParent) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(offsetParent) : offsetParent;
        let currentWin = win;
        let currentIFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFrameElement"])(currentWin);
        while(currentIFrame && offsetParent && offsetWin !== currentWin){
            const iframeScale = getScale(currentIFrame);
            const iframeRect = currentIFrame.getBoundingClientRect();
            const css = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(currentIFrame);
            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
            x *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x += left;
            y += top;
            currentWin = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(currentIFrame);
            currentIFrame = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFrameElement"])(currentWin);
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rectToClientRect"])({
        width,
        height,
        x,
        y
    });
}
// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
    const leftScroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(element).scrollLeft;
    if (!rect) {
        return getBoundingClientRect((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
        ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect));
    const y = htmlRect.top + scroll.scrollTop;
    return {
        x,
        y
    };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let { elements, rect, offsetParent, strategy } = _ref;
    const isFixed = strategy === 'fixed';
    const documentElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(offsetParent);
    const topLayer = elements ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTopLayer"])(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
        return rect;
    }
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    let scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    const offsets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    const isOffsetParentAnElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeName"])(offsetParent) !== 'body' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOverflowElement"])(documentElement)) {
            scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(offsetParent);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
}
function getClientRects(element) {
    return Array.from(element.getClientRects());
}
// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
    const html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    const scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(element);
    const body = element.ownerDocument.body;
    const width = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(body).direction === 'rtl') {
        x += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(html.clientWidth, body.clientWidth) - width;
    }
    return {
        width,
        height,
        x,
        y
    };
}
function getViewportRect(element, strategy) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(element);
    const html = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWebKit"])();
        if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width,
        height,
        x,
        y
    };
}
// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element) ? getScale(element) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
        width,
        height,
        x,
        y
    };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === 'viewport') {
        rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === 'document') {
        rect = getDocumentRect((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element));
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(clippingAncestor)) {
        rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y,
            width: clippingAncestor.width,
            height: clippingAncestor.height
        };
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rectToClientRect"])(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getParentNode"])(element);
    if (parentNode === stopNode || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(parentNode) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(parentNode)) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}
// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
        return cachedResult;
    }
    let result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(element, [], false).filter((el)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(el) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeName"])(el) !== 'body');
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'fixed';
    let currentNode = elementIsFixed ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getParentNode"])(element) : element;
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(currentNode) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(currentNode)){
        const computedStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(currentNode);
        const currentNodeIsContaining = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isContainingBlock"])(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
            currentContainingBlockComputedStyle = null;
        }
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && [
            'absolute',
            'fixed'
        ].includes(currentContainingBlockComputedStyle.position) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOverflowElement"])(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) {
            // Drop non-containing blocks.
            result = result.filter((ancestor)=>ancestor !== currentNode);
        } else {
            // Record last containing block for next iteration.
            currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getParentNode"])(currentNode);
    }
    cache.set(element, result);
    return result;
}
// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
    let { element, boundary, rootBoundary, strategy } = _ref;
    const elementClippingAncestors = boundary === 'clippingAncestors' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTopLayer"])(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [
        ...elementClippingAncestors,
        rootBoundary
    ];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(rect.top, accRect.top);
        accRect.right = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["min"])(rect.right, accRect.right);
        accRect.bottom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["min"])(rect.bottom, accRect.bottom);
        accRect.left = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
    };
}
function getDimensions(element) {
    const { width, height } = getCssDimensions(element);
    return {
        width,
        height
    };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(offsetParent);
    const documentElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(offsetParent);
    const isFixed = strategy === 'fixed';
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const offsets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
    // Firefox with layout.scrollbar.side = 3 in about:config to test this.
    function setLeftRTLScrollbarOffset() {
        offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeName"])(offsetParent) !== 'body' || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOverflowElement"])(documentElement)) {
            scroll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNodeScroll"])(offsetParent);
        }
        if (isOffsetParentAnElement) {
            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
            setLeftRTLScrollbarOffset();
        }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
        setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCoords"])(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
        x,
        y,
        width: rect.width,
        height: rect.height
    };
}
function isStaticPositioned(element) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'static';
}
function getTrueOffsetParent(element, polyfill) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).position === 'fixed') {
        return null;
    }
    if (polyfill) {
        return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    // Firefox returns the <html> element as the offsetParent if it's non-static,
    // while Chrome and Safari return the <body> element. The <body> element must
    // be used to perform the correct calculations even if the <html> element is
    // non-static.
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element) === rawOffsetParent) {
        rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
}
// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(element);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTopLayer"])(element)) {
        return win;
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(element)) {
        let svgOffsetParent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getParentNode"])(element);
        while(svgOffsetParent && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(svgOffsetParent)){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"])(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
                return svgOffsetParent;
            }
            svgOffsetParent = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getParentNode"])(svgOffsetParent);
        }
        return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while(offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTableElement"])(offsetParent) && isStaticPositioned(offsetParent)){
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLastTraversableNode"])(offsetParent) && isStaticPositioned(offsetParent) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isContainingBlock"])(offsetParent)) {
        return win;
    }
    return offsetParent || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContainingBlock"])(element) || win;
}
const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
            x: 0,
            y: 0,
            width: floatingDimensions.width,
            height: floatingDimensions.height
        }
    };
};
function isRTL(element) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(element).direction === 'rtl';
}
const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"],
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isElement"],
    isRTL
};
function rectsAreEqual(a, b) {
    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocumentElement"])(element);
    function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        (_io = io) == null || _io.disconnect();
        io = null;
    }
    function refresh(skip, threshold) {
        if (skip === void 0) {
            skip = false;
        }
        if (threshold === void 0) {
            threshold = 1;
        }
        cleanup();
        const elementRectForRootMargin = element.getBoundingClientRect();
        const { left, top, width, height } = elementRectForRootMargin;
        if (!skip) {
            onMove();
        }
        if (!width || !height) {
            return;
        }
        const insetTop = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(top);
        const insetRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(root.clientWidth - (left + width));
        const insetBottom = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(root.clientHeight - (top + height));
        const insetLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["floor"])(left);
        const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
            rootMargin,
            threshold: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["max"])(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["min"])(1, threshold)) || 1
        };
        let isFirstUpdate = true;
        function handleObserve(entries) {
            const ratio = entries[0].intersectionRatio;
            if (ratio !== threshold) {
                if (!isFirstUpdate) {
                    return refresh();
                }
                if (!ratio) {
                    // If the reference is clipped, the ratio is 0. Throttle the refresh
                    // to prevent an infinite loop of updates.
                    timeoutId = setTimeout(()=>{
                        refresh(false, 1e-7);
                    }, 1000);
                } else {
                    refresh(false, ratio);
                }
            }
            if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
                // It's possible that even though the ratio is reported as 1, the
                // element is not actually fully within the IntersectionObserver's root
                // area anymore. This can happen under performance constraints. This may
                // be a bug in the browser's IntersectionObserver implementation. To
                // work around this, we compare the element's bounding rect now with
                // what it was at the time we created the IntersectionObserver. If they
                // are not equal then the element moved, so we refresh.
                refresh();
            }
            isFirstUpdate = false;
        }
        // Older browsers don't support a `document` as the root and will throw an
        // error.
        try {
            io = new IntersectionObserver(handleObserve, {
                ...options,
                // Handle <iframe>s
                root: root.ownerDocument
            });
        } catch (_e) {
            io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element);
    }
    refresh(true);
    return cleanup;
}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */ function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
        options = {};
    }
    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === 'function', layoutShift = typeof IntersectionObserver === 'function', animationFrame = false } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [
        ...referenceEl ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(referenceEl) : [],
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getOverflowAncestors"])(floating)
    ] : [];
    ancestors.forEach((ancestor)=>{
        ancestorScroll && ancestor.addEventListener('scroll', update, {
            passive: true
        });
        ancestorResize && ancestor.addEventListener('resize', update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
        resizeObserver = new ResizeObserver((_ref)=>{
            let [firstEntry] = _ref;
            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
                // Prevent update loops when using the `size` middleware.
                // https://github.com/floating-ui/floating-ui/issues/1740
                resizeObserver.unobserve(floating);
                cancelAnimationFrame(reobserveFrame);
                reobserveFrame = requestAnimationFrame(()=>{
                    var _resizeObserver;
                    (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
                });
            }
            update();
        });
        if (referenceEl && !animationFrame) {
            resizeObserver.observe(referenceEl);
        }
        resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
        frameLoop();
    }
    function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
            update();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return ()=>{
        var _resizeObserver2;
        ancestors.forEach((ancestor)=>{
            ancestorScroll && ancestor.removeEventListener('scroll', update);
            ancestorResize && ancestor.removeEventListener('resize', update);
        });
        cleanupIo == null || cleanupIo();
        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
        resizeObserver = null;
        if (animationFrame) {
            cancelAnimationFrame(frameId);
        }
    };
}
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */ const detectOverflow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["detectOverflow"];
/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */ const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["offset"];
/**
 * Optimizes the visibility of the floating element by choosing the placement
 * that has the most space available automatically, without needing to specify a
 * preferred placement. Alternative to `flip`.
 * @see https://floating-ui.com/docs/autoPlacement
 */ const autoPlacement = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["autoPlacement"];
/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */ const shift = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["shift"];
/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */ const flip = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["flip"];
/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */ const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"];
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */ const hide = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hide"];
/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */ const arrow = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["arrow"];
/**
 * Provides improved positioning for inline reference elements that can span
 * over multiple lines, such as hyperlinks or range selections.
 * @see https://floating-ui.com/docs/inline
 */ const inline = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["inline"];
/**
 * Built-in `limiter` that will stop `shift()` at a certain point.
 */ const limitShift = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["limitShift"];
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */ const computePosition = (reference, floating, options)=>{
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
        platform,
        ...options
    };
    const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["computePosition"])(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache
    });
};
;
}),
"[project]/node_modules/@zag-js/popper/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "getPlacement": ()=>getPlacement,
    "getPlacementSide": ()=>getPlacementSide,
    "getPlacementStyles": ()=>getPlacementStyles,
    "isValidPlacement": ()=>isValidPlacement
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/popper/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)");
;
;
;
// src/get-placement.ts
function createDOMRect() {
    let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, width = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    if (typeof DOMRect === "function") {
        return new DOMRect(x, y, width, height);
    }
    const rect = {
        x,
        y,
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x
    };
    return {
        ...rect,
        toJSON: ()=>rect
    };
}
function getDOMRect(anchorRect) {
    if (!anchorRect) return createDOMRect();
    const { x, y, width, height } = anchorRect;
    return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
    return {
        contextElement: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(anchorElement) ? anchorElement : void 0,
        getBoundingClientRect: ()=>{
            const anchor = anchorElement;
            const anchorRect = getAnchorRect === null || getAnchorRect === void 0 ? void 0 : getAnchorRect(anchor);
            if (anchorRect || !anchor) {
                return getDOMRect(anchorRect);
            }
            return anchor.getBoundingClientRect();
        }
    };
}
// src/middleware.ts
var toVar = (value)=>({
        variable: value,
        reference: "var(".concat(value, ")")
    });
var cssVars = {
    arrowSize: toVar("--arrow-size"),
    arrowSizeHalf: toVar("--arrow-size-half"),
    arrowBg: toVar("--arrow-background"),
    transformOrigin: toVar("--transform-origin"),
    arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow2)=>({
        top: "bottom center",
        "top-start": arrow2 ? "".concat(arrow2.x, "px bottom") : "left bottom",
        "top-end": arrow2 ? "".concat(arrow2.x, "px bottom") : "right bottom",
        bottom: "top center",
        "bottom-start": arrow2 ? "".concat(arrow2.x, "px top") : "top left",
        "bottom-end": arrow2 ? "".concat(arrow2.x, "px top") : "top right",
        left: "right center",
        "left-start": arrow2 ? "right ".concat(arrow2.y, "px") : "right top",
        "left-end": arrow2 ? "right ".concat(arrow2.y, "px") : "right bottom",
        right: "left center",
        "right-start": arrow2 ? "left ".concat(arrow2.y, "px") : "left top",
        "right-end": arrow2 ? "left ".concat(arrow2.y, "px") : "left bottom"
    });
var transformOriginMiddleware = {
    name: "transformOrigin",
    fn (param) {
        let { placement, elements, middlewareData } = param;
        const { arrow: arrow2 } = middlewareData;
        const transformOrigin = getTransformOrigin(arrow2)[placement];
        const { floating } = elements;
        floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
        return {
            data: {
                transformOrigin
            }
        };
    }
};
var rectMiddleware = {
    name: "rects",
    fn (param) {
        let { rects } = param;
        return {
            data: rects
        };
    }
};
var shiftArrowMiddleware = (arrowEl)=>{
    if (!arrowEl) return;
    return {
        name: "shiftArrow",
        fn (param) {
            let { placement, middlewareData } = param;
            if (!middlewareData.arrow) return {};
            const { x, y } = middlewareData.arrow;
            const dir = placement.split("-")[0];
            Object.assign(arrowEl.style, {
                left: x != null ? "".concat(x, "px") : "",
                top: y != null ? "".concat(y, "px") : "",
                [dir]: "calc(100% + ".concat(cssVars.arrowOffset.reference, ")")
            });
            return {};
        }
    };
};
// src/placement.ts
function isValidPlacement(v) {
    return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v);
}
function getPlacementDetails(placement) {
    const [side, align] = placement.split("-");
    return {
        side,
        align,
        hasAlign: align != null
    };
}
function getPlacementSide(placement) {
    return placement.split("-")[0];
}
// src/get-placement.ts
var defaultOptions = {
    strategy: "absolute",
    placement: "bottom",
    listeners: true,
    gutter: 8,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    overflowPadding: 8,
    arrowPadding: 4
};
function roundByDpr(win, value) {
    const dpr = win.devicePixelRatio || 1;
    return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["runIfFn"])(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
    if (!arrowElement) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["arrow"])({
        element: arrowElement,
        padding: opts.arrowPadding
    });
}
function getOffsetMiddleware(arrowElement, opts) {
    var _opts_offset;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNull"])((_opts_offset = opts.offset) !== null && _opts_offset !== void 0 ? _opts_offset : opts.gutter)) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["offset"])((param)=>{
        let { placement } = param;
        var _opts_offset, _opts_offset1;
        const arrowOffset = ((arrowElement === null || arrowElement === void 0 ? void 0 : arrowElement.clientHeight) || 0) / 2;
        var _opts_offset_mainAxis;
        const gutter = (_opts_offset_mainAxis = (_opts_offset = opts.offset) === null || _opts_offset === void 0 ? void 0 : _opts_offset.mainAxis) !== null && _opts_offset_mainAxis !== void 0 ? _opts_offset_mainAxis : opts.gutter;
        const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter !== null && gutter !== void 0 ? gutter : arrowOffset;
        const { hasAlign } = getPlacementDetails(placement);
        const shift2 = !hasAlign ? opts.shift : void 0;
        var _opts_offset_crossAxis;
        const crossAxis = (_opts_offset_crossAxis = (_opts_offset1 = opts.offset) === null || _opts_offset1 === void 0 ? void 0 : _opts_offset1.crossAxis) !== null && _opts_offset_crossAxis !== void 0 ? _opts_offset_crossAxis : shift2;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compact"])({
            crossAxis,
            mainAxis,
            alignmentAxis: opts.shift
        });
    });
}
function getFlipMiddleware(opts) {
    if (!opts.flip) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["flip"])({
        boundary: getBoundaryMiddleware(opts),
        padding: opts.overflowPadding,
        fallbackPlacements: opts.flip === true ? void 0 : opts.flip
    });
}
function getShiftMiddleware(opts) {
    if (!opts.slide && !opts.overlap) return;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["shift"])({
        boundary: getBoundaryMiddleware(opts),
        mainAxis: opts.slide,
        crossAxis: opts.overlap,
        padding: opts.overflowPadding,
        limiter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["limitShift"])()
    });
}
function getSizeMiddleware(opts) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"])({
        padding: opts.overflowPadding,
        apply (param) {
            let { elements, rects, availableHeight, availableWidth } = param;
            const floating = elements.floating;
            const referenceWidth = Math.round(rects.reference.width);
            availableWidth = Math.floor(availableWidth);
            availableHeight = Math.floor(availableHeight);
            floating.style.setProperty("--reference-width", "".concat(referenceWidth, "px"));
            floating.style.setProperty("--available-width", "".concat(availableWidth, "px"));
            floating.style.setProperty("--available-height", "".concat(availableHeight, "px"));
        }
    });
}
function hideWhenDetachedMiddleware(opts) {
    var _opts_boundary;
    if (!opts.hideWhenDetached) return;
    var _opts_boundary1;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hide"])({
        strategy: "referenceHidden",
        boundary: (_opts_boundary1 = (_opts_boundary = opts.boundary) === null || _opts_boundary === void 0 ? void 0 : _opts_boundary.call(opts)) !== null && _opts_boundary1 !== void 0 ? _opts_boundary1 : "clippingAncestors"
    });
}
function getAutoUpdateOptions(opts) {
    if (!opts) return {};
    if (opts === true) {
        return {
            ancestorResize: true,
            ancestorScroll: true,
            elementResize: true,
            layoutShift: true
        };
    }
    return opts;
}
function getPlacementImpl(referenceOrVirtual, floating) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
    if (!floating || !reference) return;
    const options = Object.assign({}, defaultOptions, opts);
    const arrowEl = floating.querySelector("[data-part=arrow]");
    const middleware = [
        getOffsetMiddleware(arrowEl, options),
        getFlipMiddleware(options),
        getShiftMiddleware(options),
        getArrowMiddleware(arrowEl, options),
        shiftArrowMiddleware(arrowEl),
        transformOriginMiddleware,
        getSizeMiddleware(options),
        hideWhenDetachedMiddleware(options),
        rectMiddleware
    ];
    const { placement, strategy, onComplete, onPositioned } = options;
    const updatePosition = async ()=>{
        if (!reference || !floating) return;
        const pos = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["computePosition"])(reference, floating, {
            placement,
            middleware,
            strategy
        });
        onComplete === null || onComplete === void 0 ? void 0 : onComplete(pos);
        onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned({
            placed: true
        });
        const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(floating);
        const x = roundByDpr(win, pos.x);
        const y = roundByDpr(win, pos.y);
        floating.style.setProperty("--x", "".concat(x, "px"));
        floating.style.setProperty("--y", "".concat(y, "px"));
        if (options.hideWhenDetached) {
            var _pos_middlewareData_hide;
            const isHidden = (_pos_middlewareData_hide = pos.middlewareData.hide) === null || _pos_middlewareData_hide === void 0 ? void 0 : _pos_middlewareData_hide.referenceHidden;
            if (isHidden) {
                floating.style.setProperty("visibility", "hidden");
                floating.style.setProperty("pointer-events", "none");
            } else {
                floating.style.removeProperty("visibility");
                floating.style.removeProperty("pointer-events");
            }
        }
        const contentEl = floating.firstElementChild;
        if (contentEl) {
            const styles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(contentEl);
            floating.style.setProperty("--z-index", styles.zIndex);
        }
    };
    const update = async ()=>{
        if (opts.updatePosition) {
            await opts.updatePosition({
                updatePosition
            });
            onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned({
                placed: true
            });
        } else {
            await updatePosition();
        }
    };
    const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
    const cancelAutoUpdate = options.listeners ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["autoUpdate"])(reference, floating, update, autoUpdateOptions) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noop"];
    update();
    return ()=>{
        cancelAutoUpdate === null || cancelAutoUpdate === void 0 ? void 0 : cancelAutoUpdate();
        onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned({
            placed: false
        });
    };
}
function getPlacement(referenceOrFn, floatingOrFn) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const { defer, ...options } = opts;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
        const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
        cleanups.push(getPlacementImpl(reference, floating, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
// src/get-styles.ts
var ARROW_FLOATING_STYLE = {
    bottom: "rotate(45deg)",
    left: "rotate(135deg)",
    top: "rotate(225deg)",
    right: "rotate(315deg)"
};
function getPlacementStyles() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
    return {
        arrow: {
            position: "absolute",
            width: cssVars.arrowSize.reference,
            height: cssVars.arrowSize.reference,
            [cssVars.arrowSizeHalf.variable]: "calc(".concat(cssVars.arrowSize.reference, " / 2)"),
            [cssVars.arrowOffset.variable]: "calc(".concat(cssVars.arrowSizeHalf.reference, " * -1)")
        },
        arrowTip: {
            // @ts-expect-error - Fix this
            transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
            background: cssVars.arrowBg.reference,
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
            position: "absolute",
            zIndex: "inherit"
        },
        floating: {
            position: strategy,
            isolation: "isolate",
            minWidth: sameWidth ? void 0 : "max-content",
            width: sameWidth ? "var(--reference-width)" : void 0,
            maxWidth: fitViewport ? "var(--available-width)" : void 0,
            maxHeight: fitViewport ? "var(--available-height)" : void 0,
            pointerEvents: !placement ? "none" : void 0,
            top: "0px",
            left: "0px",
            // move off-screen if placement is not defined
            transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
            zIndex: "var(--z-index)"
        }
    };
}
;
}),
"[project]/node_modules/@zag-js/interact-outside/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "trackInteractOutside": ()=>trackInteractOutside
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)");
;
;
// src/index.ts
// src/frame-utils.ts
function getWindowFrames(win) {
    const frames = {
        each (cb) {
            var _win_frames;
            for(let i = 0; i < ((_win_frames = win.frames) === null || _win_frames === void 0 ? void 0 : _win_frames.length); i += 1){
                const frame = win.frames[i];
                if (frame) cb(frame);
            }
        },
        addEventListener (event, listener, options) {
            frames.each((frame)=>{
                try {
                    frame.document.addEventListener(event, listener, options);
                } catch (e) {}
            });
            return ()=>{
                try {
                    frames.removeEventListener(event, listener, options);
                } catch (e) {}
            };
        },
        removeEventListener (event, listener, options) {
            frames.each((frame)=>{
                try {
                    frame.document.removeEventListener(event, listener, options);
                } catch (e) {}
            });
        }
    };
    return frames;
}
function getParentWindow(win) {
    const parent = win.frameElement != null ? win.parent : null;
    return {
        addEventListener: (event, listener, options)=>{
            try {
                parent === null || parent === void 0 ? void 0 : parent.addEventListener(event, listener, options);
            } catch (e) {}
            return ()=>{
                try {
                    parent === null || parent === void 0 ? void 0 : parent.removeEventListener(event, listener, options);
                } catch (e) {}
            };
        },
        removeEventListener: (event, listener, options)=>{
            try {
                parent === null || parent === void 0 ? void 0 : parent.removeEventListener(event, listener, options);
            } catch (e) {}
        }
    };
}
// src/index.ts
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
    for (const node of composedPath){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(node) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(node)) return true;
    }
    return false;
}
var isPointerEvent = (event)=>"clientY" in event;
function isEventPointWithin(node, event) {
    if (!isPointerEvent(event) || !node) return false;
    const rect = node.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return false;
    return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
    return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
    if (!ancestor || !isPointerEvent(event)) return false;
    const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
    const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
    const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
    const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
    const rect = {
        x: ancestor.offsetLeft,
        y: ancestor.offsetTop,
        width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
        height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
    };
    const point = {
        x: event.clientX,
        y: event.clientY
    };
    if (!isPointInRect(rect, point)) return false;
    return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options) {
    const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
    if (!node) return;
    const doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])(node);
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(node);
    const frames = getWindowFrames(win);
    const parentWin = getParentWindow(win);
    function isEventOutside(event, target) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(target)) return false;
        if (!target.isConnected) return false;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(node, target)) return false;
        if (isEventPointWithin(node, event)) return false;
        const triggerEl = doc.querySelector('[aria-controls="'.concat(node.id, '"]'));
        if (triggerEl) {
            const triggerAncestor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNearestOverflowAncestor"])(triggerEl);
            if (isEventWithinScrollbar(event, triggerAncestor)) return false;
        }
        const nodeAncestor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNearestOverflowAncestor"])(node);
        if (isEventWithinScrollbar(event, nodeAncestor)) return false;
        return !(exclude === null || exclude === void 0 ? void 0 : exclude(target));
    }
    const pointerdownCleanups = /* @__PURE__ */ new Set();
    const isInShadowRoot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isShadowRoot"])(node === null || node === void 0 ? void 0 : node.getRootNode());
    function onPointerDown(event) {
        function handler(clickEvent) {
            var _evt_composedPath;
            const func = defer && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTouchDevice"])() ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
            const evt = clickEvent !== null && clickEvent !== void 0 ? clickEvent : event;
            var _evt_composedPath1;
            const composedPath = (_evt_composedPath1 = evt === null || evt === void 0 ? void 0 : (_evt_composedPath = evt.composedPath) === null || _evt_composedPath === void 0 ? void 0 : _evt_composedPath.call(evt)) !== null && _evt_composedPath1 !== void 0 ? _evt_composedPath1 : [
                evt === null || evt === void 0 ? void 0 : evt.target
            ];
            func(()=>{
                const target = isInShadowRoot ? composedPath[0] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
                if (!node || !isEventOutside(event, target)) return;
                if (onPointerDownOutside || onInteractOutside) {
                    const handler2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callAll"])(onPointerDownOutside, onInteractOutside);
                    node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, {
                        once: true
                    });
                }
                fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
                    bubbles: false,
                    cancelable: true,
                    detail: {
                        originalEvent: evt,
                        contextmenu: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isContextMenuEvent"])(evt),
                        focusable: isComposedPathFocusable(composedPath),
                        target
                    }
                });
            });
        }
        if (event.pointerType === "touch") {
            pointerdownCleanups.forEach((fn)=>fn());
            pointerdownCleanups.add((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "click", handler, {
                once: true
            }));
            pointerdownCleanups.add(parentWin.addEventListener("click", handler, {
                once: true
            }));
            pointerdownCleanups.add(frames.addEventListener("click", handler, {
                once: true
            }));
        } else {
            handler();
        }
    }
    const cleanups = /* @__PURE__ */ new Set();
    const timer = setTimeout(()=>{
        cleanups.add((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "pointerdown", onPointerDown, true));
        cleanups.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
        cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
    }, 0);
    function onFocusin(event) {
        const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
        func(()=>{
            const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
            if (!node || !isEventOutside(event, target)) return;
            if (onFocusOutside || onInteractOutside) {
                const handler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["callAll"])(onFocusOutside, onInteractOutside);
                node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
                    once: true
                });
            }
            fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
                bubbles: false,
                cancelable: true,
                detail: {
                    originalEvent: event,
                    contextmenu: false,
                    focusable: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(target),
                    target
                }
            });
        });
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTouchDevice"])()) {
        cleanups.add((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "focusin", onFocusin, true));
        cleanups.add(parentWin.addEventListener("focusin", onFocusin, true));
        cleanups.add(frames.addEventListener("focusin", onFocusin, true));
    }
    return ()=>{
        clearTimeout(timer);
        pointerdownCleanups.forEach((fn)=>fn());
        cleanups.forEach((fn)=>fn());
    };
}
function trackInteractOutside(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups.push(trackInteractOutsideImpl(node, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
function fireCustomEvent(el, type, init) {
    const win = el.ownerDocument.defaultView || window;
    const event = new win.CustomEvent(type, init);
    return el.dispatchEvent(event);
}
;
}),
"[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "trackDismissableBranch": ()=>trackDismissableBranch,
    "trackDismissableElement": ()=>trackDismissableElement
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$interact$2d$outside$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/interact-outside/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)");
;
;
;
// src/dismissable-layer.ts
function trackEscapeKeydown(node, fn) {
    const handleKeyDown = (event)=>{
        if (event.key !== "Escape") return;
        if (event.isComposing) return;
        fn === null || fn === void 0 ? void 0 : fn(event);
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])(node), "keydown", handleKeyDown, {
        capture: true
    });
}
var layerStack = {
    layers: [],
    branches: [],
    count () {
        return this.layers.length;
    },
    pointerBlockingLayers () {
        return this.layers.filter((layer)=>layer.pointerBlocking);
    },
    topMostPointerBlockingLayer () {
        return [
            ...this.pointerBlockingLayers()
        ].slice(-1)[0];
    },
    hasPointerBlockingLayer () {
        return this.pointerBlockingLayers().length > 0;
    },
    isBelowPointerBlockingLayer (node) {
        var _this_topMostPointerBlockingLayer;
        const index = this.indexOf(node);
        const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_this_topMostPointerBlockingLayer = this.topMostPointerBlockingLayer()) === null || _this_topMostPointerBlockingLayer === void 0 ? void 0 : _this_topMostPointerBlockingLayer.node) : -1;
        return index < highestBlockingIndex;
    },
    isTopMost (node) {
        const layer = this.layers[this.count() - 1];
        return (layer === null || layer === void 0 ? void 0 : layer.node) === node;
    },
    getNestedLayers (node) {
        return Array.from(this.layers).slice(this.indexOf(node) + 1);
    },
    isInNestedLayer (node, target) {
        return this.getNestedLayers(node).some((layer)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(layer.node, target));
    },
    isInBranch (target) {
        return Array.from(this.branches).some((branch)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(branch, target));
    },
    add (layer) {
        const num = this.layers.push(layer);
        layer.node.style.setProperty("--layer-index", "".concat(num));
    },
    addBranch (node) {
        this.branches.push(node);
    },
    remove (node) {
        const index = this.indexOf(node);
        if (index < 0) return;
        if (index < this.count() - 1) {
            const _layers = this.getNestedLayers(node);
            _layers.forEach((layer)=>layer.dismiss());
        }
        this.layers.splice(index, 1);
        node.style.removeProperty("--layer-index");
    },
    removeBranch (node) {
        const index = this.branches.indexOf(node);
        if (index >= 0) this.branches.splice(index, 1);
    },
    indexOf (node) {
        return this.layers.findIndex((layer)=>layer.node === node);
    },
    dismiss (node) {
        var _this_layers_this_indexOf;
        (_this_layers_this_indexOf = this.layers[this.indexOf(node)]) === null || _this_layers_this_indexOf === void 0 ? void 0 : _this_layers_this_indexOf.dismiss();
    },
    clear () {
        this.remove(this.layers[0].node);
    }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
    layerStack.layers.forEach((param)=>{
        let { node } = param;
        node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
    });
}
function clearPointerEvent(node) {
    node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, persistentElements) {
    const doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])(node);
    const cleanups = [];
    if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
        originalBodyPointerEvents = document.body.style.pointerEvents;
        queueMicrotask(()=>{
            doc.body.style.pointerEvents = "none";
            doc.body.setAttribute("data-inert", "");
        });
    }
    if (persistentElements) {
        const persistedCleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForElements"])(persistentElements, (el)=>{
            cleanups.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setStyle"])(el, {
                pointerEvents: "auto"
            }));
        });
        cleanups.push(persistedCleanup);
    }
    return ()=>{
        if (layerStack.hasPointerBlockingLayer()) return;
        queueMicrotask(()=>{
            doc.body.style.pointerEvents = originalBodyPointerEvents;
            doc.body.removeAttribute("data-inert");
            if (doc.body.style.length === 0) doc.body.removeAttribute("style");
        });
        cleanups.forEach((fn)=>fn());
    };
}
// src/dismissable-layer.ts
function trackDismissableElementImpl(node, options) {
    const { warnOnMissingNode = true } = options;
    if (warnOnMissingNode && !node) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("[@zag-js/dismissable] node is `null` or `undefined`");
        return;
    }
    if (!node) {
        return;
    }
    const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
    const layer = {
        dismiss: onDismiss,
        node,
        pointerBlocking
    };
    layerStack.add(layer);
    assignPointerEventToLayers();
    function onPointerDownOutside(event) {
        var _options_onPointerDownOutside, _options_onInteractOutside;
        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event.detail.originalEvent);
        if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target)) return;
        (_options_onPointerDownOutside = options.onPointerDownOutside) === null || _options_onPointerDownOutside === void 0 ? void 0 : _options_onPointerDownOutside.call(options, event);
        (_options_onInteractOutside = options.onInteractOutside) === null || _options_onInteractOutside === void 0 ? void 0 : _options_onInteractOutside.call(options, event);
        if (event.defaultPrevented) return;
        if (debug) {
            console.log("onPointerDownOutside:", event.detail.originalEvent);
        }
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
    }
    function onFocusOutside(event) {
        var _options_onFocusOutside, _options_onInteractOutside;
        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event.detail.originalEvent);
        if (layerStack.isInBranch(target)) return;
        (_options_onFocusOutside = options.onFocusOutside) === null || _options_onFocusOutside === void 0 ? void 0 : _options_onFocusOutside.call(options, event);
        (_options_onInteractOutside = options.onInteractOutside) === null || _options_onInteractOutside === void 0 ? void 0 : _options_onInteractOutside.call(options, event);
        if (event.defaultPrevented) return;
        if (debug) {
            console.log("onFocusOutside:", event.detail.originalEvent);
        }
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
    }
    function onEscapeKeyDown(event) {
        var _options_onEscapeKeyDown;
        if (!layerStack.isTopMost(node)) return;
        (_options_onEscapeKeyDown = options.onEscapeKeyDown) === null || _options_onEscapeKeyDown === void 0 ? void 0 : _options_onEscapeKeyDown.call(options, event);
        if (!event.defaultPrevented && onDismiss) {
            event.preventDefault();
            onDismiss();
        }
    }
    function exclude(target) {
        var _options_persistentElements;
        if (!node) return false;
        const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
        const _containers = Array.isArray(containers) ? containers : [
            containers
        ];
        const persistentElements = (_options_persistentElements = options.persistentElements) === null || _options_persistentElements === void 0 ? void 0 : _options_persistentElements.map((fn)=>fn()).filter(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"]);
        if (persistentElements) _containers.push(...persistentElements);
        return _containers.some((node2)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(node2, target)) || layerStack.isInNestedLayer(node, target);
    }
    const cleanups = [
        pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : void 0,
        trackEscapeKeydown(node, onEscapeKeyDown),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$interact$2d$outside$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trackInteractOutside"])(node, {
            exclude,
            onFocusOutside,
            onPointerDownOutside,
            defer: options.defer
        })
    ];
    return ()=>{
        layerStack.remove(node);
        assignPointerEventToLayers();
        clearPointerEvent(node);
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
function trackDismissableElement(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(nodeOrFn) ? nodeOrFn() : nodeOrFn;
        cleanups.push(trackDismissableElementImpl(node, options));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
function trackDismissableBranch(nodeOrFn) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { defer } = options;
    const func = defer ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"] : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFunction"])(nodeOrFn) ? nodeOrFn() : nodeOrFn;
        if (!node) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["warn"])("[@zag-js/dismissable] branch node is `null` or `undefined`");
            return;
        }
        layerStack.addBranch(node);
        cleanups.push(()=>{
            layerStack.removeBranch(node);
        });
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
;
}),
"[project]/node_modules/@zag-js/rect-utils/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "AffineTransform": ()=>AffineTransform,
    "addPoints": ()=>addPoints,
    "alignRect": ()=>alignRect,
    "clampPoint": ()=>clampPoint,
    "clampSize": ()=>clampSize,
    "closest": ()=>closest,
    "closestSideToPoint": ()=>closestSideToPoint,
    "closestSideToRect": ()=>closestSideToRect,
    "collisions": ()=>collisions,
    "constrainRect": ()=>constrainRect,
    "contains": ()=>contains,
    "containsPoint": ()=>containsPoint,
    "containsRect": ()=>containsRect,
    "createPoint": ()=>createPoint,
    "createRect": ()=>createRect,
    "debugPolygon": ()=>debugPolygon,
    "distance": ()=>distance,
    "distanceBtwEdges": ()=>distanceBtwEdges,
    "distanceFromPoint": ()=>distanceFromPoint,
    "distanceFromRect": ()=>distanceFromRect,
    "expand": ()=>expand,
    "fromRange": ()=>fromRange,
    "getElementPolygon": ()=>getElementPolygon,
    "getElementRect": ()=>getElementRect,
    "getPointAngle": ()=>getPointAngle,
    "getRectCenters": ()=>getRectCenters,
    "getRectCorners": ()=>getRectCorners,
    "getRectEdges": ()=>getRectEdges,
    "getRectFromPoints": ()=>getRectFromPoints,
    "getRotationRect": ()=>getRotationRect,
    "getViewportRect": ()=>getViewportRect,
    "getWindowRect": ()=>getWindowRect,
    "inset": ()=>inset,
    "intersection": ()=>intersection,
    "intersects": ()=>intersects,
    "isPoint": ()=>isPoint,
    "isPointEqual": ()=>isPointEqual,
    "isPointInPolygon": ()=>isPointInPolygon,
    "isRect": ()=>isRect,
    "isRectEqual": ()=>isRectEqual,
    "isSizeEqual": ()=>isSizeEqual,
    "isSymmetric": ()=>isSymmetric,
    "resizeRect": ()=>resizeRect,
    "rotate": ()=>rotate,
    "shift": ()=>shift,
    "shrink": ()=>shrink,
    "subtractPoints": ()=>subtractPoints,
    "toRad": ()=>toRad,
    "union": ()=>union
});
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
// src/affine-transform.ts
var AffineTransform = class _AffineTransform {
    applyTo(point) {
        const { x, y } = point;
        const { m00, m01, m02, m10, m11, m12 } = this;
        return {
            x: m00 * x + m01 * y + m02,
            y: m10 * x + m11 * y + m12
        };
    }
    prepend(other) {
        return new _AffineTransform([
            this.m00 * other.m00 + this.m01 * other.m10,
            // m00
            this.m00 * other.m01 + this.m01 * other.m11,
            // m01
            this.m00 * other.m02 + this.m01 * other.m12 + this.m02,
            // m02
            this.m10 * other.m00 + this.m11 * other.m10,
            // m10
            this.m10 * other.m01 + this.m11 * other.m11,
            // m11
            this.m10 * other.m02 + this.m11 * other.m12 + this.m12
        ]);
    }
    append(other) {
        return new _AffineTransform([
            other.m00 * this.m00 + other.m01 * this.m10,
            // m00
            other.m00 * this.m01 + other.m01 * this.m11,
            // m01
            other.m00 * this.m02 + other.m01 * this.m12 + other.m02,
            // m02
            other.m10 * this.m00 + other.m11 * this.m10,
            // m10
            other.m10 * this.m01 + other.m11 * this.m11,
            // m11
            other.m10 * this.m02 + other.m11 * this.m12 + other.m12
        ]);
    }
    get determinant() {
        return this.m00 * this.m11 - this.m01 * this.m10;
    }
    get isInvertible() {
        const det = this.determinant;
        return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0;
    }
    invert() {
        const det = this.determinant;
        return new _AffineTransform([
            this.m11 / det,
            // m00
            -this.m01 / det,
            // m01
            (this.m01 * this.m12 - this.m11 * this.m02) / det,
            // m02
            -this.m10 / det,
            // m10
            this.m00 / det,
            // m11
            (this.m10 * this.m02 - this.m00 * this.m12) / det
        ]);
    }
    get array() {
        return [
            this.m00,
            this.m01,
            this.m02,
            this.m10,
            this.m11,
            this.m12,
            0,
            0,
            1
        ];
    }
    get float32Array() {
        return new Float32Array(this.array);
    }
    // Static
    static get identity() {
        return new _AffineTransform([
            1,
            0,
            0,
            0,
            1,
            0
        ]);
    }
    static rotate(theta, origin) {
        const rotation = new _AffineTransform([
            Math.cos(theta),
            -Math.sin(theta),
            0,
            Math.sin(theta),
            Math.cos(theta),
            0
        ]);
        if (origin && (origin.x !== 0 || origin.y !== 0)) {
            return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), rotation, _AffineTransform.translate(-origin.x, -origin.y));
        }
        return rotation;
    }
    static scale(sx) {
        let sy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : sx, origin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
            x: 0,
            y: 0
        };
        const scale = new _AffineTransform([
            sx,
            0,
            0,
            0,
            sy,
            0
        ]);
        if (origin.x !== 0 || origin.y !== 0) {
            return _AffineTransform.multiply(_AffineTransform.translate(origin.x, origin.y), scale, _AffineTransform.translate(-origin.x, -origin.y));
        }
        return scale;
    }
    static translate(tx, ty) {
        return new _AffineTransform([
            1,
            0,
            tx,
            0,
            1,
            ty
        ]);
    }
    static multiply() {
        for(var _len = arguments.length, _tmp = new Array(_len), _key = 0; _key < _len; _key++){
            _tmp[_key] = arguments[_key];
        }
        let [first, ...rest] = _tmp;
        if (!first) return _AffineTransform.identity;
        return rest.reduce((result, item)=>result.prepend(item), first);
    }
    get a() {
        return this.m00;
    }
    get b() {
        return this.m10;
    }
    get c() {
        return this.m01;
    }
    get d() {
        return this.m11;
    }
    get tx() {
        return this.m02;
    }
    get ty() {
        return this.m12;
    }
    get scaleComponents() {
        return {
            x: this.a,
            y: this.d
        };
    }
    get translationComponents() {
        return {
            x: this.tx,
            y: this.ty
        };
    }
    get skewComponents() {
        return {
            x: this.c,
            y: this.b
        };
    }
    toString() {
        return "matrix(".concat(this.a, ", ").concat(this.b, ", ").concat(this.c, ", ").concat(this.d, ", ").concat(this.tx, ", ").concat(this.ty, ")");
    }
    constructor([m00, m01, m02, m10, m11, m12] = [
        0,
        0,
        0,
        0,
        0,
        0
    ]){
        var _this = this;
        __publicField(this, "m00");
        __publicField(this, "m01");
        __publicField(this, "m02");
        __publicField(this, "m10");
        __publicField(this, "m11");
        __publicField(this, "m12");
        __publicField(this, "rotate", function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return _this.prepend(_AffineTransform.rotate(...args));
        });
        __publicField(this, "scale", function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return _this.prepend(_AffineTransform.scale(...args));
        });
        __publicField(this, "translate", function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            return _this.prepend(_AffineTransform.translate(...args));
        });
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
    }
};
// src/align.ts
function hAlign(a, ref, h) {
    let x = ref.minX;
    if (h === "left-inside") x = ref.minX;
    if (h === "left-outside") x = ref.minX - ref.width;
    if (h === "right-inside") x = ref.maxX - ref.width;
    if (h === "right-outside") x = ref.maxX;
    if (h === "center") x = ref.midX - ref.width / 2;
    return {
        ...a,
        x
    };
}
function vAlign(a, ref, v) {
    let y = ref.minY;
    if (v === "top-inside") y = ref.minY;
    if (v === "top-outside") y = ref.minY - a.height;
    if (v === "bottom-inside") y = ref.maxY - a.height;
    if (v === "bottom-outside") y = ref.maxY;
    if (v === "center") y = ref.midY - a.height / 2;
    return {
        ...a,
        y
    };
}
function alignRect(a, ref, options) {
    const { h, v } = options;
    return vAlign(hAlign(a, ref, h), ref, v);
}
// src/angle.ts
function getPointAngle(rect, point) {
    let reference = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rect.center;
    const x = point.x - reference.x;
    const y = point.y - reference.y;
    const deg = Math.atan2(x, y) * (180 / Math.PI) + 180;
    return 360 - deg;
}
// src/clamp.ts
var clamp = (value, min3, max2)=>Math.min(Math.max(value, min3), max2);
var clampPoint = (position, size, boundaryRect)=>{
    const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width);
    const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height);
    return {
        x,
        y
    };
};
var defaultMinSize = {
    width: 0,
    height: 0
};
var defaultMaxSize = {
    width: Infinity,
    height: Infinity
};
var clampSize = function(size) {
    let minSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultMinSize, maxSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultMaxSize;
    return {
        width: Math.min(Math.max(size.width, minSize.width), maxSize.width),
        height: Math.min(Math.max(size.height, minSize.height), maxSize.height)
    };
};
// src/rect.ts
var createPoint = (x, y)=>({
        x,
        y
    });
var subtractPoints = (a, b)=>{
    if (!b) return a;
    return createPoint(a.x - b.x, a.y - b.y);
};
var addPoints = (a, b)=>createPoint(a.x + b.x, a.y + b.y);
function isPoint(v) {
    return Reflect.has(v, "x") && Reflect.has(v, "y");
}
function createRect(r) {
    const { x, y, width, height } = r;
    const midX = x + width / 2;
    const midY = y + height / 2;
    return {
        x,
        y,
        width,
        height,
        minX: x,
        minY: y,
        maxX: x + width,
        maxY: y + height,
        midX,
        midY,
        center: createPoint(midX, midY)
    };
}
function isRect(v) {
    return Reflect.has(v, "x") && Reflect.has(v, "y") && Reflect.has(v, "width") && Reflect.has(v, "height");
}
function getRectCenters(v) {
    const top = createPoint(v.midX, v.minY);
    const right = createPoint(v.maxX, v.midY);
    const bottom = createPoint(v.midX, v.maxY);
    const left = createPoint(v.minX, v.midY);
    return {
        top,
        right,
        bottom,
        left
    };
}
function getRectCorners(v) {
    const top = createPoint(v.minX, v.minY);
    const right = createPoint(v.maxX, v.minY);
    const bottom = createPoint(v.maxX, v.maxY);
    const left = createPoint(v.minX, v.maxY);
    return {
        top,
        right,
        bottom,
        left
    };
}
function getRectEdges(v) {
    const c = getRectCorners(v);
    const top = [
        c.top,
        c.right
    ];
    const right = [
        c.right,
        c.bottom
    ];
    const bottom = [
        c.left,
        c.bottom
    ];
    const left = [
        c.top,
        c.left
    ];
    return {
        top,
        right,
        bottom,
        left
    };
}
// src/intersection.ts
function intersects(a, b) {
    return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y;
}
function intersection(a, b) {
    const x = Math.max(a.x, b.x);
    const y = Math.max(a.y, b.y);
    const x2 = Math.min(a.x + a.width, b.x + b.width);
    const y2 = Math.min(a.y + a.height, b.y + b.height);
    return createRect({
        x,
        y,
        width: x2 - x,
        height: y2 - y
    });
}
function collisions(a, b) {
    return {
        top: a.minY <= b.minY,
        right: a.maxX >= b.maxX,
        bottom: a.maxY >= b.maxY,
        left: a.minX <= b.minX
    };
}
// src/distance.ts
function distance(a) {
    let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        x: 0,
        y: 0
    };
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}
function distanceFromPoint(r, p) {
    let x = 0;
    let y = 0;
    if (p.x < r.x) x = r.x - p.x;
    else if (p.x > r.maxX) x = p.x - r.maxX;
    if (p.y < r.y) y = r.y - p.y;
    else if (p.y > r.maxY) y = p.y - r.maxY;
    return {
        x,
        y,
        value: distance({
            x,
            y
        })
    };
}
function distanceFromRect(a, b) {
    if (intersects(a, b)) return {
        x: 0,
        y: 0,
        value: 0
    };
    const left = a.x < b.x ? a : b;
    const right = b.x < a.x ? a : b;
    const upper = a.y < b.y ? a : b;
    const lower = b.y < a.y ? a : b;
    let x = left.x === right.x ? 0 : right.x - left.maxX;
    x = Math.max(0, x);
    let y = upper.y === lower.y ? 0 : lower.y - upper.maxY;
    y = Math.max(0, y);
    return {
        x,
        y,
        value: distance({
            x,
            y
        })
    };
}
function distanceBtwEdges(a, b) {
    return {
        left: b.x - a.x,
        top: b.y - a.y,
        right: a.maxX - b.maxX,
        bottom: a.maxY - b.maxY
    };
}
// src/closest.ts
function closest() {
    for(var _len = arguments.length, pts = new Array(_len), _key = 0; _key < _len; _key++){
        pts[_key] = arguments[_key];
    }
    return (a)=>{
        const ds = pts.map((b)=>distance(b, a));
        const c = Math.min.apply(Math, ds);
        return pts[ds.indexOf(c)];
    };
}
function closestSideToRect(ref, r) {
    if (r.maxX <= ref.minX) return "left";
    if (r.minX >= ref.maxX) return "right";
    if (r.maxY <= ref.minY) return "top";
    if (r.minY >= ref.maxY) return "bottom";
    return "left";
}
function closestSideToPoint(ref, p) {
    const { x, y } = p;
    const dl = x - ref.minX;
    const dr = ref.maxX - x;
    const dt = y - ref.minY;
    const db = ref.maxY - y;
    let closest2 = dl;
    let side = "left";
    if (dr < closest2) {
        closest2 = dr;
        side = "right";
    }
    if (dt < closest2) {
        closest2 = dt;
        side = "top";
    }
    if (db < closest2) {
        side = "bottom";
    }
    return side;
}
// src/constrain.ts
var constrainRect = (rect, boundary)=>{
    const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width));
    const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height));
    return {
        x: left,
        y: top,
        width: Math.min(rect.width, boundary.width),
        height: Math.min(rect.height, boundary.height)
    };
};
// src/contains.ts
function containsPoint(r, p) {
    return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY;
}
function containsRect(a, b) {
    return Object.values(getRectCorners(b)).every((c)=>containsPoint(a, c));
}
function contains(r, v) {
    return isRect(v) ? containsRect(r, v) : containsPoint(r, v);
}
// src/equality.ts
var isSizeEqual = (a, b)=>{
    return a.width === (b === null || b === void 0 ? void 0 : b.width) && a.height === (b === null || b === void 0 ? void 0 : b.height);
};
var isPointEqual = (a, b)=>{
    return a.x === (b === null || b === void 0 ? void 0 : b.x) && a.y === (b === null || b === void 0 ? void 0 : b.y);
};
var isRectEqual = (a, b)=>{
    return isPointEqual(a, b) && isSizeEqual(a, b);
};
// src/from-element.ts
var styleCache = /* @__PURE__ */ new WeakMap();
function getCacheComputedStyle(el) {
    if (!styleCache.has(el)) {
        const win = el.ownerDocument.defaultView || window;
        styleCache.set(el, win.getComputedStyle(el));
    }
    return styleCache.get(el);
}
function getElementRect(el) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return createRect(getClientRect(el, opts));
}
function getClientRect(el) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { excludeScrollbar = false, excludeBorders = false } = opts;
    const { x, y, width, height } = el.getBoundingClientRect();
    const r = {
        x,
        y,
        width,
        height
    };
    const style = getCacheComputedStyle(el);
    const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style;
    const borderXWidth = sum(borderLeftWidth, borderRightWidth);
    const borderYWidth = sum(borderTopWidth, borderBottomWidth);
    if (excludeBorders) {
        r.width -= borderXWidth;
        r.height -= borderYWidth;
        r.x += px(borderLeftWidth);
        r.y += px(borderTopWidth);
    }
    if (excludeScrollbar) {
        const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth;
        const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth;
        r.width -= scrollbarWidth;
        r.height -= scrollbarHeight;
    }
    return r;
}
var px = (v)=>parseFloat(v.replace("px", ""));
var sum = function() {
    for(var _len = arguments.length, vals = new Array(_len), _key = 0; _key < _len; _key++){
        vals[_key] = arguments[_key];
    }
    return vals.reduce((sum2, v)=>sum2 + (v ? px(v) : 0), 0);
};
// src/from-points.ts
function getRectFromPoints() {
    for(var _len = arguments.length, pts = new Array(_len), _key = 0; _key < _len; _key++){
        pts[_key] = arguments[_key];
    }
    const xs = pts.map((p)=>p.x);
    const ys = pts.map((p)=>p.y);
    const x = Math.min(...xs);
    const y = Math.min(...ys);
    const width = Math.max(...xs) - x;
    const height = Math.max(...ys) - y;
    return createRect({
        x,
        y,
        width,
        height
    });
}
// src/union.ts
var { min, max } = Math;
function union() {
    for(var _len = arguments.length, rs = new Array(_len), _key = 0; _key < _len; _key++){
        rs[_key] = arguments[_key];
    }
    const pMin = {
        x: min(...rs.map((r)=>r.minX)),
        y: min(...rs.map((r)=>r.minY))
    };
    const pMax = {
        x: max(...rs.map((r)=>r.maxX)),
        y: max(...rs.map((r)=>r.maxY))
    };
    return getRectFromPoints(pMin, pMax);
}
// src/from-range.ts
function fromRange(range) {
    let rs = [];
    const rects = Array.from(range.getClientRects());
    if (rects.length) {
        rs = rs.concat(rects.map(createRect));
        return union.apply(void 0, rs);
    }
    let start = range.startContainer;
    if (start.nodeType === Node.TEXT_NODE) {
        start = start.parentNode;
    }
    if (start instanceof HTMLElement) {
        const r = getElementRect(start);
        rs.push({
            ...r,
            x: r.maxX,
            width: 0
        });
    }
    return union.apply(void 0, rs);
}
// src/from-rotation.ts
function toRad(d) {
    return d % 360 * Math.PI / 180;
}
function rotate(a, d, c) {
    const r = toRad(d);
    const sin = Math.sin(r);
    const cos = Math.cos(r);
    const x = a.x - c.x;
    const y = a.y - c.y;
    return {
        x: c.x + x * cos - y * sin,
        y: c.y + x * sin + y * cos
    };
}
function getRotationRect(r, deg) {
    const rr = Object.values(getRectCorners(r)).map((p)=>rotate(p, deg, r.center));
    const xs = rr.map((p)=>p.x);
    const ys = rr.map((p)=>p.y);
    const minX = Math.min(...xs);
    const minY = Math.min(...ys);
    const maxX = Math.max(...xs);
    const maxY = Math.max(...ys);
    return createRect({
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    });
}
// src/from-window.ts
function getWindowRect(win) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return createRect(getViewportRect(win, opts));
}
function getViewportRect(win, opts) {
    const { excludeScrollbar = false } = opts;
    const { innerWidth, innerHeight, document: doc, visualViewport } = win;
    const width = (visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) || innerWidth;
    const height = (visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) || innerHeight;
    const rect = {
        x: 0,
        y: 0,
        width,
        height
    };
    if (excludeScrollbar) {
        const scrollbarWidth = innerWidth - doc.documentElement.clientWidth;
        const scrollbarHeight = innerHeight - doc.documentElement.clientHeight;
        rect.width -= scrollbarWidth;
        rect.height -= scrollbarHeight;
    }
    return rect;
}
// src/operations.ts
var isSymmetric = (v)=>"dx" in v || "dy" in v;
function inset(r, i) {
    const v = isSymmetric(i) ? {
        left: i.dx,
        right: i.dx,
        top: i.dy,
        bottom: i.dy
    } : i;
    const { top = 0, right = 0, bottom = 0, left = 0 } = v;
    return createRect({
        x: r.x + left,
        y: r.y + top,
        width: r.width - left - right,
        height: r.height - top - bottom
    });
}
function expand(r, v) {
    const value = typeof v === "number" ? {
        dx: -v,
        dy: -v
    } : v;
    return inset(r, value);
}
function shrink(r, v) {
    const value = typeof v === "number" ? {
        dx: -v,
        dy: -v
    } : v;
    return inset(r, value);
}
function shift(r, o) {
    const { x = 0, y = 0 } = o;
    return createRect({
        x: r.x + x,
        y: r.y + y,
        width: r.width,
        height: r.height
    });
}
// src/polygon.ts
function getElementPolygon(rectValue, placement) {
    const rect = createRect(rectValue);
    const { top, right, left, bottom } = getRectCorners(rect);
    const [base] = placement.split("-");
    return ({
        top: [
            left,
            top,
            right,
            bottom
        ],
        right: [
            top,
            right,
            bottom,
            left
        ],
        bottom: [
            top,
            left,
            bottom,
            right
        ],
        left: [
            right,
            top,
            left,
            bottom
        ]
    })[base];
}
function isPointInPolygon(polygon, point) {
    const { x, y } = point;
    let c = false;
    for(let i = 0, j = polygon.length - 1; i < polygon.length; j = i++){
        const xi = polygon[i].x;
        const yi = polygon[i].y;
        const xj = polygon[j].x;
        const yj = polygon[j].y;
        if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
            c = !c;
        }
    }
    return c;
}
function createPolygonElement() {
    const id = "debug-polygon";
    const existingPolygon = document.getElementById(id);
    if (existingPolygon) {
        return existingPolygon;
    }
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    Object.assign(svg.style, {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        opacity: "0.15",
        position: "fixed",
        pointerEvents: "none",
        fill: "red"
    });
    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    polygon.setAttribute("id", id);
    polygon.setAttribute("points", "0,0 0,0");
    svg.appendChild(polygon);
    document.body.appendChild(svg);
    return polygon;
}
function debugPolygon(polygon) {
    const el = createPolygonElement();
    const points = polygon.map((point)=>"".concat(point.x, ",").concat(point.y)).join(" ");
    el.setAttribute("points", points);
    return ()=>{
        el.remove();
    };
}
// src/compass.ts
var compassDirectionMap = {
    n: {
        x: 0.5,
        y: 0
    },
    ne: {
        x: 1,
        y: 0
    },
    e: {
        x: 1,
        y: 0.5
    },
    se: {
        x: 1,
        y: 1
    },
    s: {
        x: 0.5,
        y: 1
    },
    sw: {
        x: 0,
        y: 1
    },
    w: {
        x: 0,
        y: 0.5
    },
    nw: {
        x: 0,
        y: 0
    }
};
var oppositeDirectionMap = {
    n: "s",
    ne: "sw",
    e: "w",
    se: "nw",
    s: "n",
    sw: "ne",
    w: "e",
    nw: "se"
};
// src/resize.ts
var { sign, abs, min: min2 } = Math;
function getRectExtentPoint(rect, direction) {
    const { minX, minY, maxX, maxY, midX, midY } = rect;
    const x = direction.includes("w") ? minX : direction.includes("e") ? maxX : midX;
    const y = direction.includes("n") ? minY : direction.includes("s") ? maxY : midY;
    return {
        x,
        y
    };
}
function getOppositeDirection(direction) {
    return oppositeDirectionMap[direction];
}
function resizeRect(rect, offset, direction, opts) {
    const { scalingOriginMode, lockAspectRatio } = opts;
    const extent = getRectExtentPoint(rect, direction);
    const oppositeDirection = getOppositeDirection(direction);
    const oppositeExtent = getRectExtentPoint(rect, oppositeDirection);
    if (scalingOriginMode === "center") {
        offset = {
            x: offset.x * 2,
            y: offset.y * 2
        };
    }
    const newExtent = {
        x: extent.x + offset.x,
        y: extent.y + offset.y
    };
    const multiplier = {
        x: compassDirectionMap[direction].x * 2 - 1,
        y: compassDirectionMap[direction].y * 2 - 1
    };
    const newSize = {
        width: newExtent.x - oppositeExtent.x,
        height: newExtent.y - oppositeExtent.y
    };
    const scaleX = multiplier.x * newSize.width / rect.width;
    const scaleY = multiplier.y * newSize.height / rect.height;
    const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY;
    const scale = lockAspectRatio ? {
        x: largestMagnitude,
        y: largestMagnitude
    } : {
        x: extent.x === oppositeExtent.x ? 1 : scaleX,
        y: extent.y === oppositeExtent.y ? 1 : scaleY
    };
    if (extent.y === oppositeExtent.y) {
        scale.y = abs(scale.y);
    } else if (sign(scale.y) !== sign(scaleY)) {
        scale.y *= -1;
    }
    if (extent.x === oppositeExtent.x) {
        scale.x = abs(scale.x);
    } else if (sign(scale.x) !== sign(scaleX)) {
        scale.x *= -1;
    }
    switch(scalingOriginMode){
        case "extent":
            return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false);
        case "center":
            return transformRect(rect, AffineTransform.scale(scale.x, scale.y, {
                x: rect.midX,
                y: rect.midY
            }), false);
    }
}
function createRectFromPoints(initialPoint, finalPoint) {
    let normalized = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (normalized) {
        return {
            x: min2(finalPoint.x, initialPoint.x),
            y: min2(finalPoint.y, initialPoint.y),
            width: abs(finalPoint.x - initialPoint.x),
            height: abs(finalPoint.y - initialPoint.y)
        };
    }
    return {
        x: initialPoint.x,
        y: initialPoint.y,
        width: finalPoint.x - initialPoint.x,
        height: finalPoint.y - initialPoint.y
    };
}
function transformRect(rect, transform) {
    let normalized = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const p1 = transform.applyTo({
        x: rect.minX,
        y: rect.minY
    });
    const p2 = transform.applyTo({
        x: rect.maxX,
        y: rect.maxY
    });
    return createRectFromPoints(p1, p2, normalized);
}
;
}),
"[project]/node_modules/@zag-js/menu/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "anatomy": ()=>anatomy,
    "connect": ()=>connect,
    "itemGroupLabelProps": ()=>itemGroupLabelProps,
    "itemGroupProps": ()=>itemGroupProps,
    "itemProps": ()=>itemProps,
    "machine": ()=>machine,
    "optionItemProps": ()=>optionItemProps,
    "props": ()=>props,
    "splitItemGroupLabelProps": ()=>splitItemGroupLabelProps,
    "splitItemGroupProps": ()=>splitItemGroupProps,
    "splitItemProps": ()=>splitItemProps,
    "splitOptionItemProps": ()=>splitOptionItemProps,
    "splitProps": ()=>splitProps
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/core/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/popper/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rect$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/rect-utils/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/types/dist/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
// src/menu.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createAnatomy"])("menu").parts("arrow", "arrowTip", "content", "contextTrigger", "indicator", "item", "itemGroup", "itemGroupLabel", "itemIndicator", "itemText", "positioner", "separator", "trigger", "triggerItem");
var parts = anatomy.build();
var getTriggerId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_trigger;
    return (_ctx_ids_trigger = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.trigger) !== null && _ctx_ids_trigger !== void 0 ? _ctx_ids_trigger : "menu:".concat(ctx.id, ":trigger");
};
var getContextTriggerId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_contextTrigger;
    return (_ctx_ids_contextTrigger = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.contextTrigger) !== null && _ctx_ids_contextTrigger !== void 0 ? _ctx_ids_contextTrigger : "menu:".concat(ctx.id, ":ctx-trigger");
};
var getContentId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_content;
    return (_ctx_ids_content = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.content) !== null && _ctx_ids_content !== void 0 ? _ctx_ids_content : "menu:".concat(ctx.id, ":content");
};
var getArrowId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_arrow;
    return (_ctx_ids_arrow = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.arrow) !== null && _ctx_ids_arrow !== void 0 ? _ctx_ids_arrow : "menu:".concat(ctx.id, ":arrow");
};
var getPositionerId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_positioner;
    return (_ctx_ids_positioner = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.positioner) !== null && _ctx_ids_positioner !== void 0 ? _ctx_ids_positioner : "menu:".concat(ctx.id, ":popper");
};
var getGroupId = (ctx, id)=>{
    var _ctx_ids_group, _ctx_ids;
    var _ctx_ids_group1;
    return (_ctx_ids_group1 = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : (_ctx_ids_group = _ctx_ids.group) === null || _ctx_ids_group === void 0 ? void 0 : _ctx_ids_group.call(_ctx_ids, id)) !== null && _ctx_ids_group1 !== void 0 ? _ctx_ids_group1 : "menu:".concat(ctx.id, ":group:").concat(id);
};
var getItemId = (ctx, id)=>"".concat(ctx.id, "/").concat(id);
var getItemValue = (el)=>{
    var _el_dataset_value;
    return (_el_dataset_value = el === null || el === void 0 ? void 0 : el.dataset.value) !== null && _el_dataset_value !== void 0 ? _el_dataset_value : null;
};
var getGroupLabelId = (ctx, id)=>{
    var _ctx_ids_groupLabel, _ctx_ids;
    var _ctx_ids_groupLabel1;
    return (_ctx_ids_groupLabel1 = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : (_ctx_ids_groupLabel = _ctx_ids.groupLabel) === null || _ctx_ids_groupLabel === void 0 ? void 0 : _ctx_ids_groupLabel.call(_ctx_ids, id)) !== null && _ctx_ids_groupLabel1 !== void 0 ? _ctx_ids_groupLabel1 : "menu:".concat(ctx.id, ":group-label:").concat(id);
};
var getContentEl = (ctx)=>ctx.getById(getContentId(ctx));
var getPositionerEl = (ctx)=>ctx.getById(getPositionerId(ctx));
var getTriggerEl = (ctx)=>ctx.getById(getTriggerId(ctx));
var getItemEl = (ctx, value)=>value ? ctx.getById(getItemId(ctx, value)) : null;
var getContextTriggerEl = (ctx)=>ctx.getById(getContextTriggerId(ctx));
var getElements = (ctx)=>{
    const ownerId = CSS.escape(getContentId(ctx));
    const selector = '[role^="menuitem"][data-ownedby='.concat(ownerId, "]:not([data-disabled])");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["queryAll"])(getContentEl(ctx), selector);
};
var getFirstEl = (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["first"])(getElements(ctx));
var getLastEl = (ctx)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["last"])(getElements(ctx));
var isMatch = (el, value)=>{
    if (!value) return false;
    return el.id === value || el.dataset.value === value;
};
var getNextEl = (ctx, opts)=>{
    const items = getElements(ctx);
    const index = items.findIndex((el)=>isMatch(el, opts.value));
    var _opts_loop;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["next"])(items, index, {
        loop: (_opts_loop = opts.loop) !== null && _opts_loop !== void 0 ? _opts_loop : opts.loopFocus
    });
};
var getPrevEl = (ctx, opts)=>{
    const items = getElements(ctx);
    const index = items.findIndex((el)=>isMatch(el, opts.value));
    var _opts_loop;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prev"])(items, index, {
        loop: (_opts_loop = opts.loop) !== null && _opts_loop !== void 0 ? _opts_loop : opts.loopFocus
    });
};
var getElemByKey = (ctx, opts)=>{
    const items = getElements(ctx);
    const item = items.find((el)=>isMatch(el, opts.value));
    var _item_id;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getByTypeahead"])(items, {
        state: opts.typeaheadState,
        key: opts.key,
        activeId: (_item_id = item === null || item === void 0 ? void 0 : item.id) !== null && _item_id !== void 0 ? _item_id : null
    });
};
var isTargetDisabled = (v)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHTMLElement"])(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
};
var isTriggerItem = (el)=>{
    var _el_getAttribute;
    return !!(el === null || el === void 0 ? void 0 : (_el_getAttribute = el.getAttribute("role")) === null || _el_getAttribute === void 0 ? void 0 : _el_getAttribute.startsWith("menuitem")) && !!(el === null || el === void 0 ? void 0 : el.hasAttribute("aria-controls"));
};
var itemSelectEvent = "menu:select";
function dispatchSelectionEvent(el, value) {
    if (!el) return;
    const win = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindow"])(el);
    const event = new win.CustomEvent(itemSelectEvent, {
        detail: {
            value
        }
    });
    el.dispatchEvent(event);
}
// src/menu.connect.ts
function connect(service, normalize) {
    const { context, send, state, computed, prop, scope } = service;
    const open = state.hasTag("open");
    const isSubmenu = computed("isSubmenu");
    const isTypingAhead = computed("isTypingAhead");
    const composite = prop("composite");
    const currentPlacement = context.get("currentPlacement");
    const anchorPoint = context.get("anchorPoint");
    const highlightedValue = context.get("highlightedValue");
    const popperStyles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPlacementStyles"])({
        ...prop("positioning"),
        placement: anchorPoint ? "bottom" : currentPlacement
    });
    function getItemState(props2) {
        return {
            id: getItemId(scope, props2.value),
            disabled: !!props2.disabled,
            highlighted: highlightedValue === props2.value
        };
    }
    function getOptionItemProps(props2) {
        var _props2_valueText;
        const valueText = (_props2_valueText = props2.valueText) !== null && _props2_valueText !== void 0 ? _props2_valueText : props2.value;
        return {
            ...props2,
            id: props2.value,
            valueText
        };
    }
    function getOptionItemState(props2) {
        const itemState = getItemState(getOptionItemProps(props2));
        return {
            ...itemState,
            checked: !!props2.checked
        };
    }
    function getItemProps(props2) {
        const { closeOnSelect, valueText, value } = props2;
        const itemState = getItemState(props2);
        const id = getItemId(scope, value);
        return normalize.element({
            ...parts.item.attrs,
            id,
            role: "menuitem",
            "aria-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ariaAttr"])(itemState.disabled),
            "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
            "data-ownedby": getContentId(scope),
            "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
            "data-value": value,
            "data-valuetext": valueText,
            onDragStart (event) {
                const isLink = event.currentTarget.matches("a[href]");
                if (isLink) event.preventDefault();
            },
            onPointerMove (event) {
                if (itemState.disabled) return;
                if (event.pointerType !== "mouse") return;
                const target = event.currentTarget;
                if (itemState.highlighted) return;
                send({
                    type: "ITEM_POINTERMOVE",
                    id,
                    target,
                    closeOnSelect
                });
            },
            onPointerLeave (event) {
                var _service_event_previous;
                if (itemState.disabled) return;
                if (event.pointerType !== "mouse") return;
                const pointerMoved = (_service_event_previous = service.event.previous()) === null || _service_event_previous === void 0 ? void 0 : _service_event_previous.type.includes("POINTER");
                if (!pointerMoved) return;
                const target = event.currentTarget;
                send({
                    type: "ITEM_POINTERLEAVE",
                    id,
                    target,
                    closeOnSelect
                });
            },
            onPointerDown (event) {
                if (itemState.disabled) return;
                const target = event.currentTarget;
                send({
                    type: "ITEM_POINTERDOWN",
                    target,
                    id,
                    closeOnSelect
                });
            },
            onClick (event) {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDownloadingEvent"])(event)) return;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOpeningInNewTab"])(event)) return;
                if (itemState.disabled) return;
                const target = event.currentTarget;
                send({
                    type: "ITEM_CLICK",
                    target,
                    id,
                    closeOnSelect
                });
            }
        });
    }
    return {
        highlightedValue,
        open,
        setOpen (nextOpen) {
            const open2 = state.hasTag("open");
            if (open2 === nextOpen) return;
            send({
                type: nextOpen ? "OPEN" : "CLOSE"
            });
        },
        setHighlightedValue (value) {
            send({
                type: "HIGHLIGHTED.SET",
                value
            });
        },
        setParent (parent) {
            send({
                type: "PARENT.SET",
                value: parent,
                id: parent.prop("id")
            });
        },
        setChild (child) {
            send({
                type: "CHILD.SET",
                value: child,
                id: child.prop("id")
            });
        },
        reposition () {
            let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            send({
                type: "POSITIONING.SET",
                options
            });
        },
        addItemListener (props2) {
            const node = scope.getById(props2.id);
            if (!node) return;
            const listener = ()=>{
                var _props2_onSelect;
                return (_props2_onSelect = props2.onSelect) === null || _props2_onSelect === void 0 ? void 0 : _props2_onSelect.call(props2);
            };
            node.addEventListener(itemSelectEvent, listener);
            return ()=>node.removeEventListener(itemSelectEvent, listener);
        },
        getContextTriggerProps () {
            return normalize.element({
                ...parts.contextTrigger.attrs,
                dir: prop("dir"),
                id: getContextTriggerId(scope),
                onPointerDown (event) {
                    if (event.pointerType === "mouse") return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "CONTEXT_MENU_START",
                        point
                    });
                },
                onPointerCancel (event) {
                    if (event.pointerType === "mouse") return;
                    send({
                        type: "CONTEXT_MENU_CANCEL"
                    });
                },
                onPointerMove (event) {
                    if (event.pointerType === "mouse") return;
                    send({
                        type: "CONTEXT_MENU_CANCEL"
                    });
                },
                onPointerUp (event) {
                    if (event.pointerType === "mouse") return;
                    send({
                        type: "CONTEXT_MENU_CANCEL"
                    });
                },
                onContextMenu (event) {
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "CONTEXT_MENU",
                        point
                    });
                    event.preventDefault();
                },
                style: {
                    WebkitTouchCallout: "none",
                    WebkitUserSelect: "none",
                    userSelect: "none"
                }
            });
        },
        getTriggerItemProps (childApi) {
            const triggerProps = childApi.getTriggerProps();
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeProps"])(getItemProps({
                value: triggerProps.id
            }), triggerProps);
        },
        getTriggerProps () {
            return normalize.button({
                ...isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs,
                "data-placement": context.get("currentPlacement"),
                type: "button",
                dir: prop("dir"),
                id: getTriggerId(scope),
                "data-uid": prop("id"),
                "aria-haspopup": composite ? "menu" : "dialog",
                "aria-controls": getContentId(scope),
                "aria-expanded": open || void 0,
                "data-state": open ? "open" : "closed",
                onPointerMove (event) {
                    if (event.pointerType !== "mouse") return;
                    const disabled = isTargetDisabled(event.currentTarget);
                    if (disabled || !isSubmenu) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "TRIGGER_POINTERMOVE",
                        target: event.currentTarget,
                        point
                    });
                },
                onPointerLeave (event) {
                    if (isTargetDisabled(event.currentTarget)) return;
                    if (event.pointerType !== "mouse") return;
                    if (!isSubmenu) return;
                    const point = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventPoint"])(event);
                    send({
                        type: "TRIGGER_POINTERLEAVE",
                        target: event.currentTarget,
                        point
                    });
                },
                onPointerDown (event) {
                    if (isTargetDisabled(event.currentTarget)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isContextMenuEvent"])(event)) return;
                    event.preventDefault();
                },
                onClick (event) {
                    if (event.defaultPrevented) return;
                    if (isTargetDisabled(event.currentTarget)) return;
                    send({
                        type: "TRIGGER_CLICK",
                        target: event.currentTarget
                    });
                },
                onBlur () {
                    send({
                        type: "TRIGGER_BLUR"
                    });
                },
                onFocus () {
                    send({
                        type: "TRIGGER_FOCUS"
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    const keyMap = {
                        ArrowDown () {
                            send({
                                type: "ARROW_DOWN"
                            });
                        },
                        ArrowUp () {
                            send({
                                type: "ARROW_UP"
                            });
                        },
                        Enter () {
                            send({
                                type: "ARROW_DOWN",
                                src: "enter"
                            });
                        },
                        Space () {
                            send({
                                type: "ARROW_DOWN",
                                src: "space"
                            });
                        }
                    };
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventKey"])(event, {
                        orientation: "vertical",
                        dir: prop("dir")
                    });
                    const exec = keyMap[key];
                    if (exec) {
                        event.preventDefault();
                        exec(event);
                    }
                }
            });
        },
        getIndicatorProps () {
            return normalize.element({
                ...parts.indicator.attrs,
                dir: prop("dir"),
                "data-state": open ? "open" : "closed"
            });
        },
        getPositionerProps () {
            return normalize.element({
                ...parts.positioner.attrs,
                dir: prop("dir"),
                id: getPositionerId(scope),
                style: popperStyles.floating
            });
        },
        getArrowProps () {
            return normalize.element({
                id: getArrowId(scope),
                ...parts.arrow.attrs,
                dir: prop("dir"),
                style: popperStyles.arrow
            });
        },
        getArrowTipProps () {
            return normalize.element({
                ...parts.arrowTip.attrs,
                dir: prop("dir"),
                style: popperStyles.arrowTip
            });
        },
        getContentProps () {
            return normalize.element({
                ...parts.content.attrs,
                id: getContentId(scope),
                "aria-label": prop("aria-label"),
                hidden: !open,
                "data-state": open ? "open" : "closed",
                role: composite ? "menu" : "dialog",
                tabIndex: 0,
                dir: prop("dir"),
                "aria-activedescendant": computed("highlightedId") || void 0,
                "aria-labelledby": getTriggerId(scope),
                "data-placement": currentPlacement,
                onPointerEnter (event) {
                    if (event.pointerType !== "mouse") return;
                    send({
                        type: "MENU_POINTERENTER"
                    });
                },
                onKeyDown (event) {
                    if (event.defaultPrevented) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSelfTarget"])(event)) return;
                    const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
                    const sameMenu = (target === null || target === void 0 ? void 0 : target.closest("[role=menu]")) === event.currentTarget || target === event.currentTarget;
                    if (!sameMenu) return;
                    if (event.key === "Tab") {
                        const valid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidTabEvent"])(event);
                        if (!valid) {
                            event.preventDefault();
                            return;
                        }
                    }
                    const item = getItemEl(scope, highlightedValue);
                    const keyMap = {
                        ArrowDown () {
                            send({
                                type: "ARROW_DOWN"
                            });
                        },
                        ArrowUp () {
                            send({
                                type: "ARROW_UP"
                            });
                        },
                        ArrowLeft () {
                            send({
                                type: "ARROW_LEFT"
                            });
                        },
                        ArrowRight () {
                            send({
                                type: "ARROW_RIGHT"
                            });
                        },
                        Enter () {
                            send({
                                type: "ENTER"
                            });
                            if (highlightedValue == null) return;
                            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAnchorElement"])(item)) {
                                var _prop;
                                (_prop = prop("navigate")) === null || _prop === void 0 ? void 0 : _prop({
                                    value: highlightedValue,
                                    node: item,
                                    href: item.href
                                });
                            }
                        },
                        Space (event2) {
                            if (isTypingAhead) {
                                send({
                                    type: "TYPEAHEAD",
                                    key: event2.key
                                });
                            } else {
                                var _keyMap_Enter;
                                (_keyMap_Enter = keyMap.Enter) === null || _keyMap_Enter === void 0 ? void 0 : _keyMap_Enter.call(keyMap, event2);
                            }
                        },
                        Home () {
                            send({
                                type: "HOME"
                            });
                        },
                        End () {
                            send({
                                type: "END"
                            });
                        }
                    };
                    const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventKey"])(event, {
                        dir: prop("dir")
                    });
                    const exec = keyMap[key];
                    if (exec) {
                        exec(event);
                        event.stopPropagation();
                        event.preventDefault();
                        return;
                    }
                    if (!prop("typeahead")) return;
                    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPrintableKey"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isModifierKey"])(event)) return;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEditableElement"])(target)) return;
                    send({
                        type: "TYPEAHEAD",
                        key: event.key
                    });
                    event.preventDefault();
                }
            });
        },
        getSeparatorProps () {
            return normalize.element({
                ...parts.separator.attrs,
                role: "separator",
                dir: prop("dir"),
                "aria-orientation": "horizontal"
            });
        },
        getItemState,
        getItemProps,
        getOptionItemState,
        getOptionItemProps (props2) {
            const { type, disabled, onCheckedChange, closeOnSelect } = props2;
            const option = getOptionItemProps(props2);
            const itemState = getOptionItemState(props2);
            return {
                ...getItemProps(option),
                ...normalize.element({
                    "data-type": type,
                    ...parts.item.attrs,
                    dir: prop("dir"),
                    "data-value": option.value,
                    role: "menuitem".concat(type),
                    "aria-checked": !!itemState.checked,
                    "data-state": itemState.checked ? "checked" : "unchecked",
                    onClick (event) {
                        if (disabled) return;
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDownloadingEvent"])(event)) return;
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOpeningInNewTab"])(event)) return;
                        const target = event.currentTarget;
                        send({
                            type: "ITEM_CLICK",
                            target,
                            option,
                            closeOnSelect
                        });
                        onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(!itemState.checked);
                    }
                })
            };
        },
        getItemIndicatorProps (props2) {
            const itemState = getOptionItemState((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cast"])(props2));
            const dataState = itemState.checked ? "checked" : "unchecked";
            return normalize.element({
                ...parts.itemIndicator.attrs,
                dir: prop("dir"),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
                "data-state": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasProp"])(props2, "checked") ? dataState : void 0,
                hidden: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasProp"])(props2, "checked") ? !itemState.checked : void 0
            });
        },
        getItemTextProps (props2) {
            const itemState = getOptionItemState((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cast"])(props2));
            const dataState = itemState.checked ? "checked" : "unchecked";
            return normalize.element({
                ...parts.itemText.attrs,
                dir: prop("dir"),
                "data-disabled": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.disabled),
                "data-highlighted": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataAttr"])(itemState.highlighted),
                "data-state": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hasProp"])(props2, "checked") ? dataState : void 0
            });
        },
        getItemGroupLabelProps (props2) {
            return normalize.element({
                ...parts.itemGroupLabel.attrs,
                id: getGroupLabelId(scope, props2.htmlFor),
                dir: prop("dir")
            });
        },
        getItemGroupProps (props2) {
            return normalize.element({
                id: getGroupId(scope, props2.id),
                ...parts.itemGroup.attrs,
                dir: prop("dir"),
                "aria-labelledby": getGroupLabelId(scope, props2.id),
                role: "group"
            });
        }
    };
}
var { not, and, or } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createGuards"])();
var machine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMachine"])({
    props (param) {
        let { props: props2 } = param;
        return {
            closeOnSelect: true,
            typeahead: true,
            composite: true,
            loopFocus: false,
            navigate (details) {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clickIfLink"])(details.node);
            },
            ...props2,
            positioning: {
                placement: "bottom-start",
                gutter: 8,
                ...props2.positioning
            }
        };
    },
    initialState (param) {
        let { prop } = param;
        const open = prop("open") || prop("defaultOpen");
        return open ? "open" : "idle";
    },
    context (param) {
        let { bindable, prop } = param;
        return {
            suspendPointer: bindable(()=>({
                    defaultValue: false
                })),
            highlightedValue: bindable(()=>({
                    defaultValue: prop("defaultHighlightedValue") || null,
                    value: prop("highlightedValue"),
                    onChange (value) {
                        var _prop;
                        (_prop = prop("onHighlightChange")) === null || _prop === void 0 ? void 0 : _prop({
                            highlightedValue: value
                        });
                    }
                })),
            lastHighlightedValue: bindable(()=>({
                    defaultValue: null
                })),
            currentPlacement: bindable(()=>({
                    defaultValue: void 0
                })),
            intentPolygon: bindable(()=>({
                    defaultValue: null
                })),
            anchorPoint: bindable(()=>({
                    defaultValue: null,
                    hash (value) {
                        return "x: ".concat(value === null || value === void 0 ? void 0 : value.x, ", y: ").concat(value === null || value === void 0 ? void 0 : value.y);
                    }
                }))
        };
    },
    refs () {
        return {
            parent: null,
            children: {},
            typeaheadState: {
                ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getByTypeahead"].defaultOptions
            },
            positioningOverride: {}
        };
    },
    computed: {
        isSubmenu: (param)=>{
            let { refs } = param;
            return refs.get("parent") != null;
        },
        isRtl: (param)=>{
            let { prop } = param;
            return prop("dir") === "rtl";
        },
        isTypingAhead: (param)=>{
            let { refs } = param;
            return refs.get("typeaheadState").keysSoFar !== "";
        },
        highlightedId: (param)=>{
            let { context, scope, refs } = param;
            return resolveItemId(refs.get("children"), context.get("highlightedValue"), scope);
        }
    },
    watch (param) {
        let { track, action, context, computed, prop } = param;
        track([
            ()=>computed("isSubmenu")
        ], ()=>{
            action([
                "setSubmenuPlacement"
            ]);
        });
        track([
            ()=>context.hash("anchorPoint")
        ], ()=>{
            action([
                "reposition"
            ]);
        });
        track([
            ()=>prop("open")
        ], ()=>{
            action([
                "toggleVisibility"
            ]);
        });
    },
    on: {
        "PARENT.SET": {
            actions: [
                "setParentMenu"
            ]
        },
        "CHILD.SET": {
            actions: [
                "setChildMenu"
            ]
        },
        OPEN: [
            {
                guard: "isOpenControlled",
                actions: [
                    "invokeOnOpen"
                ]
            },
            {
                target: "open",
                actions: [
                    "invokeOnOpen"
                ]
            }
        ],
        OPEN_AUTOFOCUS: [
            {
                guard: "isOpenControlled",
                actions: [
                    "invokeOnOpen"
                ]
            },
            {
                // internal: true,
                target: "open",
                actions: [
                    "highlightFirstItem",
                    "invokeOnOpen"
                ]
            }
        ],
        CLOSE: [
            {
                guard: "isOpenControlled",
                actions: [
                    "invokeOnClose"
                ]
            },
            {
                target: "closed",
                actions: [
                    "invokeOnClose"
                ]
            }
        ],
        "HIGHLIGHTED.RESTORE": {
            actions: [
                "restoreHighlightedItem"
            ]
        },
        "HIGHLIGHTED.SET": {
            actions: [
                "setHighlightedItem"
            ]
        }
    },
    states: {
        idle: {
            tags: [
                "closed"
            ],
            on: {
                "CONTROLLED.OPEN": {
                    target: "open"
                },
                "CONTROLLED.CLOSE": {
                    target: "closed"
                },
                CONTEXT_MENU_START: {
                    target: "opening:contextmenu",
                    actions: [
                        "setAnchorPoint"
                    ]
                },
                CONTEXT_MENU: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "setAnchorPoint",
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "setAnchorPoint",
                            "invokeOnOpen"
                        ]
                    }
                ],
                TRIGGER_CLICK: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "invokeOnOpen"
                        ]
                    }
                ],
                TRIGGER_FOCUS: {
                    guard: not("isSubmenu"),
                    target: "closed"
                },
                TRIGGER_POINTERMOVE: {
                    guard: "isSubmenu",
                    target: "opening"
                }
            }
        },
        "opening:contextmenu": {
            tags: [
                "closed"
            ],
            effects: [
                "waitForLongPress"
            ],
            on: {
                "CONTROLLED.OPEN": {
                    target: "open"
                },
                "CONTROLLED.CLOSE": {
                    target: "closed"
                },
                CONTEXT_MENU_CANCEL: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    }
                ],
                "LONG_PRESS.OPEN": [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "invokeOnOpen"
                        ]
                    }
                ]
            }
        },
        opening: {
            tags: [
                "closed"
            ],
            effects: [
                "waitForOpenDelay"
            ],
            on: {
                "CONTROLLED.OPEN": {
                    target: "open"
                },
                "CONTROLLED.CLOSE": {
                    target: "closed"
                },
                BLUR: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    }
                ],
                TRIGGER_POINTERLEAVE: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    }
                ],
                "DELAY.OPEN": [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "invokeOnOpen"
                        ]
                    }
                ]
            }
        },
        closing: {
            tags: [
                "open"
            ],
            effects: [
                "trackPointerMove",
                "trackInteractOutside",
                "waitForCloseDelay"
            ],
            on: {
                "CONTROLLED.OPEN": {
                    target: "open"
                },
                "CONTROLLED.CLOSE": {
                    target: "closed",
                    actions: [
                        "focusParentMenu",
                        "restoreParentHighlightedItem"
                    ]
                },
                // don't invoke on open here since the menu is still open (we're only keeping it open)
                MENU_POINTERENTER: {
                    target: "open",
                    actions: [
                        "clearIntentPolygon"
                    ]
                },
                POINTER_MOVED_AWAY_FROM_SUBMENU: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        target: "closed",
                        actions: [
                            "focusParentMenu",
                            "restoreParentHighlightedItem"
                        ]
                    }
                ],
                "DELAY.CLOSE": [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        target: "closed",
                        actions: [
                            "focusParentMenu",
                            "restoreParentHighlightedItem",
                            "invokeOnClose"
                        ]
                    }
                ]
            }
        },
        closed: {
            tags: [
                "closed"
            ],
            entry: [
                "clearHighlightedItem",
                "focusTrigger",
                "resumePointer"
            ],
            on: {
                "CONTROLLED.OPEN": [
                    {
                        guard: or("isOpenAutoFocusEvent", "isArrowDownEvent"),
                        target: "open",
                        actions: [
                            "highlightFirstItem"
                        ]
                    },
                    {
                        guard: "isArrowUpEvent",
                        target: "open",
                        actions: [
                            "highlightLastItem"
                        ]
                    },
                    {
                        target: "open"
                    }
                ],
                CONTEXT_MENU_START: {
                    target: "opening:contextmenu",
                    actions: [
                        "setAnchorPoint"
                    ]
                },
                CONTEXT_MENU: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "setAnchorPoint",
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "setAnchorPoint",
                            "invokeOnOpen"
                        ]
                    }
                ],
                TRIGGER_CLICK: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "invokeOnOpen"
                        ]
                    }
                ],
                TRIGGER_POINTERMOVE: {
                    guard: "isTriggerItem",
                    target: "opening"
                },
                TRIGGER_BLUR: {
                    target: "idle"
                },
                ARROW_DOWN: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "highlightFirstItem",
                            "invokeOnOpen"
                        ]
                    }
                ],
                ARROW_UP: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "highlightLastItem",
                            "invokeOnOpen"
                        ]
                    }
                ]
            }
        },
        open: {
            tags: [
                "open"
            ],
            effects: [
                "trackInteractOutside",
                "trackPositioning",
                "scrollToHighlightedItem"
            ],
            entry: [
                "focusMenu",
                "resumePointer"
            ],
            on: {
                "CONTROLLED.CLOSE": [
                    {
                        target: "closed",
                        guard: "isArrowLeftEvent",
                        actions: [
                            "focusParentMenu"
                        ]
                    },
                    {
                        target: "closed"
                    }
                ],
                TRIGGER_CLICK: [
                    {
                        guard: and(not("isTriggerItem"), "isOpenControlled"),
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        guard: not("isTriggerItem"),
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    }
                ],
                CONTEXT_MENU: {
                    actions: [
                        "setAnchorPoint",
                        "focusMenu"
                    ]
                },
                ARROW_UP: {
                    actions: [
                        "highlightPrevItem",
                        "focusMenu"
                    ]
                },
                ARROW_DOWN: {
                    actions: [
                        "highlightNextItem",
                        "focusMenu"
                    ]
                },
                ARROW_LEFT: [
                    {
                        guard: and("isSubmenu", "isOpenControlled"),
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        guard: "isSubmenu",
                        target: "closed",
                        actions: [
                            "focusParentMenu",
                            "invokeOnClose"
                        ]
                    }
                ],
                HOME: {
                    actions: [
                        "highlightFirstItem",
                        "focusMenu"
                    ]
                },
                END: {
                    actions: [
                        "highlightLastItem",
                        "focusMenu"
                    ]
                },
                ARROW_RIGHT: {
                    guard: "isTriggerItemHighlighted",
                    actions: [
                        "openSubmenu"
                    ]
                },
                ENTER: [
                    {
                        guard: "isTriggerItemHighlighted",
                        actions: [
                            "openSubmenu"
                        ]
                    },
                    {
                        actions: [
                            "clickHighlightedItem"
                        ]
                    }
                ],
                ITEM_POINTERMOVE: [
                    {
                        guard: not("isPointerSuspended"),
                        actions: [
                            "setHighlightedItem",
                            "focusMenu"
                        ]
                    },
                    {
                        actions: [
                            "setLastHighlightedItem"
                        ]
                    }
                ],
                ITEM_POINTERLEAVE: {
                    guard: and(not("isPointerSuspended"), not("isTriggerItem")),
                    actions: [
                        "clearHighlightedItem"
                    ]
                },
                ITEM_CLICK: [
                    // == grouped ==
                    {
                        guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable"), "closeOnSelect", "isOpenControlled"),
                        actions: [
                            "invokeOnSelect",
                            "setOptionState",
                            "closeRootMenu",
                            "invokeOnClose"
                        ]
                    },
                    {
                        guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable"), "closeOnSelect"),
                        target: "closed",
                        actions: [
                            "invokeOnSelect",
                            "setOptionState",
                            "closeRootMenu",
                            "invokeOnClose"
                        ]
                    },
                    //
                    {
                        guard: and(not("isTriggerItemHighlighted"), not("isHighlightedItemEditable")),
                        actions: [
                            "invokeOnSelect",
                            "setOptionState"
                        ]
                    },
                    {
                        actions: [
                            "setHighlightedItem"
                        ]
                    }
                ],
                TRIGGER_POINTERMOVE: {
                    guard: "isTriggerItem",
                    actions: [
                        "setIntentPolygon"
                    ]
                },
                TRIGGER_POINTERLEAVE: {
                    target: "closing"
                },
                ITEM_POINTERDOWN: {
                    actions: [
                        "setHighlightedItem"
                    ]
                },
                TYPEAHEAD: {
                    actions: [
                        "highlightMatchedItem"
                    ]
                },
                FOCUS_MENU: {
                    actions: [
                        "focusMenu"
                    ]
                },
                "POSITIONING.SET": {
                    actions: [
                        "reposition"
                    ]
                }
            }
        }
    },
    implementations: {
        guards: {
            closeOnSelect: (param)=>{
                let { prop, event } = param;
                var _event_closeOnSelect;
                return !!((_event_closeOnSelect = event === null || event === void 0 ? void 0 : event.closeOnSelect) !== null && _event_closeOnSelect !== void 0 ? _event_closeOnSelect : prop("closeOnSelect"));
            },
            // whether the trigger is also a menu item
            isTriggerItem: (param)=>{
                let { event } = param;
                return isTriggerItem(event.target);
            },
            // whether the trigger item is the active item
            isTriggerItemHighlighted: (param)=>{
                let { event, scope, computed } = param;
                var _event_target;
                const target = (_event_target = event.target) !== null && _event_target !== void 0 ? _event_target : scope.getById(computed("highlightedId"));
                return !!(target === null || target === void 0 ? void 0 : target.hasAttribute("aria-controls"));
            },
            isSubmenu: (param)=>{
                let { computed } = param;
                return computed("isSubmenu");
            },
            isPointerSuspended: (param)=>{
                let { context } = param;
                return context.get("suspendPointer");
            },
            isHighlightedItemEditable: (param)=>{
                let { scope, computed } = param;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEditableElement"])(scope.getById(computed("highlightedId")));
            },
            // guard assertions (for controlled mode)
            isOpenControlled: (param)=>{
                let { prop } = param;
                return prop("open") !== void 0;
            },
            isArrowLeftEvent: (param)=>{
                let { event } = param;
                var _event_previousEvent;
                return ((_event_previousEvent = event.previousEvent) === null || _event_previousEvent === void 0 ? void 0 : _event_previousEvent.type) === "ARROW_LEFT";
            },
            isArrowUpEvent: (param)=>{
                let { event } = param;
                var _event_previousEvent;
                return ((_event_previousEvent = event.previousEvent) === null || _event_previousEvent === void 0 ? void 0 : _event_previousEvent.type) === "ARROW_UP";
            },
            isArrowDownEvent: (param)=>{
                let { event } = param;
                var _event_previousEvent;
                return ((_event_previousEvent = event.previousEvent) === null || _event_previousEvent === void 0 ? void 0 : _event_previousEvent.type) === "ARROW_DOWN";
            },
            isOpenAutoFocusEvent: (param)=>{
                let { event } = param;
                var _event_previousEvent;
                return ((_event_previousEvent = event.previousEvent) === null || _event_previousEvent === void 0 ? void 0 : _event_previousEvent.type) === "OPEN_AUTOFOCUS";
            }
        },
        effects: {
            waitForOpenDelay (param) {
                let { send } = param;
                const timer = setTimeout(()=>{
                    send({
                        type: "DELAY.OPEN"
                    });
                }, 100);
                return ()=>clearTimeout(timer);
            },
            waitForCloseDelay (param) {
                let { send } = param;
                const timer = setTimeout(()=>{
                    send({
                        type: "DELAY.CLOSE"
                    });
                }, 300);
                return ()=>clearTimeout(timer);
            },
            waitForLongPress (param) {
                let { send } = param;
                const timer = setTimeout(()=>{
                    send({
                        type: "LONG_PRESS.OPEN"
                    });
                }, 700);
                return ()=>clearTimeout(timer);
            },
            trackPositioning (param) {
                let { context, prop, scope, refs } = param;
                if (!!getContextTriggerEl(scope)) return;
                const positioning = {
                    ...prop("positioning"),
                    ...refs.get("positioningOverride")
                };
                context.set("currentPlacement", positioning.placement);
                const getPositionerEl2 = ()=>getPositionerEl(scope);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPlacement"])(getTriggerEl(scope), getPositionerEl2, {
                    ...positioning,
                    defer: true,
                    onComplete (data) {
                        context.set("currentPlacement", data.placement);
                    }
                });
            },
            trackInteractOutside (param) {
                let { refs, scope, prop, computed, send } = param;
                const getContentEl2 = ()=>getContentEl(scope);
                let restoreFocus = true;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trackDismissableElement"])(getContentEl2, {
                    defer: true,
                    exclude: [
                        getTriggerEl(scope)
                    ],
                    onInteractOutside: prop("onInteractOutside"),
                    onFocusOutside: prop("onFocusOutside"),
                    onEscapeKeyDown (event) {
                        var _prop;
                        (_prop = prop("onEscapeKeyDown")) === null || _prop === void 0 ? void 0 : _prop(event);
                        if (computed("isSubmenu")) event.preventDefault();
                        closeRootMenu({
                            parent: refs.get("parent")
                        });
                    },
                    onPointerDownOutside (event) {
                        var _prop;
                        const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event.detail.originalEvent);
                        const isWithinContextTrigger = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(getContextTriggerEl(scope), target);
                        if (isWithinContextTrigger && event.detail.contextmenu) {
                            event.preventDefault();
                            return;
                        }
                        restoreFocus = !event.detail.focusable;
                        (_prop = prop("onPointerDownOutside")) === null || _prop === void 0 ? void 0 : _prop(event);
                    },
                    onDismiss () {
                        send({
                            type: "CLOSE",
                            src: "interact-outside",
                            restoreFocus
                        });
                    }
                });
            },
            trackPointerMove (param) {
                let { context, scope, send, refs, flush } = param;
                const parent = refs.get("parent");
                flush(()=>{
                    parent.context.set("suspendPointer", true);
                });
                const doc = scope.getDoc();
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(doc, "pointermove", (e)=>{
                    const isMovingToSubmenu = isWithinPolygon(context.get("intentPolygon"), {
                        x: e.clientX,
                        y: e.clientY
                    });
                    if (!isMovingToSubmenu) {
                        send({
                            type: "POINTER_MOVED_AWAY_FROM_SUBMENU"
                        });
                        parent.context.set("suspendPointer", false);
                    }
                });
            },
            scrollToHighlightedItem (param) {
                let { event, scope, computed } = param;
                const exec = ()=>{
                    if (event.type.startsWith("ITEM_POINTER")) return;
                    const itemEl = scope.getById(computed("highlightedId"));
                    const contentEl2 = getContentEl(scope);
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scrollIntoView"])(itemEl, {
                        rootEl: contentEl2,
                        block: "nearest"
                    });
                };
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"])(()=>exec());
                const contentEl = ()=>getContentEl(scope);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["observeAttributes"])(contentEl, {
                    defer: true,
                    attributes: [
                        "aria-activedescendant"
                    ],
                    callback: exec
                });
            }
        },
        actions: {
            setAnchorPoint (param) {
                let { context, event } = param;
                context.set("anchorPoint", event.point);
            },
            setSubmenuPlacement (param) {
                let { computed, refs } = param;
                if (!computed("isSubmenu")) return;
                const placement = computed("isRtl") ? "left-start" : "right-start";
                refs.set("positioningOverride", {
                    placement,
                    gutter: 0
                });
            },
            reposition (param) {
                let { context, scope, prop, event, refs } = param;
                const getPositionerEl2 = ()=>getPositionerEl(scope);
                const anchorPoint = context.get("anchorPoint");
                const getAnchorRect = anchorPoint ? ()=>({
                        width: 0,
                        height: 0,
                        ...anchorPoint
                    }) : void 0;
                const positioning = {
                    ...prop("positioning"),
                    ...refs.get("positioningOverride")
                };
                var _event_options;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPlacement"])(getTriggerEl(scope), getPositionerEl2, {
                    ...positioning,
                    defer: true,
                    getAnchorRect,
                    ...(_event_options = event.options) !== null && _event_options !== void 0 ? _event_options : {},
                    listeners: false,
                    onComplete (data) {
                        context.set("currentPlacement", data.placement);
                    }
                });
            },
            setOptionState (param) {
                let { event } = param;
                if (!event.option) return;
                const { checked, onCheckedChange, type } = event.option;
                if (type === "radio") {
                    onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(true);
                } else if (type === "checkbox") {
                    onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(!checked);
                }
            },
            clickHighlightedItem (param) {
                let { scope, computed } = param;
                const itemEl = scope.getById(computed("highlightedId"));
                if (!itemEl || itemEl.dataset.disabled) return;
                queueMicrotask(()=>itemEl.click());
            },
            setIntentPolygon (param) {
                let { context, scope, event } = param;
                const menu = getContentEl(scope);
                const placement = context.get("currentPlacement");
                if (!menu || !placement) return;
                const rect = menu.getBoundingClientRect();
                const polygon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rect$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getElementPolygon"])(rect, placement);
                if (!polygon) return;
                const rightSide = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$popper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPlacementSide"])(placement) === "right";
                const bleed = rightSide ? -5 : 5;
                context.set("intentPolygon", [
                    {
                        ...event.point,
                        x: event.point.x + bleed
                    },
                    ...polygon
                ]);
            },
            clearIntentPolygon (param) {
                let { context } = param;
                context.set("intentPolygon", null);
            },
            resumePointer (param) {
                let { refs, flush } = param;
                const parent = refs.get("parent");
                if (!parent) return;
                flush(()=>{
                    parent.context.set("suspendPointer", false);
                });
            },
            setHighlightedItem (param) {
                let { context, event } = param;
                const value = event.value || getItemValue(event.target);
                context.set("highlightedValue", value);
            },
            clearHighlightedItem (param) {
                let { context } = param;
                context.set("highlightedValue", null);
            },
            focusMenu (param) {
                let { scope } = param;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const contentEl = getContentEl(scope);
                    const initialFocusEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getInitialFocus"])({
                        root: contentEl,
                        enabled: !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["contains"])(contentEl, scope.getActiveElement()),
                        filter (node) {
                            var _node_role;
                            return !((_node_role = node.role) === null || _node_role === void 0 ? void 0 : _node_role.startsWith("menuitem"));
                        }
                    });
                    initialFocusEl === null || initialFocusEl === void 0 ? void 0 : initialFocusEl.focus({
                        preventScroll: true
                    });
                });
            },
            highlightFirstItem (param) {
                let { context, scope } = param;
                const fn = getContentEl(scope) ? queueMicrotask : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"];
                fn(()=>{
                    const first2 = getFirstEl(scope);
                    if (!first2) return;
                    context.set("highlightedValue", getItemValue(first2));
                });
            },
            highlightLastItem (param) {
                let { context, scope } = param;
                const fn = getContentEl(scope) ? queueMicrotask : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"];
                fn(()=>{
                    const last2 = getLastEl(scope);
                    if (!last2) return;
                    context.set("highlightedValue", getItemValue(last2));
                });
            },
            highlightNextItem (param) {
                let { context, scope, event, prop } = param;
                const next2 = getNextEl(scope, {
                    loop: event.loop,
                    value: context.get("highlightedValue"),
                    loopFocus: prop("loopFocus")
                });
                context.set("highlightedValue", getItemValue(next2));
            },
            highlightPrevItem (param) {
                let { context, scope, event, prop } = param;
                const prev2 = getPrevEl(scope, {
                    loop: event.loop,
                    value: context.get("highlightedValue"),
                    loopFocus: prop("loopFocus")
                });
                context.set("highlightedValue", getItemValue(prev2));
            },
            invokeOnSelect (param) {
                let { context, prop, scope } = param;
                var _prop;
                const value = context.get("highlightedValue");
                if (value == null) return;
                const node = getItemEl(scope, value);
                dispatchSelectionEvent(node, value);
                (_prop = prop("onSelect")) === null || _prop === void 0 ? void 0 : _prop({
                    value
                });
            },
            focusTrigger (param) {
                let { scope, context, event, computed } = param;
                if (computed("isSubmenu") || context.get("anchorPoint") || event.restoreFocus === false) return;
                queueMicrotask(()=>{
                    var _getTriggerEl;
                    return (_getTriggerEl = getTriggerEl(scope)) === null || _getTriggerEl === void 0 ? void 0 : _getTriggerEl.focus({
                        preventScroll: true
                    });
                });
            },
            highlightMatchedItem (param) {
                let { scope, context, event, refs } = param;
                const node = getElemByKey(scope, {
                    key: event.key,
                    value: context.get("highlightedValue"),
                    typeaheadState: refs.get("typeaheadState")
                });
                if (!node) return;
                context.set("highlightedValue", getItemValue(node));
            },
            setParentMenu (param) {
                let { refs, event } = param;
                refs.set("parent", event.value);
            },
            setChildMenu (param) {
                let { refs, event } = param;
                const children = refs.get("children");
                children[event.id] = event.value;
                refs.set("children", children);
            },
            closeRootMenu (param) {
                let { refs } = param;
                closeRootMenu({
                    parent: refs.get("parent")
                });
            },
            openSubmenu (param) {
                let { refs, scope, computed } = param;
                const item = scope.getById(computed("highlightedId"));
                const id = item === null || item === void 0 ? void 0 : item.getAttribute("data-uid");
                const children = refs.get("children");
                const child = id ? children[id] : null;
                child === null || child === void 0 ? void 0 : child.send({
                    type: "OPEN_AUTOFOCUS"
                });
            },
            focusParentMenu (param) {
                let { refs } = param;
                var _refs_get;
                (_refs_get = refs.get("parent")) === null || _refs_get === void 0 ? void 0 : _refs_get.send({
                    type: "FOCUS_MENU"
                });
            },
            setLastHighlightedItem (param) {
                let { context, event } = param;
                context.set("lastHighlightedValue", getItemValue(event.target));
            },
            restoreHighlightedItem (param) {
                let { context } = param;
                if (!context.get("lastHighlightedValue")) return;
                context.set("highlightedValue", context.get("lastHighlightedValue"));
                context.set("lastHighlightedValue", null);
            },
            restoreParentHighlightedItem (param) {
                let { refs } = param;
                var _refs_get;
                (_refs_get = refs.get("parent")) === null || _refs_get === void 0 ? void 0 : _refs_get.send({
                    type: "HIGHLIGHTED.RESTORE"
                });
            },
            invokeOnOpen (param) {
                let { prop } = param;
                var _prop;
                (_prop = prop("onOpenChange")) === null || _prop === void 0 ? void 0 : _prop({
                    open: true
                });
            },
            invokeOnClose (param) {
                let { prop } = param;
                var _prop;
                (_prop = prop("onOpenChange")) === null || _prop === void 0 ? void 0 : _prop({
                    open: false
                });
            },
            toggleVisibility (param) {
                let { prop, event, send } = param;
                send({
                    type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: event
                });
            }
        }
    }
});
function closeRootMenu(ctx) {
    let parent = ctx.parent;
    while(parent && parent.computed("isSubmenu")){
        parent = parent.refs.get("parent");
    }
    parent === null || parent === void 0 ? void 0 : parent.send({
        type: "CLOSE"
    });
}
function isWithinPolygon(polygon, point) {
    if (!polygon) return false;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$rect$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPointInPolygon"])(polygon, point);
}
function resolveItemId(children, value, scope) {
    const hasChildren = Object.keys(children).length > 0;
    if (!value) return null;
    if (!hasChildren) {
        return getItemId(scope, value);
    }
    for(const id in children){
        const childMenu = children[id];
        const childTriggerId = getTriggerId(childMenu.scope);
        if (childTriggerId === value) {
            return childTriggerId;
        }
    }
    return getItemId(scope, value);
}
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createProps"])()([
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultHighlightedValue",
    "defaultOpen",
    "dir",
    "getRootNode",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
var itemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createProps"])()([
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
]);
var splitItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSplitProps"])(itemProps);
var itemGroupLabelProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createProps"])()([
    "htmlFor"
]);
var splitItemGroupLabelProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSplitProps"])(itemGroupLabelProps);
var itemGroupProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createProps"])()([
    "id"
]);
var splitItemGroupProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSplitProps"])(itemGroupProps);
var optionItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createProps"])()([
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "type",
    "value",
    "valueText"
]);
var splitOptionItemProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSplitProps"])(optionItemProps);
;
}),
"[project]/node_modules/@zag-js/aria-hidden/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/walk-tree-outside.ts
__turbopack_context__.s({
    "ariaHidden": ()=>ariaHidden
});
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node)=>node && (node.host || unwrapHost(node.parentNode));
var correctTargets = (parent, targets)=>targets.map((target)=>{
        if (parent.contains(target)) return target;
        const correctedTarget = unwrapHost(target);
        if (correctedTarget && parent.contains(correctedTarget)) {
            return correctedTarget;
        }
        console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent, ". Doing nothing");
        return null;
    }).filter((x)=>Boolean(x));
var isIgnoredNode = (node)=>{
    if (node.localName === "next-route-announcer") return true;
    if (node.localName === "script") return true;
    if (node.hasAttribute("aria-live")) return true;
    return node.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props)=>{
    const { parentNode, markerName, controlAttribute } = props;
    const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [
        originalTarget
    ]);
    markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
    const markerCounter = markerMap[markerName];
    const hiddenNodes = [];
    const elementsToKeep = /* @__PURE__ */ new Set();
    const elementsToStop = new Set(targets);
    const keep = (el)=>{
        if (!el || elementsToKeep.has(el)) return;
        elementsToKeep.add(el);
        keep(el.parentNode);
    };
    targets.forEach(keep);
    const deep = (parent)=>{
        if (!parent || elementsToStop.has(parent)) {
            return;
        }
        Array.prototype.forEach.call(parent.children, (node)=>{
            if (elementsToKeep.has(node)) {
                deep(node);
            } else {
                try {
                    if (isIgnoredNode(node)) return;
                    const attr = node.getAttribute(controlAttribute);
                    const alreadyHidden = attr === "true";
                    const counterValue = (counterMap.get(node) || 0) + 1;
                    const markerValue = (markerCounter.get(node) || 0) + 1;
                    counterMap.set(node, counterValue);
                    markerCounter.set(node, markerValue);
                    hiddenNodes.push(node);
                    if (counterValue === 1 && alreadyHidden) {
                        uncontrolledNodes.set(node, true);
                    }
                    if (markerValue === 1) {
                        node.setAttribute(markerName, "");
                    }
                    if (!alreadyHidden) {
                        node.setAttribute(controlAttribute, "true");
                    }
                } catch (e) {
                    console.error("[zag-js > ariaHidden] cannot operate on ", node, e);
                }
            }
        });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return ()=>{
        hiddenNodes.forEach((node)=>{
            const counterValue = counterMap.get(node) - 1;
            const markerValue = markerCounter.get(node) - 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            if (!counterValue) {
                if (!uncontrolledNodes.has(node)) {
                    node.removeAttribute(controlAttribute);
                }
                uncontrolledNodes.delete(node);
            }
            if (!markerValue) {
                node.removeAttribute(markerName);
            }
        });
        lockCount--;
        if (!lockCount) {
            counterMap = /* @__PURE__ */ new WeakMap();
            counterMap = /* @__PURE__ */ new WeakMap();
            uncontrolledNodes = /* @__PURE__ */ new WeakMap();
            markerMap = {};
        }
    };
};
// src/aria-hidden.ts
var getParentNode = (originalTarget)=>{
    const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return target.ownerDocument.body;
};
var hideOthers = function(originalTarget) {
    let parentNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getParentNode(originalTarget), markerName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "data-aria-hidden";
    if (!parentNode) return;
    return walkTreeOutside(originalTarget, {
        parentNode,
        markerName,
        controlAttribute: "aria-hidden"
    });
};
// src/index.ts
var raf = (fn)=>{
    const frameId = requestAnimationFrame(()=>fn());
    return ()=>cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { defer = true } = options;
    const func = defer ? raf : (v)=>v();
    const cleanups = [];
    cleanups.push(func(()=>{
        const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
        const elements = targets.filter(Boolean);
        if (elements.length === 0) return;
        cleanups.push(hideOthers(elements));
    }));
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
    };
}
;
}),
"[project]/node_modules/@zag-js/focus-trap/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "FocusTrap": ()=>FocusTrap,
    "trapFocus": ()=>trapFocus
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
;
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
    activateTrap (trapStack, trap) {
        if (trapStack.length > 0) {
            const activeTrap = trapStack[trapStack.length - 1];
            if (activeTrap !== trap) {
                activeTrap.pause();
            }
        }
        const trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
            trapStack.push(trap);
        } else {
            trapStack.splice(trapIndex, 1);
            trapStack.push(trap);
        }
    },
    deactivateTrap (trapStack, trap) {
        const trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
            trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
            trapStack[trapStack.length - 1].unpause();
        }
    }
};
var sharedTrapStack = [];
var FocusTrap = class {
    get active() {
        return this.state.active;
    }
    get paused() {
        return this.state.paused;
    }
    findContainerIndex(element, event) {
        const composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
        return this.state.containerGroups.findIndex((param)=>{
            let { container, tabbableNodes } = param;
            return container.contains(element) || (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find((node)=>node === element);
        });
    }
    updateTabbableNodes() {
        this.state.containerGroups = this.state.containers.map((container)=>{
            const tabbableNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTabbables"])(container);
            const focusableNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getFocusables"])(container);
            const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
            const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
            const firstDomTabbableNode = focusableNodes.find((node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(node));
            const lastDomTabbableNode = focusableNodes.slice().reverse().find((node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(node));
            const posTabIndexesFound = !!tabbableNodes.find((node)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTabIndex"])(node) > 0);
            function nextTabbableNode(node) {
                let forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                const nodeIdx = tabbableNodes.indexOf(node);
                if (nodeIdx < 0) {
                    if (forward) {
                        return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(el));
                    }
                    return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(el));
                }
                return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
            }
            return {
                container,
                tabbableNodes,
                focusableNodes,
                posTabIndexesFound,
                firstTabbableNode,
                lastTabbableNode,
                firstDomTabbableNode,
                lastDomTabbableNode,
                nextTabbableNode
            };
        });
        this.state.tabbableGroups = this.state.containerGroups.filter((group)=>group.tabbableNodes.length > 0);
        if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
            throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (this.state.containerGroups.find((g)=>g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
            throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
    }
    addListeners() {
        if (!this.state.active) return;
        activeFocusTraps.activateTrap(this.trapStack, this);
        this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(()=>{
            this.tryFocus(this.getInitialFocusNode());
        }) : this.tryFocus(this.getInitialFocusNode());
        this.listenerCleanups.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(this.doc, "focusin", this.handleFocus, true), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(this.doc, "mousedown", this.handlePointerDown, {
            capture: true,
            passive: false
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(this.doc, "touchstart", this.handlePointerDown, {
            capture: true,
            passive: false
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(this.doc, "click", this.handleClick, {
            capture: true,
            passive: false
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(this.doc, "keydown", this.handleTabKey, {
            capture: true,
            passive: false
        }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addDomEvent"])(this.doc, "keydown", this.handleEscapeKey));
        return this;
    }
    removeListeners() {
        if (!this.state.active) return;
        this.listenerCleanups.forEach((cleanup)=>cleanup());
        this.listenerCleanups = [];
        return this;
    }
    activate(activateOptions) {
        if (this.state.active) {
            return this;
        }
        const onActivate = this.getOption(activateOptions, "onActivate");
        const onPostActivate = this.getOption(activateOptions, "onPostActivate");
        const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
            this.updateTabbableNodes();
        }
        this.state.active = true;
        this.state.paused = false;
        this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
        onActivate === null || onActivate === void 0 ? void 0 : onActivate();
        const finishActivation = ()=>{
            if (checkCanFocusTrap) {
                this.updateTabbableNodes();
            }
            this.addListeners();
            this.updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 ? void 0 : onPostActivate();
        };
        if (checkCanFocusTrap) {
            checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
            return this;
        }
        finishActivation();
        return this;
    }
    constructor(elements, options){
        var _this = this;
        __publicField(this, "trapStack");
        __publicField(this, "config");
        __publicField(this, "doc");
        __publicField(this, "state", {
            containers: [],
            containerGroups: [],
            tabbableGroups: [],
            nodeFocusedBeforeActivation: null,
            mostRecentlyFocusedNode: null,
            active: false,
            paused: false,
            delayInitialFocusTimer: void 0,
            recentNavEvent: void 0
        });
        __publicField(this, "listenerCleanups", []);
        __publicField(this, "handleFocus", (event)=>{
            const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
            const targetContained = this.findContainerIndex(target, event) >= 0;
            if (targetContained || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDocument"])(target)) {
                if (targetContained) {
                    this.state.mostRecentlyFocusedNode = target;
                }
            } else {
                event.stopImmediatePropagation();
                let nextNode;
                let navAcrossContainers = true;
                if (this.state.mostRecentlyFocusedNode) {
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTabIndex"])(this.state.mostRecentlyFocusedNode) > 0) {
                        const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
                        const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
                        if (tabbableNodes.length > 0) {
                            const mruTabIdx = tabbableNodes.findIndex((node)=>node === this.state.mostRecentlyFocusedNode);
                            if (mruTabIdx >= 0) {
                                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                                    if (mruTabIdx + 1 < tabbableNodes.length) {
                                        nextNode = tabbableNodes[mruTabIdx + 1];
                                        navAcrossContainers = false;
                                    }
                                } else {
                                    if (mruTabIdx - 1 >= 0) {
                                        nextNode = tabbableNodes[mruTabIdx - 1];
                                        navAcrossContainers = false;
                                    }
                                }
                            }
                        }
                    } else {
                        if (!this.state.containerGroups.some((g)=>g.tabbableNodes.some((n)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTabIndex"])(n) > 0))) {
                            navAcrossContainers = false;
                        }
                    }
                } else {
                    navAcrossContainers = false;
                }
                if (navAcrossContainers) {
                    nextNode = this.findNextNavNode({
                        // move FROM the MRU node, not event-related node (which will be the node that is
                        //  outside the trap causing the focus escape we're trying to fix)
                        target: this.state.mostRecentlyFocusedNode,
                        isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
                    });
                }
                if (nextNode) {
                    this.tryFocus(nextNode);
                } else {
                    this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
                }
            }
            this.state.recentNavEvent = void 0;
        });
        __publicField(this, "handlePointerDown", (event)=>{
            const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
            if (this.findContainerIndex(target, event) >= 0) {
                return;
            }
            if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
                this.deactivate({
                    returnFocus: this.config.returnFocusOnDeactivate
                });
                return;
            }
            if (valueOrHandler(this.config.allowOutsideClick, event)) {
                return;
            }
            event.preventDefault();
        });
        __publicField(this, "handleClick", (event)=>{
            const target = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
            if (this.findContainerIndex(target, event) >= 0) {
                return;
            }
            if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
                return;
            }
            if (valueOrHandler(this.config.allowOutsideClick, event)) {
                return;
            }
            event.preventDefault();
            event.stopImmediatePropagation();
        });
        __publicField(this, "handleTabKey", (event)=>{
            if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
                this.state.recentNavEvent = event;
                const isBackward = this.config.isKeyBackward(event);
                const destinationNode = this.findNextNavNode({
                    event,
                    isBackward
                });
                if (!destinationNode) return;
                if (isTabEvent(event)) {
                    event.preventDefault();
                }
                this.tryFocus(destinationNode);
            }
        });
        __publicField(this, "handleEscapeKey", (event)=>{
            if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
                event.preventDefault();
                this.deactivate();
            }
        });
        __publicField(this, "_mutationObserver");
        __publicField(this, "setupMutationObserver", ()=>{
            const win = this.doc.defaultView || window;
            this._mutationObserver = new win.MutationObserver((mutations)=>{
                const isFocusedNodeRemoved = mutations.some((mutation)=>{
                    const removedNodes = Array.from(mutation.removedNodes);
                    return removedNodes.some((node)=>node === this.state.mostRecentlyFocusedNode);
                });
                if (isFocusedNodeRemoved) {
                    this.tryFocus(this.getInitialFocusNode());
                }
            });
        });
        __publicField(this, "updateObservedNodes", ()=>{
            var _this__mutationObserver;
            (_this__mutationObserver = this._mutationObserver) === null || _this__mutationObserver === void 0 ? void 0 : _this__mutationObserver.disconnect();
            if (this.state.active && !this.state.paused) {
                this.state.containers.map((container)=>{
                    var _this__mutationObserver;
                    (_this__mutationObserver = this._mutationObserver) === null || _this__mutationObserver === void 0 ? void 0 : _this__mutationObserver.observe(container, {
                        subtree: true,
                        childList: true
                    });
                });
            }
        });
        __publicField(this, "getInitialFocusNode", ()=>{
            let node = this.getNodeForOption("initialFocus", {
                hasFallback: true
            });
            if (node === false) {
                return false;
            }
            if (node === void 0 || node && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(node)) {
                if (this.findContainerIndex(this.doc.activeElement) >= 0) {
                    node = this.doc.activeElement;
                } else {
                    const firstTabbableGroup = this.state.tabbableGroups[0];
                    const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
                    node = firstTabbableNode || this.getNodeForOption("fallbackFocus");
                }
            } else if (node === null) {
                node = this.getNodeForOption("fallbackFocus");
            }
            if (!node) {
                throw new Error("Your focus-trap needs to have at least one focusable element");
            }
            if (!node.isConnected) {
                node = this.getNodeForOption("fallbackFocus");
            }
            return node;
        });
        __publicField(this, "tryFocus", (node)=>{
            if (node === false) return;
            if (node === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveElement"])(this.doc)) return;
            if (!node || !node.focus) {
                this.tryFocus(this.getInitialFocusNode());
                return;
            }
            node.focus({
                preventScroll: !!this.config.preventScroll
            });
            this.state.mostRecentlyFocusedNode = node;
            if (isSelectableInput(node)) {
                node.select();
            }
        });
        __publicField(this, "deactivate", (deactivateOptions)=>{
            if (!this.state.active) return this;
            const options = {
                onDeactivate: this.config.onDeactivate,
                onPostDeactivate: this.config.onPostDeactivate,
                checkCanReturnFocus: this.config.checkCanReturnFocus,
                ...deactivateOptions
            };
            clearTimeout(this.state.delayInitialFocusTimer);
            this.state.delayInitialFocusTimer = void 0;
            this.removeListeners();
            this.state.active = false;
            this.state.paused = false;
            this.updateObservedNodes();
            activeFocusTraps.deactivateTrap(this.trapStack, this);
            const onDeactivate = this.getOption(options, "onDeactivate");
            const onPostDeactivate = this.getOption(options, "onPostDeactivate");
            const checkCanReturnFocus = this.getOption(options, "checkCanReturnFocus");
            const returnFocus = this.getOption(options, "returnFocus", "returnFocusOnDeactivate");
            onDeactivate === null || onDeactivate === void 0 ? void 0 : onDeactivate();
            const finishDeactivation = ()=>{
                delay(()=>{
                    if (returnFocus) {
                        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
                        this.tryFocus(returnFocusNode);
                    }
                    onPostDeactivate === null || onPostDeactivate === void 0 ? void 0 : onPostDeactivate();
                });
            };
            if (returnFocus && checkCanReturnFocus) {
                const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
                checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
                return this;
            }
            finishDeactivation();
            return this;
        });
        __publicField(this, "pause", (pauseOptions)=>{
            if (this.state.paused || !this.state.active) {
                return this;
            }
            const onPause = this.getOption(pauseOptions, "onPause");
            const onPostPause = this.getOption(pauseOptions, "onPostPause");
            this.state.paused = true;
            onPause === null || onPause === void 0 ? void 0 : onPause();
            this.removeListeners();
            this.updateObservedNodes();
            onPostPause === null || onPostPause === void 0 ? void 0 : onPostPause();
            return this;
        });
        __publicField(this, "unpause", (unpauseOptions)=>{
            if (!this.state.paused || !this.state.active) {
                return this;
            }
            const onUnpause = this.getOption(unpauseOptions, "onUnpause");
            const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
            this.state.paused = false;
            onUnpause === null || onUnpause === void 0 ? void 0 : onUnpause();
            this.updateTabbableNodes();
            this.addListeners();
            this.updateObservedNodes();
            onPostUnpause === null || onPostUnpause === void 0 ? void 0 : onPostUnpause();
            return this;
        });
        __publicField(this, "updateContainerElements", (containerElements)=>{
            this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [
                containerElements
            ].filter(Boolean);
            if (this.state.active) {
                this.updateTabbableNodes();
            }
            this.updateObservedNodes();
            return this;
        });
        __publicField(this, "getReturnFocusNode", (previousActiveElement)=>{
            const node = this.getNodeForOption("setReturnFocus", {
                params: [
                    previousActiveElement
                ]
            });
            return node ? node : node === false ? false : previousActiveElement;
        });
        __publicField(this, "getOption", (configOverrideOptions, optionName, configOptionName)=>{
            return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : // @ts-expect-error
            this.config[configOptionName || optionName];
        });
        __publicField(this, "getNodeForOption", function(optionName) {
            let { hasFallback = false, params = [] } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            let optionValue = _this.config[optionName];
            if (typeof optionValue === "function") optionValue = optionValue(...params);
            if (optionValue === true) optionValue = void 0;
            if (!optionValue) {
                if (optionValue === void 0 || optionValue === false) {
                    return optionValue;
                }
                throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
            }
            let node = optionValue;
            if (typeof optionValue === "string") {
                try {
                    node = _this.doc.querySelector(optionValue);
                } catch (err) {
                    throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
                }
                if (!node) {
                    if (!hasFallback) {
                        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
                    }
                }
            }
            return node;
        });
        __publicField(this, "findNextNavNode", (opts)=>{
            const { event, isBackward = false } = opts;
            const target = opts.target || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEventTarget"])(event);
            this.updateTabbableNodes();
            let destinationNode = null;
            if (this.state.tabbableGroups.length > 0) {
                const containerIndex = this.findContainerIndex(target, event);
                const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
                if (containerIndex < 0) {
                    if (isBackward) {
                        destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
                    } else {
                        destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
                    }
                } else if (isBackward) {
                    let startOfGroupIndex = this.state.tabbableGroups.findIndex((param)=>{
                        let { firstTabbableNode } = param;
                        return target === firstTabbableNode;
                    });
                    if (startOfGroupIndex < 0 && ((containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.container) === target || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(target) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(target) && !(containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.nextTabbableNode(target, false)))) {
                        startOfGroupIndex = containerIndex;
                    }
                    if (startOfGroupIndex >= 0) {
                        const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
                        const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
                        destinationNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTabIndex"])(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
                    } else if (!isTabEvent(event)) {
                        destinationNode = containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.nextTabbableNode(target, false);
                    }
                } else {
                    let lastOfGroupIndex = this.state.tabbableGroups.findIndex((param)=>{
                        let { lastTabbableNode } = param;
                        return target === lastTabbableNode;
                    });
                    if (lastOfGroupIndex < 0 && ((containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.container) === target || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFocusable"])(target) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTabbable"])(target) && !(containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.nextTabbableNode(target)))) {
                        lastOfGroupIndex = containerIndex;
                    }
                    if (lastOfGroupIndex >= 0) {
                        const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
                        const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
                        destinationNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getTabIndex"])(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
                    } else if (!isTabEvent(event)) {
                        destinationNode = containerGroup === null || containerGroup === void 0 ? void 0 : containerGroup.nextTabbableNode(target);
                    }
                }
            } else {
                destinationNode = this.getNodeForOption("fallbackFocus");
            }
            return destinationNode;
        });
        this.trapStack = options.trapStack || sharedTrapStack;
        const config = {
            returnFocusOnDeactivate: true,
            escapeDeactivates: true,
            delayInitialFocus: true,
            isKeyForward (e) {
                return isTabEvent(e) && !e.shiftKey;
            },
            isKeyBackward (e) {
                return isTabEvent(e) && e.shiftKey;
            },
            ...options
        };
        this.doc = config.document || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])(Array.isArray(elements) ? elements[0] : elements);
        this.config = config;
        this.updateContainerElements(elements);
        this.setupMutationObserver();
    }
};
var isTabEvent = (event)=>event.key === "Tab";
var valueOrHandler = function(value) {
    for(var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value(...params) : value;
};
var isEscapeEvent = (event)=>!event.isComposing && event.key === "Escape";
var delay = (fn)=>setTimeout(fn, 0);
var isSelectableInput = (node)=>node.localName === "input" && "select" in node && typeof node.select === "function";
// src/index.ts
function trapFocus(el) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let trap;
    const cleanup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"])(()=>{
        const contentEl = typeof el === "function" ? el() : el;
        if (!contentEl) return;
        trap = new FocusTrap(contentEl, {
            escapeDeactivates: false,
            allowOutsideClick: true,
            preventScroll: true,
            returnFocusOnDeactivate: true,
            delayInitialFocus: false,
            fallbackFocus: contentEl,
            ...options,
            document: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])(contentEl)
        });
        try {
            trap.activate();
        } catch (e) {}
    });
    return function destroy() {
        trap === null || trap === void 0 ? void 0 : trap.deactivate();
        cleanup();
    };
}
;
}),
"[project]/node_modules/@zag-js/remove-scroll/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "preventBodyScroll": ()=>preventBodyScroll
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
;
// src/index.ts
var LOCK_CLASSNAME = "data-scroll-lock";
function getPaddingProperty(documentElement) {
    const documentLeft = documentElement.getBoundingClientRect().left;
    const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
    return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
    const doc = _document !== null && _document !== void 0 ? _document : document;
    var _doc_defaultView;
    const win = (_doc_defaultView = doc.defaultView) !== null && _doc_defaultView !== void 0 ? _doc_defaultView : window;
    const { documentElement, body } = doc;
    const locked = body.hasAttribute(LOCK_CLASSNAME);
    if (locked) return;
    const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
    body.setAttribute(LOCK_CLASSNAME, "");
    const setScrollbarWidthProperty = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setStyleProperty"])(documentElement, "--scrollbar-width", "".concat(scrollbarWidth, "px"));
    const paddingProperty = getPaddingProperty(documentElement);
    const setBodyStyle = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setStyle"])(body, {
            overflow: "hidden",
            [paddingProperty]: "".concat(scrollbarWidth, "px")
        });
    const setBodyStyleIOS = ()=>{
        const { scrollX, scrollY, visualViewport } = win;
        var _visualViewport_offsetLeft;
        const offsetLeft = (_visualViewport_offsetLeft = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.offsetLeft) !== null && _visualViewport_offsetLeft !== void 0 ? _visualViewport_offsetLeft : 0;
        var _visualViewport_offsetTop;
        const offsetTop = (_visualViewport_offsetTop = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.offsetTop) !== null && _visualViewport_offsetTop !== void 0 ? _visualViewport_offsetTop : 0;
        const restoreStyle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setStyle"])(body, {
            position: "fixed",
            overflow: "hidden",
            top: "".concat(-(scrollY - Math.floor(offsetTop)), "px"),
            left: "".concat(-(scrollX - Math.floor(offsetLeft)), "px"),
            right: "0",
            [paddingProperty]: "".concat(scrollbarWidth, "px")
        });
        return ()=>{
            restoreStyle === null || restoreStyle === void 0 ? void 0 : restoreStyle();
            win.scrollTo({
                left: scrollX,
                top: scrollY,
                behavior: "instant"
            });
        };
    };
    const cleanups = [
        setScrollbarWidthProperty(),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isIos"])() ? setBodyStyleIOS() : setBodyStyle()
    ];
    return ()=>{
        cleanups.forEach((fn)=>fn === null || fn === void 0 ? void 0 : fn());
        body.removeAttribute(LOCK_CLASSNAME);
    };
}
;
}),
"[project]/node_modules/@zag-js/dialog/dist/index.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "anatomy": ()=>anatomy,
    "connect": ()=>connect,
    "machine": ()=>machine,
    "props": ()=>props,
    "splitProps": ()=>splitProps
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/anatomy/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$aria$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/aria-hidden/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/core/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dismissable/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/dom-query/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$trap$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/focus-trap/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$remove$2d$scroll$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/remove-scroll/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/types/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@zag-js/utils/dist/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
// src/dialog.anatomy.ts
var anatomy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$anatomy$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createAnatomy"])("dialog").parts("trigger", "backdrop", "positioner", "content", "title", "description", "closeTrigger");
var parts = anatomy.build();
// src/dialog.dom.ts
var getPositionerId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_positioner;
    return (_ctx_ids_positioner = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.positioner) !== null && _ctx_ids_positioner !== void 0 ? _ctx_ids_positioner : "dialog:".concat(ctx.id, ":positioner");
};
var getBackdropId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_backdrop;
    return (_ctx_ids_backdrop = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.backdrop) !== null && _ctx_ids_backdrop !== void 0 ? _ctx_ids_backdrop : "dialog:".concat(ctx.id, ":backdrop");
};
var getContentId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_content;
    return (_ctx_ids_content = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.content) !== null && _ctx_ids_content !== void 0 ? _ctx_ids_content : "dialog:".concat(ctx.id, ":content");
};
var getTriggerId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_trigger;
    return (_ctx_ids_trigger = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.trigger) !== null && _ctx_ids_trigger !== void 0 ? _ctx_ids_trigger : "dialog:".concat(ctx.id, ":trigger");
};
var getTitleId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_title;
    return (_ctx_ids_title = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.title) !== null && _ctx_ids_title !== void 0 ? _ctx_ids_title : "dialog:".concat(ctx.id, ":title");
};
var getDescriptionId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_description;
    return (_ctx_ids_description = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.description) !== null && _ctx_ids_description !== void 0 ? _ctx_ids_description : "dialog:".concat(ctx.id, ":description");
};
var getCloseTriggerId = (ctx)=>{
    var _ctx_ids;
    var _ctx_ids_closeTrigger;
    return (_ctx_ids_closeTrigger = (_ctx_ids = ctx.ids) === null || _ctx_ids === void 0 ? void 0 : _ctx_ids.closeTrigger) !== null && _ctx_ids_closeTrigger !== void 0 ? _ctx_ids_closeTrigger : "dialog:".concat(ctx.id, ":close");
};
var getContentEl = (ctx)=>ctx.getById(getContentId(ctx));
var getPositionerEl = (ctx)=>ctx.getById(getPositionerId(ctx));
var getBackdropEl = (ctx)=>ctx.getById(getBackdropId(ctx));
var getTriggerEl = (ctx)=>ctx.getById(getTriggerId(ctx));
var getTitleEl = (ctx)=>ctx.getById(getTitleId(ctx));
var getDescriptionEl = (ctx)=>ctx.getById(getDescriptionId(ctx));
var getCloseTriggerEl = (ctx)=>ctx.getById(getCloseTriggerId(ctx));
// src/dialog.connect.ts
function connect(service, normalize) {
    const { state, send, context, prop, scope } = service;
    const ariaLabel = prop("aria-label");
    const open = state.matches("open");
    return {
        open,
        setOpen (nextOpen) {
            const open2 = state.matches("open");
            if (open2 === nextOpen) return;
            send({
                type: nextOpen ? "OPEN" : "CLOSE"
            });
        },
        getTriggerProps () {
            return normalize.button({
                ...parts.trigger.attrs,
                dir: prop("dir"),
                id: getTriggerId(scope),
                "aria-haspopup": "dialog",
                type: "button",
                "aria-expanded": open,
                "data-state": open ? "open" : "closed",
                "aria-controls": getContentId(scope),
                onClick (event) {
                    if (event.defaultPrevented) return;
                    send({
                        type: "TOGGLE"
                    });
                }
            });
        },
        getBackdropProps () {
            return normalize.element({
                ...parts.backdrop.attrs,
                dir: prop("dir"),
                hidden: !open,
                id: getBackdropId(scope),
                "data-state": open ? "open" : "closed"
            });
        },
        getPositionerProps () {
            return normalize.element({
                ...parts.positioner.attrs,
                dir: prop("dir"),
                id: getPositionerId(scope),
                style: {
                    pointerEvents: open ? void 0 : "none"
                }
            });
        },
        getContentProps () {
            const rendered = context.get("rendered");
            return normalize.element({
                ...parts.content.attrs,
                dir: prop("dir"),
                role: prop("role"),
                hidden: !open,
                id: getContentId(scope),
                tabIndex: -1,
                "data-state": open ? "open" : "closed",
                "aria-modal": true,
                "aria-label": ariaLabel || void 0,
                "aria-labelledby": ariaLabel || !rendered.title ? void 0 : getTitleId(scope),
                "aria-describedby": rendered.description ? getDescriptionId(scope) : void 0
            });
        },
        getTitleProps () {
            return normalize.element({
                ...parts.title.attrs,
                dir: prop("dir"),
                id: getTitleId(scope)
            });
        },
        getDescriptionProps () {
            return normalize.element({
                ...parts.description.attrs,
                dir: prop("dir"),
                id: getDescriptionId(scope)
            });
        },
        getCloseTriggerProps () {
            return normalize.button({
                ...parts.closeTrigger.attrs,
                dir: prop("dir"),
                id: getCloseTriggerId(scope),
                type: "button",
                onClick (event) {
                    if (event.defaultPrevented) return;
                    event.stopPropagation();
                    send({
                        type: "CLOSE"
                    });
                }
            });
        }
    };
}
var machine = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$core$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createMachine"])({
    props (param) {
        let { props: props2, scope } = param;
        const alertDialog = props2.role === "alertdialog";
        const initialFocusEl = alertDialog ? ()=>getCloseTriggerEl(scope) : void 0;
        return {
            role: "dialog",
            modal: true,
            trapFocus: true,
            preventScroll: true,
            closeOnInteractOutside: !alertDialog,
            closeOnEscape: true,
            restoreFocus: true,
            initialFocusEl,
            ...props2
        };
    },
    initialState (param) {
        let { prop } = param;
        const open = prop("open") || prop("defaultOpen");
        return open ? "open" : "closed";
    },
    context (param) {
        let { bindable } = param;
        return {
            rendered: bindable(()=>({
                    defaultValue: {
                        title: true,
                        description: true
                    }
                }))
        };
    },
    watch (param) {
        let { track, action, prop } = param;
        track([
            ()=>prop("open")
        ], ()=>{
            action([
                "toggleVisibility"
            ]);
        });
    },
    states: {
        open: {
            entry: [
                "checkRenderedElements",
                "syncZIndex"
            ],
            effects: [
                "trackDismissableElement",
                "trapFocus",
                "preventScroll",
                "hideContentBelow"
            ],
            on: {
                "CONTROLLED.CLOSE": {
                    target: "closed"
                },
                CLOSE: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    }
                ],
                TOGGLE: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnClose"
                        ]
                    },
                    {
                        target: "closed",
                        actions: [
                            "invokeOnClose"
                        ]
                    }
                ]
            }
        },
        closed: {
            on: {
                "CONTROLLED.OPEN": {
                    target: "open"
                },
                OPEN: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "invokeOnOpen"
                        ]
                    }
                ],
                TOGGLE: [
                    {
                        guard: "isOpenControlled",
                        actions: [
                            "invokeOnOpen"
                        ]
                    },
                    {
                        target: "open",
                        actions: [
                            "invokeOnOpen"
                        ]
                    }
                ]
            }
        }
    },
    implementations: {
        guards: {
            isOpenControlled: (param)=>{
                let { prop } = param;
                return prop("open") != void 0;
            }
        },
        effects: {
            trackDismissableElement (param) {
                let { scope, send, prop } = param;
                const getContentEl2 = ()=>getContentEl(scope);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dismissable$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trackDismissableElement"])(getContentEl2, {
                    defer: true,
                    pointerBlocking: prop("modal"),
                    exclude: [
                        getTriggerEl(scope)
                    ],
                    onInteractOutside (event) {
                        var _prop;
                        (_prop = prop("onInteractOutside")) === null || _prop === void 0 ? void 0 : _prop(event);
                        if (!prop("closeOnInteractOutside")) {
                            event.preventDefault();
                        }
                    },
                    persistentElements: prop("persistentElements"),
                    onFocusOutside: prop("onFocusOutside"),
                    onPointerDownOutside: prop("onPointerDownOutside"),
                    onEscapeKeyDown (event) {
                        var _prop;
                        (_prop = prop("onEscapeKeyDown")) === null || _prop === void 0 ? void 0 : _prop(event);
                        if (!prop("closeOnEscape")) {
                            event.preventDefault();
                        }
                    },
                    onDismiss () {
                        send({
                            type: "CLOSE",
                            src: "interact-outside"
                        });
                    }
                });
            },
            preventScroll (param) {
                let { scope, prop } = param;
                if (!prop("preventScroll")) return;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$remove$2d$scroll$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["preventBodyScroll"])(scope.getDoc());
            },
            trapFocus (param) {
                let { scope, prop } = param;
                if (!prop("trapFocus") || !prop("modal")) return;
                const contentEl = ()=>getContentEl(scope);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$focus$2d$trap$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trapFocus"])(contentEl, {
                    preventScroll: true,
                    returnFocusOnDeactivate: !!prop("restoreFocus"),
                    initialFocus: prop("initialFocusEl"),
                    setReturnFocus: (el)=>{
                        var _prop;
                        var _prop1;
                        return (_prop1 = (_prop = prop("finalFocusEl")) === null || _prop === void 0 ? void 0 : _prop()) !== null && _prop1 !== void 0 ? _prop1 : el;
                    }
                });
            },
            hideContentBelow (param) {
                let { scope, prop } = param;
                if (!prop("modal")) return;
                const getElements = ()=>[
                        getContentEl(scope)
                    ];
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$aria$2d$hidden$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ariaHidden"])(getElements, {
                    defer: true
                });
            }
        },
        actions: {
            checkRenderedElements (param) {
                let { context, scope } = param;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    context.set("rendered", {
                        title: !!getTitleEl(scope),
                        description: !!getDescriptionEl(scope)
                    });
                });
            },
            syncZIndex (param) {
                let { scope } = param;
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["raf"])(()=>{
                    const contentEl = getContentEl(scope);
                    if (!contentEl) return;
                    const styles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$dom$2d$query$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getComputedStyle"])(contentEl);
                    const elems = [
                        getPositionerEl(scope),
                        getBackdropEl(scope)
                    ];
                    elems.forEach((node)=>{
                        node === null || node === void 0 ? void 0 : node.style.setProperty("--z-index", styles.zIndex);
                    });
                });
            },
            invokeOnClose (param) {
                let { prop } = param;
                var _prop;
                (_prop = prop("onOpenChange")) === null || _prop === void 0 ? void 0 : _prop({
                    open: false
                });
            },
            invokeOnOpen (param) {
                let { prop } = param;
                var _prop;
                (_prop = prop("onOpenChange")) === null || _prop === void 0 ? void 0 : _prop({
                    open: true
                });
            },
            toggleVisibility (param) {
                let { prop, send, event } = param;
                send({
                    type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
                    previousEvent: event
                });
            }
        }
    }
});
var props = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createProps"])()([
    "aria-label",
    "closeOnEscape",
    "closeOnInteractOutside",
    "dir",
    "finalFocusEl",
    "getRootNode",
    "getRootNode",
    "id",
    "id",
    "ids",
    "initialFocusEl",
    "modal",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "defaultOpen",
    "open",
    "persistentElements",
    "preventScroll",
    "restoreFocus",
    "role",
    "trapFocus"
]);
var splitProps = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$zag$2d$js$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createSplitProps"])(props);
;
}),
}]);

//# sourceMappingURL=node_modules_%40zag-js_38dca92d._.js.map